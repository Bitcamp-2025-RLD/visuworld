[
  {
    "id": "Xds3zN",
    "title": "Raymarching - Primitives",
    "description": "A set of raw primitives. All except the ellipsoid are exact euclidean distances. More info here: [url=https://iquilezles.org/articles/distfunctions]https://iquilezles.org/articles/distfunctions[/url]",
    "code": "// The MIT License\n// Copyright \u00a9 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//\n// The license is here only not because I want to (can one\n// license pieces of math?), but because people get upset\n// if I don't add one...\n\n// A list of useful distance function to simple primitives. All\n// these functions (except for ellipsoid) return an exact\n// euclidean distance, meaning they produce a better SDF than\n// what you'd get if you were constructing them from boolean\n// operations (such as cutting an infinite cylinder with two planes).\n\n// List of other 3D SDFs:\n//    https://www.shadertoy.com/playlist/43cXRl\n// and\n//    https://iquilezles.org/articles/distfunctions\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2   // make this 2 or 3 for antialiasing\n#endif\n\n//------------------------------------------------------------------\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdOctogonPrism( in vec3 p, in float r, float h )\n{\n  const vec3 k = vec3(-0.9238795325,   // sqrt(2+sqrt(2))/2 \n                       0.3826834323,   // sqrt(2-sqrt(2))/2\n                       0.4142135623 ); // sqrt(2)-1 \n  // reflections\n  p = abs(p);\n  p.xy -= 2.0*min(dot(vec2( k.x,k.y),p.xy),0.0)*vec2( k.x,k.y);\n  p.xy -= 2.0*min(dot(vec2(-k.x,k.y),p.xy),0.0)*vec2(-k.x,k.y);\n  // polygon side\n  p.xy -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n  vec2 d = vec2( length(p.xy)*sign(p.y), p.z-h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    const float k = sqrt(3.0);\n    h.x *= 0.5*k;\n    p.xy /= h.x;\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    float d1 = length(p.xy)*sign(-p.y)*h.x;\n    float d2 = abs(p.z)-h.y;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// vertical\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\n// vertical\nfloat sdCone( in vec3 p, in vec2 c, float h )\n{\n    vec2 q = h*vec2(c.x,-c.y)/c.y;\n    vec2 w = vec2( length(p.xz), p.y );\n    \n\tvec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n    float k = sign( q.y );\n    float d = min(dot( a, a ),dot(b, b));\n    float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n\treturn sqrt(d)*sign(s);\n}\n\nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n\n    float x = sqrt( papa - paba*paba*baba );\n\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    \n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n\n// c is the sin/cos of the desired cone angle\nfloat sdSolidAngle(vec3 pos, vec2 c, float ra)\n{\n    vec2 p = vec2( length(pos.xz), pos.y );\n    float l = length(p) - ra;\n\tfloat m = length(p - c*clamp(dot(p,c),0.0,ra) );\n    return max(l,m*sign(c.y*p.x-c.x*p.y));\n}\n\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    float m = p.x + p.y + p.z - s;\n\n    // exact distance\n    #if 0\n    vec3 o = min(3.0*p - m, 0.0);\n    o = max(6.0*p - m*2.0 - o*3.0 + (o.x+o.y+o.z), 0.0);\n    return length(p - s*o/(o.x+o.y+o.z));\n    #endif\n    \n    // exact distance\n    #if 1\n \tvec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n    #endif\n    \n    // bound, not exact\n    #if 0\n\treturn m*0.57735027;\n    #endif\n}\n\nfloat sdPyramid( in vec3 p, in float h )\n{\n    float m2 = h*h + 0.25;\n    \n    // symmetry\n    p.xz = abs(p.xz);\n    p.xz = (p.z>p.x) ? p.zx : p.xz;\n    p.xz -= 0.5;\n\t\n    // project into face plane (2D)\n    vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n    float s = max(-q.x,0.0);\n    float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n    float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n\tfloat b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n    float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n    // recover 3D and scale, and add sign\n    return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));;\n}\n\n// la,lb=semi axis, h=height, ra=corner\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra)\n{\n    p = abs(p);\n    vec2 b = vec2(la,lb);\n    float f = clamp( (ndot(b,b-2.0*p.xz))/dot(b,b), -1.0, 1.0 );\n\tvec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\nfloat sdHorseshoe( in vec3 p, in vec2 c, in float r, in float le, vec2 w )\n{\n    p.x = abs(p.x);\n    float l = length(p.xy);\n    p.xy = mat2(-c.x, c.y, \n              c.y, c.x)*p.xy;\n    p.xy = vec2((p.y>0.0 || p.x>0.0)?p.x:l*sign(-c.x),\n                (p.x>0.0)?p.y:l );\n    p.xy = vec2(p.x,abs(p.y-r))-vec2(le,0.0);\n    \n    vec2 q = vec2(length(max(p.xy,0.0)) + min(0.0,max(p.x,p.y)),p.z);\n    vec2 d = abs(q) - w;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdU( in vec3 p, in float r, in float le, vec2 w )\n{\n    p.x = (p.y>0.0) ? abs(p.x) : length(p.xy);\n    p.x = abs(p.x-r);\n    p.y = p.y - le;\n    float k = max(p.x,p.y);\n    vec2 q = vec2( (k<0.0) ? -k : length(max(p.xy,0.0)), abs(p.z) ) - w;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\n//------------------------------------------------------------------\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2( pos.y, 0.0 );\n\n    // bounding box\n    if( sdBox( pos-vec3(-2.0,0.3,0.25),vec3(0.3,0.3,1.0) )<res.x )\n    {\n      res = opU( res, vec2( sdSphere(    pos-vec3(-2.0,0.25, 0.0), 0.25 ), 26.9 ) );\n\t  res = opU( res, vec2( sdRhombus(  (pos-vec3(-2.0,0.25, 1.0)).xzy, 0.15, 0.25, 0.04, 0.08 ),17.0 ) );\n    }\n\n    // bounding box\n    if( sdBox( pos-vec3(0.0,0.3,-1.0),vec3(0.35,0.3,2.5) )<res.x )\n    {\n\tres = opU( res, vec2( sdCappedTorus((pos-vec3( 0.0,0.30, 1.0))*vec3(1,-1,1), vec2(0.866025,-0.5), 0.25, 0.05), 25.0) );\n    res = opU( res, vec2( sdBoxFrame(    pos-vec3( 0.0,0.25, 0.0), vec3(0.3,0.25,0.2), 0.025 ), 16.9 ) );\n\tres = opU( res, vec2( sdCone(        pos-vec3( 0.0,0.45,-1.0), vec2(0.6,0.8),0.45 ), 55.0 ) );\n    res = opU( res, vec2( sdCappedCone(  pos-vec3( 0.0,0.25,-2.0), 0.25, 0.25, 0.1 ), 13.67 ) );\n    res = opU( res, vec2( sdSolidAngle(  pos-vec3( 0.0,0.00,-3.0), vec2(3,4)/5.0, 0.4 ), 49.13 ) );\n    }\n\n    // bounding box\n    if( sdBox( pos-vec3(1.0,0.3,-1.0),vec3(0.35,0.3,2.5) )<res.x )\n    {\n\tres = opU( res, vec2( sdTorus(      (pos-vec3( 1.0,0.30, 1.0)).xzy, vec2(0.25,0.05) ), 7.1 ) );\n    res = opU( res, vec2( sdBox(         pos-vec3( 1.0,0.25, 0.0), vec3(0.3,0.25,0.1) ), 3.0 ) );\n    res = opU( res, vec2( sdCapsule(     pos-vec3( 1.0,0.00,-1.0),vec3(-0.1,0.1,-0.1), vec3(0.2,0.4,0.2), 0.1  ), 31.9 ) );\n\tres = opU( res, vec2( sdCylinder(    pos-vec3( 1.0,0.25,-2.0), vec2(0.15,0.25) ), 8.0 ) );\n    res = opU( res, vec2( sdHexPrism(    pos-vec3( 1.0,0.2,-3.0), vec2(0.2,0.05) ), 18.4 ) );\n    }\n\n    // bounding box\n    if( sdBox( pos-vec3(-1.0,0.35,-1.0),vec3(0.35,0.35,2.5))<res.x )\n    {\n\tres = opU( res, vec2( sdPyramid(    pos-vec3(-1.0,-0.6,-3.0), 1.0 ), 13.56 ) );\n\tres = opU( res, vec2( sdOctahedron( pos-vec3(-1.0,0.15,-2.0), 0.35 ), 23.56 ) );\n    res = opU( res, vec2( sdTriPrism(   pos-vec3(-1.0,0.15,-1.0), vec2(0.3,0.05) ),43.5 ) );\n    res = opU( res, vec2( sdEllipsoid(  pos-vec3(-1.0,0.25, 0.0), vec3(0.2, 0.25, 0.05) ), 43.17 ) );\n    res = opU( res, vec2( sdHorseshoe(  pos-vec3(-1.0,0.25, 1.0), vec2(cos(1.3),sin(1.3)), 0.2, 0.3, vec2(0.03,0.08) ), 11.5 ) );\n    }\n\n    // bounding box\n    if( sdBox( pos-vec3(2.0,0.3,-1.0),vec3(0.35,0.3,2.5) )<res.x )\n    {\n    res = opU( res, vec2( sdOctogonPrism(pos-vec3( 2.0,0.2,-3.0), 0.2, 0.05), 51.8 ) );\n    res = opU( res, vec2( sdCylinder(    pos-vec3( 2.0,0.14,-2.0), vec3(0.1,-0.1,0.0), vec3(-0.2,0.35,0.1), 0.08), 31.2 ) );\n\tres = opU( res, vec2( sdCappedCone(  pos-vec3( 2.0,0.09,-1.0), vec3(0.1,0.0,0.0), vec3(-0.2,0.40,0.1), 0.15, 0.05), 46.1 ) );\n    res = opU( res, vec2( sdRoundCone(   pos-vec3( 2.0,0.15, 0.0), vec3(0.1,0.0,0.0), vec3(-0.1,0.35,0.1), 0.15, 0.05), 51.7 ) );\n    res = opU( res, vec2( sdRoundCone(   pos-vec3( 2.0,0.20, 1.0), 0.2, 0.1, 0.3 ), 37.0 ) );\n    }\n    \n    return res;\n}\n\n// https://iquilezles.org/articles/boxfunctions\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\treturn vec2( max( max( t1.x, t1.y ), t1.z ),\n\t             min( min( t2.x, t2.y ), t2.z ) );\n}\n\nvec2 raycast( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    // raytrace floor plane\n    float tp1 = (0.0-ro.y)/rd.y;\n    if( tp1>0.0 )\n    {\n        tmax = min( tmax, tp1 );\n        res = vec2( tp1, 1.0 );\n    }\n    //else return res;\n    \n    // raymarch primitives   \n    vec2 tb = iBox( ro-vec3(0.0,0.4,-0.5), rd, vec3(2.5,0.41,3.0) );\n    if( tb.x<tb.y && tb.y>0.0 && tb.x<tmax)\n    {\n        //return vec2(tb.x,2.0);\n        tmin = max(tb.x,tmin);\n        tmax = min(tb.y,tmax);\n\n        float t = tmin;\n        for( int i=0; i<70 && t<tmax; i++ )\n        {\n            vec2 h = map( ro+rd*t );\n            if( abs(h.x)<(0.0001*t) )\n            { \n                res = vec2(t,h.y); \n                break;\n            }\n            t += h.x;\n        }\n    }\n    \n    return res;\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (0.8-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<24; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s );\n        t += clamp( h, 0.01, 0.2 );\n        if( res<0.004 || t>tmax ) break;\n    }\n    res = clamp( res, 0.0, 1.0 );\n    return res*res*(3.0-2.0*res);\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n#endif    \n}\n\n// https://iquilezles.org/articles/nvscene2008/rwwtt.pdf\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n// https://iquilezles.org/articles/checkerfiltering\nfloat checkersGradBox( in vec2 p, in vec2 dpdx, in vec2 dpdy )\n{\n    // filter kernel\n    vec2 w = abs(dpdx)+abs(dpdy) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 render( in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy )\n{ \n    // background\n    vec3 col = vec3(0.7, 0.7, 0.9) - max(rd.y,0.0)*0.3;\n    \n    // raycast scene\n    vec2 res = raycast(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = (m<1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n        col = 0.2 + 0.2*sin( m*2.0 + vec3(0.0,1.0,2.0) );\n        float ks = 1.0;\n        \n        if( m<1.5 )\n        {\n            // project pixel footprint into the plane\n            vec3 dpdx = ro.y*(rd/rd.y-rdx/rdx.y);\n            vec3 dpdy = ro.y*(rd/rd.y-rdy/rdy.y);\n\n            float f = checkersGradBox( 3.0*pos.xz, 3.0*dpdx.xz, 3.0*dpdy.xz );\n            col = 0.15 + f*vec3(0.05);\n            ks = 0.4;\n        }\n\n        // lighting\n        float occ = calcAO( pos, nor );\n        \n\t\tvec3 lin = vec3(0.0);\n\n        // sun\n        {\n            vec3  lig = normalize( vec3(-0.5, 0.4, -0.6) );\n            vec3  hal = normalize( lig-rd );\n            float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n          //if( dif>0.0001 )\n        \t      dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n\t\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0);\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0-dot(hal,lig),0.0,1.0),5.0);\n                //spe *= 0.04+0.96*pow(clamp(1.0-sqrt(0.5*(1.0-dot(rd,lig))),0.0,1.0),5.0);\n            lin += col*2.20*dif*vec3(1.30,1.00,0.70);\n            lin +=     5.00*spe*vec3(1.30,1.00,0.70)*ks;\n        }\n        // sky\n        {\n            float dif = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n                  dif *= occ;\n            float spe = smoothstep( -0.2, 0.2, ref.y );\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0+dot(nor,rd),0.0,1.0), 5.0 );\n          //if( spe>0.001 )\n                  spe *= calcSoftshadow( pos, ref, 0.02, 2.5 );\n            lin += col*0.60*dif*vec3(0.40,0.60,1.15);\n            lin +=     2.00*spe*vec3(0.40,0.60,1.30)*ks;\n        }\n        // back\n        {\n        \tfloat dif = clamp( dot( nor, normalize(vec3(0.5,0.0,0.6))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n                  dif *= occ;\n        \tlin += col*0.55*dif*vec3(0.25,0.25,0.25);\n        }\n        // sss\n        {\n            float dif = pow(clamp(1.0+dot(nor,rd),0.0,1.0),2.0);\n                  dif *= occ;\n        \tlin += col*0.25*dif*vec3(1.00,1.00,1.00);\n        }\n        \n\t\tcol = lin;\n\n        col = mix( col, vec3(0.7,0.7,0.9), 1.0-exp( -0.0001*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 32.0 + iTime*1.5;\n\n    // camera\t\n    vec3 ta = vec3( 0.25, -0.75, -0.75 );\n    vec3 ro = ta + vec3( 4.5*cos(0.1*time + 7.0*mo.x), 2.2, 4.5*sin(0.1*time + 7.0*mo.x) );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n\n        // focal length\n        const float fl = 2.5;\n        \n        // ray direction\n        vec3 rd = ca * normalize( vec3(p,fl) );\n\n         // ray differentials\n        vec2 px = (2.0*(fragCoord+vec2(1.0,0.0))-iResolution.xy)/iResolution.y;\n        vec2 py = (2.0*(fragCoord+vec2(0.0,1.0))-iResolution.xy)/iResolution.y;\n        vec3 rdx = ca * normalize( vec3(px,fl) );\n        vec3 rdy = ca * normalize( vec3(py,fl) );\n        \n        // render\t\n        vec3 col = render( ro, rd, rdx, rdy );\n\n        // gain\n        // col = col*3.0/(2.5+col);\n        \n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n    \n    fragColor = vec4( tot, 1.0 );\n}",
    "tags": [
      "procedural",
      "3d",
      "raymarching",
      "distancefields",
      "primitives"
    ],
    "author": "iq",
    "views": 0,
    "likes": 1798,
    "published": 3
  },
  {
    "id": "Ms2SD1",
    "title": "Seascape",
    "description": "fully-procedural sea surface computing. without textures.\n\nAndroid version: https://play.google.com/store/apps/details?id=com.nature.seascape\nInsta: https://www.instagram.com/seascapebenchmark/\t",
    "code": "/*\n * \"Seascape\" by Alexander Alekseev aka TDM - 2014\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * Contact: tdmaav@gmail.com\n */\n\nconst int NUM_STEPS = 32;\nconst float PI\t \t= 3.141592;\nconst float EPSILON\t= 1e-3;\n#define EPSILON_NRM (0.1 / iResolution.x)\n//#define AA\n\n// sea\nconst int ITER_GEOMETRY = 3;\nconst int ITER_FRAGMENT = 5;\nconst float SEA_HEIGHT = 0.6;\nconst float SEA_CHOPPY = 4.0;\nconst float SEA_SPEED = 0.8;\nconst float SEA_FREQ = 0.16;\nconst vec3 SEA_BASE = vec3(0.0,0.09,0.18);\nconst vec3 SEA_WATER_COLOR = vec3(0.8,0.9,0.6)*0.6;\n#define SEA_TIME (1.0 + iTime * SEA_SPEED)\nconst mat2 octave_m = mat2(1.6,1.2,-1.2,1.6);\n\n// math\nmat3 fromEuler(vec3 ang) {\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    mat3 m;\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\n\tm[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\n\tm[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\n\treturn m;\n}\nfloat hash( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// lighting\nfloat diffuse(vec3 n,vec3 l,float p) {\n    return pow(dot(n,l) * 0.4 + 0.6,p);\n}\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \n    float nrm = (s + 8.0) / (PI * 8.0);\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\n}\n\n// sky\nvec3 getSkyColor(vec3 e) {\n    e.y = (max(e.y,0.0)*0.8+0.2)*0.8;\n    return vec3(pow(1.0-e.y,2.0), 1.0-e.y, 0.6+(1.0-e.y)*0.4) * 1.1;\n}\n\n// sea\nfloat sea_octave(vec2 uv, float choppy) {\n    uv += noise(uv);        \n    vec2 wv = 1.0-abs(sin(uv));\n    vec2 swv = abs(cos(uv));    \n    wv = mix(wv,swv,wv);\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\n}\n\nfloat map(vec3 p) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    \n    float d, h = 0.0;    \n    for(int i = 0; i < ITER_GEOMETRY; i++) {        \n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\n        h += d * amp;        \n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\nfloat map_detailed(vec3 p) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    \n    float d, h = 0.0;    \n    for(int i = 0; i < ITER_FRAGMENT; i++) {        \n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\n        h += d * amp;        \n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\nvec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist) {  \n    float fresnel = clamp(1.0 - dot(n, -eye), 0.0, 1.0);\n    fresnel = min(fresnel * fresnel * fresnel, 0.5);\n    \n    vec3 reflected = getSkyColor(reflect(eye, n));    \n    vec3 refracted = SEA_BASE + diffuse(n, l, 80.0) * SEA_WATER_COLOR * 0.12; \n    \n    vec3 color = mix(refracted, reflected, fresnel);\n    \n    float atten = max(1.0 - dot(dist, dist) * 0.001, 0.0);\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\n    \n    color += specular(n, l, eye, 60.0);\n    \n    return color;\n}\n\n// tracing\nvec3 getNormal(vec3 p, float eps) {\n    vec3 n;\n    n.y = map_detailed(p);    \n    n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - n.y;\n    n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - n.y;\n    n.y = eps;\n    return normalize(n);\n}\n\nfloat heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {  \n    float tm = 0.0;\n    float tx = 1000.0;    \n    float hx = map(ori + dir * tx);\n    if(hx > 0.0) {\n        p = ori + dir * tx;\n        return tx;   \n    }\n    float hm = map(ori);    \n    for(int i = 0; i < NUM_STEPS; i++) {\n        float tmid = mix(tm, tx, hm / (hm - hx));\n        p = ori + dir * tmid;\n        float hmid = map(p);        \n        if(hmid < 0.0) {\n            tx = tmid;\n            hx = hmid;\n        } else {\n            tm = tmid;\n            hm = hmid;\n        }        \n        if(abs(hmid) < EPSILON) break;\n    }\n    return mix(tm, tx, hm / (hm - hx));\n}\n\nvec3 getPixel(in vec2 coord, float time) {    \n    vec2 uv = coord / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;    \n        \n    // ray\n    vec3 ang = vec3(sin(time*3.0)*0.1,sin(time)*0.2+0.3,time);    \n    vec3 ori = vec3(0.0,3.5,time*5.0);\n    vec3 dir = normalize(vec3(uv.xy,-2.0)); dir.z += length(uv) * 0.14;\n    dir = normalize(dir) * fromEuler(ang);\n    \n    // tracing\n    vec3 p;\n    heightMapTracing(ori,dir,p);\n    vec3 dist = p - ori;\n    vec3 n = getNormal(p, dot(dist,dist) * EPSILON_NRM);\n    vec3 light = normalize(vec3(0.0,1.0,0.8)); \n             \n    // color\n    return mix(\n        getSkyColor(dir),\n        getSeaColor(p,n,light,dir,dist),\n    \tpow(smoothstep(0.0,-0.02,dir.y),0.2));\n}\n\n// main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float time = iTime * 0.3 + iMouse.x*0.01;\n\t\n#ifdef AA\n    vec3 color = vec3(0.0);\n    for(int i = -1; i <= 1; i++) {\n        for(int j = -1; j <= 1; j++) {\n        \tvec2 uv = fragCoord+vec2(i,j)/3.0;\n    \t\tcolor += getPixel(uv, time);\n        }\n    }\n    color /= 9.0;\n#else\n    vec3 color = getPixel(fragCoord, time);\n#endif\n    \n    // post\n\tfragColor = vec4(pow(color,vec3(0.65)), 1.0);\n}",
    "tags": [
      "procedural",
      "noise",
      "waves",
      "sea",
      "water",
      "subsurface"
    ],
    "author": "TDM",
    "views": 0,
    "likes": 3136,
    "published": 3
  },
  {
    "id": "XsXXDn",
    "title": "Creation by Silexars",
    "description": "My first demoscene release. Achieved second place @ DemoJS 2011. It has been said to be the first 1k WebGL intro ever released.",
    "code": "// http://www.pouet.net/prod.php?which=57245\n// If you intend to reuse this shader, please add credits to 'Danilo Guanabara'\n\n#define t iTime\n#define r iResolution.xy\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec3 c;\n\tfloat l,z=t;\n\tfor(int i=0;i<3;i++) {\n\t\tvec2 uv,p=fragCoord.xy/r;\n\t\tuv=p;\n\t\tp-=.5;\n\t\tp.x*=r.x/r.y;\n\t\tz+=.07;\n\t\tl=length(p);\n\t\tuv+=p/l*(sin(z)+1.)*abs(sin(l*9.-z-z));\n\t\tc[i]=.01/length(mod(uv,1.)-.5);\n\t}\n\tfragColor=vec4(c/l,t);\n}",
    "tags": [
      "intro",
      "silexars",
      "1k",
      "demojs"
    ],
    "author": "Danguafer",
    "views": 0,
    "likes": 1646,
    "published": 3
  },
  {
    "id": "Wt33Wf",
    "title": "Cyber Fuji 2020",
    "description": "A Happy New Yeahhhhhhhhhhhhhhhhhh!!!!!!!!!!!!!",
    "code": "\nfloat sun(vec2 uv, float battery)\n{\n \tfloat val = smoothstep(0.3, 0.29, length(uv));\n \tfloat bloom = smoothstep(0.7, 0.0, length(uv));\n    float cut = 3.0 * sin((uv.y + iTime * 0.2 * (battery + 0.02)) * 100.0) \n\t\t\t\t+ clamp(uv.y * 14.0 + 1.0, -6.0, 6.0);\n    cut = clamp(cut, 0.0, 1.0);\n    return clamp(val * cut, 0.0, 1.0) + bloom * 0.6;\n}\n\nfloat grid(vec2 uv, float battery)\n{\n    vec2 size = vec2(uv.y, uv.y * uv.y * 0.2) * 0.01;\n    uv += vec2(0.0, iTime * 4.0 * (battery + 0.05));\n    uv = abs(fract(uv) - 0.5);\n \tvec2 lines = smoothstep(size, vec2(0.0), uv);\n \tlines += smoothstep(size * 5.0, vec2(0.0), uv) * 0.4 * battery;\n    return clamp(lines.x + lines.y, 0.0, 3.0);\n}\n\nfloat dot2(in vec2 v ) { return dot(v,v); }\n\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n    p.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x,(p.y<0.0)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k){\n\tfloat h = clamp(0.5 + 0.5 * (d2 - d1) /k,0.0,1.0);\n    return mix(d2, d1 , h) - k * h * ( 1.0 - h);\n}\n\nfloat sdCloud(in vec2 p, in vec2 a1, in vec2 b1, in vec2 a2, in vec2 b2, float w)\n{\n\t//float lineVal1 = smoothstep(w - 0.0001, w, sdLine(p, a1, b1));\n    float lineVal1 = sdLine(p, a1, b1);\n    float lineVal2 = sdLine(p, a2, b2);\n    vec2 ww = vec2(w*1.5, 0.0);\n    vec2 left = max(a1 + ww, a2 + ww);\n    vec2 right = min(b1 - ww, b2 - ww);\n    vec2 boxCenter = (left + right) * 0.5;\n    //float boxW = right.x - left.x;\n    float boxH = abs(a2.y - a1.y) * 0.5;\n    //float boxVal = sdBox(p - boxCenter, vec2(boxW, boxH)) + w;\n    float boxVal = sdBox(p - boxCenter, vec2(0.04, boxH)) + w;\n    \n    float uniVal1 = opSmoothUnion(lineVal1, boxVal, 0.05);\n    float uniVal2 = opSmoothUnion(lineVal2, boxVal, 0.05);\n    \n    return min(uniVal1, uniVal2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord.xy - iResolution.xy)/iResolution.y;\n    float battery = 1.0;\n    //if (iMouse.x > 1.0 && iMouse.y > 1.0) battery = iMouse.y / iResolution.y;\n    //else battery = 0.8;\n    \n    //if (abs(uv.x) < (9.0 / 16.0))\n    {\n        // Grid\n        float fog = smoothstep(0.1, -0.02, abs(uv.y + 0.2));\n        vec3 col = vec3(0.0, 0.1, 0.2);\n        if (uv.y < -0.2)\n        {\n            uv.y = 3.0 / (abs(uv.y + 0.2) + 0.05);\n            uv.x *= uv.y * 1.0;\n            float gridVal = grid(uv, battery);\n            col = mix(col, vec3(1.0, 0.5, 1.0), gridVal);\n        }\n        else\n        {\n            float fujiD = min(uv.y * 4.5 - 0.5, 1.0);\n            uv.y -= battery * 1.1 - 0.51;\n            \n            vec2 sunUV = uv;\n            vec2 fujiUV = uv;\n            \n            // Sun\n            sunUV += vec2(0.75, 0.2);\n            //uv.y -= 1.1 - 0.51;\n            col = vec3(1.0, 0.2, 1.0);\n            float sunVal = sun(sunUV, battery);\n            \n            col = mix(col, vec3(1.0, 0.4, 0.1), sunUV.y * 2.0 + 0.2);\n            col = mix(vec3(0.0, 0.0, 0.0), col, sunVal);\n            \n            // fuji\n            float fujiVal = sdTrapezoid( uv  + vec2(-0.75+sunUV.y * 0.0, 0.5), 1.75 + pow(uv.y * uv.y, 2.1), 0.2, 0.5);\n            float waveVal = uv.y + sin(uv.x * 20.0 + iTime * 2.0) * 0.05 + 0.2;\n            float wave_width = smoothstep(0.0,0.01,(waveVal));\n            \n            // fuji color\n            col = mix( col, mix(vec3(0.0, 0.0, 0.25), vec3(1.0, 0.0, 0.5), fujiD), step(fujiVal, 0.0));\n            // fuji top snow\n            col = mix( col, vec3(1.0, 0.5, 1.0), wave_width * step(fujiVal, 0.0));\n            // fuji outline\n            col = mix( col, vec3(1.0, 0.5, 1.0), 1.0-smoothstep(0.0,0.01,abs(fujiVal)) );\n            //col = mix( col, vec3(1.0, 1.0, 1.0), 1.0-smoothstep(0.03,0.04,abs(fujiVal)) );\n            //col = vec3(1.0, 1.0, 1.0) *(1.0-smoothstep(0.03,0.04,abs(fujiVal)));\n            \n            // horizon color\n            col += mix( col, mix(vec3(1.0, 0.12, 0.8), vec3(0.0, 0.0, 0.2), clamp(uv.y * 3.5 + 3.0, 0.0, 1.0)), step(0.0, fujiVal) );\n            \n            // cloud\n            vec2 cloudUV = uv;\n            cloudUV.x = mod(cloudUV.x + iTime * 0.1, 4.0) - 2.0;\n            float cloudTime = iTime * 0.5;\n            float cloudY = -0.5;\n            float cloudVal1 = sdCloud(cloudUV, \n                                     vec2(0.1 + sin(cloudTime + 140.5)*0.1,cloudY), \n                                     vec2(1.05 + cos(cloudTime * 0.9 - 36.56) * 0.1, cloudY), \n                                     vec2(0.2 + cos(cloudTime * 0.867 + 387.165) * 0.1,0.25+cloudY), \n                                     vec2(0.5 + cos(cloudTime * 0.9675 - 15.162) * 0.09, 0.25+cloudY), 0.075);\n            cloudY = -0.6;\n            float cloudVal2 = sdCloud(cloudUV, \n                                     vec2(-0.9 + cos(cloudTime * 1.02 + 541.75) * 0.1,cloudY), \n                                     vec2(-0.5 + sin(cloudTime * 0.9 - 316.56) * 0.1, cloudY), \n                                     vec2(-1.5 + cos(cloudTime * 0.867 + 37.165) * 0.1,0.25+cloudY), \n                                     vec2(-0.6 + sin(cloudTime * 0.9675 + 665.162) * 0.09, 0.25+cloudY), 0.075);\n            \n            float cloudVal = min(cloudVal1, cloudVal2);\n            \n            //col = mix(col, vec3(1.0,1.0,0.0), smoothstep(0.0751, 0.075, cloudVal));\n            col = mix(col, vec3(0.0, 0.0, 0.2), 1.0 - smoothstep(0.075 - 0.0001, 0.075, cloudVal));\n            col += vec3(1.0, 1.0, 1.0)*(1.0 - smoothstep(0.0,0.01,abs(cloudVal - 0.075)));\n        }\n\n        col += fog * fog * fog;\n        col = mix(vec3(col.r, col.r, col.r) * 0.5, col, battery * 0.7);\n\n        fragColor = vec4(col,1.0);\n    }\n    //else fragColor = vec4(0.0);\n\n    \n}",
    "tags": [
      "sun",
      "80s",
      "retro",
      "fuji",
      "cineshader"
    ],
    "author": "kaiware007",
    "views": 0,
    "likes": 554,
    "published": 3
  },
  {
    "id": "ssjyWc",
    "title": "Lover 2",
    "description": "Fork of \"Lover\" by wyatt. https://shadertoy.com/view/fsjyR3  \ntrying to mimic Karthik Dondeti https://twitter.com/d0ndeti/status/1479814051366539264 series.\n\n- A:use close curve, starting as circle. k partics\n- I: basic drawing\nstill, there are crossings.",
    "code": "// Fork of \"Lover\" by wyatt. https://shadertoy.com/view/fsjyR3\n// 2022-02-07 18:41:05\n\nMain  Q = B( U ).zzzz; }\n",
    "tags": [
      "paper",
      "reproduction",
      "dondeti"
    ],
    "author": "FabriceNeyret2",
    "views": 0,
    "likes": 450,
    "published": 3
  },
  {
    "id": "tlVGDt",
    "title": "Octagrams",
    "description": "Inspired by arabesque.\nhttps://cineshader.com/editor",
    "code": "precision highp float;\n\n\nfloat gTime = 0.;\nconst float REPEAT = 5.0;\n\n// \u56de\u8ee2\u884c\u5217\nmat2 rot(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c,s,-s,c);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n\tvec3 q = abs(p) - b;\n\treturn length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat box(vec3 pos, float scale) {\n\tpos *= scale;\n\tfloat base = sdBox(pos, vec3(.4,.4,.1)) /1.5;\n\tpos.xy *= 5.;\n\tpos.y -= 3.5;\n\tpos.xy *= rot(.75);\n\tfloat result = -base;\n\treturn result;\n}\n\nfloat box_set(vec3 pos, float iTime) {\n\tvec3 pos_origin = pos;\n\tpos = pos_origin;\n\tpos .y += sin(gTime * 0.4) * 2.5;\n\tpos.xy *=   rot(.8);\n\tfloat box1 = box(pos,2. - abs(sin(gTime * 0.4)) * 1.5);\n\tpos = pos_origin;\n\tpos .y -=sin(gTime * 0.4) * 2.5;\n\tpos.xy *=   rot(.8);\n\tfloat box2 = box(pos,2. - abs(sin(gTime * 0.4)) * 1.5);\n\tpos = pos_origin;\n\tpos .x +=sin(gTime * 0.4) * 2.5;\n\tpos.xy *=   rot(.8);\n\tfloat box3 = box(pos,2. - abs(sin(gTime * 0.4)) * 1.5);\t\n\tpos = pos_origin;\n\tpos .x -=sin(gTime * 0.4) * 2.5;\n\tpos.xy *=   rot(.8);\n\tfloat box4 = box(pos,2. - abs(sin(gTime * 0.4)) * 1.5);\t\n\tpos = pos_origin;\n\tpos.xy *=   rot(.8);\n\tfloat box5 = box(pos,.5) * 6.;\t\n\tpos = pos_origin;\n\tfloat box6 = box(pos,.5) * 6.;\t\n\tfloat result = max(max(max(max(max(box1,box2),box3),box4),box5),box6);\n\treturn result;\n}\n\nfloat map(vec3 pos, float iTime) {\n\tvec3 pos_origin = pos;\n\tfloat box_set1 = box_set(pos, iTime);\n\n\treturn box_set1;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 p = (fragCoord.xy * 2. - iResolution.xy) / min(iResolution.x, iResolution.y);\n\tvec3 ro = vec3(0., -0.2 ,iTime * 4.);\n\tvec3 ray = normalize(vec3(p, 1.5));\n\tray.xy = ray.xy * rot(sin(iTime * .03) * 5.);\n\tray.yz = ray.yz * rot(sin(iTime * .05) * .2);\n\tfloat t = 0.1;\n\tvec3 col = vec3(0.);\n\tfloat ac = 0.0;\n\n\n\tfor (int i = 0; i < 99; i++){\n\t\tvec3 pos = ro + ray * t;\n\t\tpos = mod(pos-2., 4.) -2.;\n\t\tgTime = iTime -float(i) * 0.01;\n\t\t\n\t\tfloat d = map(pos, iTime);\n\n\t\td = max(abs(d), 0.01);\n\t\tac += exp(-d*23.);\n\n\t\tt += d* 0.55;\n\t}\n\n\tcol = vec3(ac * 0.02);\n\n\tcol +=vec3(0.,0.2 * abs(sin(iTime)),0.5 + sin(iTime) * 0.2);\n\n\n\tfragColor = vec4(col ,1.0 - t * (0.02 + 0.02 * sin (iTime)));\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"Octgrams\",\n\t\"description\": \"Lorem ipsum dolor\",\n\t\"model\": \"person\"\n}\n*/",
    "tags": [
      "raymarching",
      "cineshader"
    ],
    "author": "whisky_shusuky",
    "views": 0,
    "likes": 586,
    "published": 3
  },
  {
    "id": "tsXBzS",
    "title": "fractal pyramid",
    "description": "Creating multiple shapes with one SDF evaluation by repeatedly rotating and folding space",
    "code": "vec3 palette(float d){\n\treturn mix(vec3(0.2,0.7,0.9),vec3(1.,0.,1.),d);\n}\n\nvec2 rotate(vec2 p,float a){\n\tfloat c = cos(a);\n    float s = sin(a);\n    return p*mat2(c,s,-s,c);\n}\n\nfloat map(vec3 p){\n    for( int i = 0; i<8; ++i){\n        float t = iTime*0.2;\n        p.xz =rotate(p.xz,t);\n        p.xy =rotate(p.xy,t*1.89);\n        p.xz = abs(p.xz);\n        p.xz-=.5;\n\t}\n\treturn dot(sign(p),p)/5.;\n}\n\nvec4 rm (vec3 ro, vec3 rd){\n    float t = 0.;\n    vec3 col = vec3(0.);\n    float d;\n    for(float i =0.; i<64.; i++){\n\t\tvec3 p = ro + rd*t;\n        d = map(p)*.5;\n        if(d<0.02){\n            break;\n        }\n        if(d>100.){\n        \tbreak;\n        }\n        //col+=vec3(0.6,0.8,0.8)/(400.*(d));\n        col+=palette(length(p)*.1)/(400.*(d));\n        t+=d;\n    }\n    return vec4(col,1./(d*100.));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-(iResolution.xy/2.))/iResolution.x;\n\tvec3 ro = vec3(0.,0.,-50.);\n    ro.xz = rotate(ro.xz,iTime);\n    vec3 cf = normalize(-ro);\n    vec3 cs = normalize(cross(cf,vec3(0.,1.,0.)));\n    vec3 cu = normalize(cross(cf,cs));\n    \n    vec3 uuv = ro+cf*3. + uv.x*cs + uv.y*cu;\n    \n    vec3 rd = normalize(uuv-ro);\n    \n    vec4 col = rm(ro,rd);\n    \n    \n    fragColor = col;\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"fractal pyramid\",\n\t\"description\": \"\",\n\t\"model\": \"car\"\n}\n*/",
    "tags": [
      "fractalcineshader"
    ],
    "author": "bradjamesgrant",
    "views": 0,
    "likes": 757,
    "published": 3
  },
  {
    "id": "3sySRK",
    "title": "CineShader Lava",
    "description": "Simple ray marching template. View this shader at [url]https://cineshader.com/view/3sySRK[/url]",
    "code": "float opSmoothUnion( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n} \n\nfloat map(vec3 p)\n{\n\tfloat d = 2.0;\n\tfor (int i = 0; i < 16; i++) {\n\t\tfloat fi = float(i);\n\t\tfloat time = iTime * (fract(fi * 412.531 + 0.513) - 0.5) * 2.0;\n\t\td = opSmoothUnion(\n            sdSphere(p + sin(time + fi * vec3(52.5126, 64.62744, 632.25)) * vec3(2.0, 2.0, 0.8), mix(0.5, 1.0, fract(fi * 412.531 + 0.5124))),\n\t\t\td,\n\t\t\t0.4\n\t\t);\n\t}\n\treturn d;\n}\n\nvec3 calcNormal( in vec3 p )\n{\n    const float h = 1e-5; // or some other value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*h ) + \n                      k.yyx*map( p + k.yyx*h ) + \n                      k.yxy*map( p + k.yxy*h ) + \n                      k.xxx*map( p + k.xxx*h ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // screen size is 6m x 6m\n\tvec3 rayOri = vec3((uv - 0.5) * vec2(iResolution.x/iResolution.y, 1.0) * 6.0, 3.0);\n\tvec3 rayDir = vec3(0.0, 0.0, -1.0);\n\t\n\tfloat depth = 0.0;\n\tvec3 p;\n\t\n\tfor(int i = 0; i < 64; i++) {\n\t\tp = rayOri + rayDir * depth;\n\t\tfloat dist = map(p);\n        depth += dist;\n\t\tif (dist < 1e-6) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n    depth = min(6.0, depth);\n\tvec3 n = calcNormal(p);\n    float b = max(0.0, dot(n, vec3(0.577)));\n    vec3 col = (0.5 + 0.5 * cos((b + iTime * 3.0) + uv.xyx * 2.0 + vec3(0,2,4))) * (0.85 + b * 0.35);\n    col *= exp( -depth * 0.15 );\n\t\n    // maximum thickness is 2m in alpha channel\n    fragColor = vec4(col, 1.0 - (depth - 0.5) / 2.0);\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"My Shader 0\",\n\t\"description\": \"Lorem ipsum dolor\",\n\t\"model\": \"person\"\n}\n*/",
    "tags": [
      "cineshader"
    ],
    "author": "edankwan",
    "views": 0,
    "likes": 470,
    "published": 3
  },
  {
    "id": "MdXSWn",
    "title": "mandelbulb_",
    "description": "a mandelbulb",
    "code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// whether turn on the animation\n//#define phase_shift_on \n\nfloat stime, ctime;\n void ry(inout vec3 p, float a){  \n \tfloat c,s;vec3 q=p;  \n  \tc = cos(a); s = sin(a);  \n  \tp.x = c * q.x + s * q.z;  \n  \tp.z = -s * q.x + c * q.z; \n }  \n\nfloat pixel_size = 0.0;\n\n/* \n\nz = r*(sin(theta)cos(phi) + i cos(theta) + j sin(theta)sin(phi)\n\nzn+1 = zn^8 +c\n\nz^8 = r^8 * (sin(8*theta)*cos(8*phi) + i cos(8*theta) + j sin(8*theta)*sin(8*theta)\n\nzn+1' = 8 * zn^7 * zn' + 1\n\n*/\n\nvec3 mb(vec3 p) {\n\tp.xyz = p.xzy;\n\tvec3 z = p;\n\tvec3 dz=vec3(0.0);\n\tfloat power = 8.0;\n\tfloat r, theta, phi;\n\tfloat dr = 1.0;\n\t\n\tfloat t0 = 1.0;\n\tfor(int i = 0; i < 7; ++i) {\n\t\tr = length(z);\n\t\tif(r > 2.0) continue;\n\t\ttheta = atan(z.y / z.x);\n        #ifdef phase_shift_on\n\t\tphi = asin(z.z / r) + iTime*0.1;\n        #else\n        phi = asin(z.z / r);\n        #endif\n\t\t\n\t\tdr = pow(r, power - 1.0) * dr * power + 1.0;\n\t\n\t\tr = pow(r, power);\n\t\ttheta = theta * power;\n\t\tphi = phi * power;\n\t\t\n\t\tz = r * vec3(cos(theta)*cos(phi), sin(theta)*cos(phi), sin(phi)) + p;\n\t\t\n\t\tt0 = min(t0, r);\n\t}\n\treturn vec3(0.5 * log(r) * r / dr, t0, 0.0);\n}\n\n vec3 f(vec3 p){ \n\t ry(p, iTime*0.2);\n     return mb(p); \n } \n\n\n float softshadow(vec3 ro, vec3 rd, float k ){ \n     float akuma=1.0,h=0.0; \n\t float t = 0.01;\n     for(int i=0; i < 50; ++i){ \n         h=f(ro+rd*t).x; \n         if(h<0.001)return 0.02; \n         akuma=min(akuma, k*h/t); \n \t\t t+=clamp(h,0.01,2.0); \n     } \n     return akuma; \n } \n\nvec3 nor( in vec3 pos )\n{\n    vec3 eps = vec3(0.001,0.0,0.0);\n\treturn normalize( vec3(\n           f(pos+eps.xyy).x - f(pos-eps.xyy).x,\n           f(pos+eps.yxy).x - f(pos-eps.yxy).x,\n           f(pos+eps.yyx).x - f(pos-eps.yyx).x ) );\n}\n\nvec3 intersect( in vec3 ro, in vec3 rd )\n{\n    float t = 1.0;\n    float res_t = 0.0;\n    float res_d = 1000.0;\n    vec3 c, res_c;\n    float max_error = 1000.0;\n\tfloat d = 1.0;\n    float pd = 100.0;\n    float os = 0.0;\n    float step = 0.0;\n    float error = 1000.0;\n    \n    for( int i=0; i<48; i++ )\n    {\n        if( error < pixel_size*0.5 || t > 20.0 )\n        {\n        }\n        else{  // avoid broken shader on windows\n        \n            c = f(ro + rd*t);\n            d = c.x;\n\n            if(d > os)\n            {\n                os = 0.4 * d*d/pd;\n                step = d + os;\n                pd = d;\n            }\n            else\n            {\n                step =-os; os = 0.0; pd = 100.0; d = 1.0;\n            }\n\n            error = d / t;\n\n            if(error < max_error) \n            {\n                max_error = error;\n                res_t = t;\n                res_c = c;\n            }\n        \n            t += step;\n        }\n\n    }\n\tif( t>20.0/* || max_error > pixel_size*/ ) res_t=-1.0;\n    return vec3(res_t, res_c.y, res_c.z);\n}\n\n void mainImage( out vec4 fragColor, in vec2 fragCoord ) \n { \n    vec2 q=fragCoord.xy/iResolution.xy; \n \tvec2 uv = -1.0 + 2.0*q; \n \tuv.x*=iResolution.x/iResolution.y; \n     \n    pixel_size = 1.0/(iResolution.x * 3.0);\n\t// camera\n \tstime=0.7+0.3*sin(iTime*0.4); \n \tctime=0.7+0.3*cos(iTime*0.4); \n\n \tvec3 ta=vec3(0.0,0.0,0.0); \n\tvec3 ro = vec3(0.0, 3.*stime*ctime, 3.*(1.-stime*ctime));\n\n \tvec3 cf = normalize(ta-ro); \n    vec3 cs = normalize(cross(cf,vec3(0.0,1.0,0.0))); \n    vec3 cu = normalize(cross(cs,cf)); \n \tvec3 rd = normalize(uv.x*cs + uv.y*cu + 3.0*cf);  // transform from view to world\n\n    vec3 sundir = normalize(vec3(0.1, 0.8, 0.6)); \n    vec3 sun = vec3(1.64, 1.27, 0.99); \n    vec3 skycolor = vec3(0.6, 1.5, 1.0); \n\n\tvec3 bg = exp(uv.y-2.0)*vec3(0.4, 1.6, 1.0);\n\n    float halo=clamp(dot(normalize(vec3(-ro.x, -ro.y, -ro.z)), rd), 0.0, 1.0); \n    vec3 col=bg+vec3(1.0,0.8,0.4)*pow(halo,17.0); \n\n\n    float t=0.0;\n    vec3 p=ro; \n\t \n\tvec3 res = intersect(ro, rd);\n\t if(res.x > 0.0){\n\t\t   p = ro + res.x * rd;\n           vec3 n=nor(p); \n           float shadow = softshadow(p, sundir, 10.0 );\n\n           float dif = max(0.0, dot(n, sundir)); \n           float sky = 0.6 + 0.4 * max(0.0, dot(n, vec3(0.0, 1.0, 0.0))); \n \t\t   float bac = max(0.3 + 0.7 * dot(vec3(-sundir.x, -1.0, -sundir.z), n), 0.0); \n           float spe = max(0.0, pow(clamp(dot(sundir, reflect(rd, n)), 0.0, 1.0), 10.0)); \n\n           vec3 lin = 4.5 * sun * dif * shadow; \n           lin += 0.8 * bac * sun; \n           lin += 0.6 * sky * skycolor*shadow; \n           lin += 3.0 * spe * shadow; \n\n\t\t   res.y = pow(clamp(res.y, 0.0, 1.0), 0.55);\n\t\t   vec3 tc0 = 0.5 + 0.5 * sin(3.0 + 4.2 * res.y + vec3(0.0, 0.5, 1.0));\n           col = lin *vec3(0.9, 0.8, 0.6) *  0.2 * tc0;\n \t\t   col=mix(col,bg, 1.0-exp(-0.001*res.x*res.x)); \n    } \n\n    // post\n    col=pow(clamp(col,0.0,1.0),vec3(0.45)); \n    col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n    col=mix(col, vec3(dot(col, vec3(0.33))), -0.5);  // satuation\n    col*=0.5+0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n \tfragColor = vec4(col.xyz, smoothstep(0.55, .76, 1.-res.x/5.)); \n }",
    "tags": [
      "raymarching",
      "fractal",
      "cineshader"
    ],
    "author": "EvilRyu",
    "views": 0,
    "likes": 330,
    "published": 3
  },
  {
    "id": "ttKGDt",
    "title": "Phantom Star for CineShader",
    "description": "https://cineshader.com/view/ttKGDt",
    "code": "precision highp float;\n\n\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c,s,-s,c);\n}\n\nconst float pi = acos(-1.0);\nconst float pi2 = pi*2.0;\n\nvec2 pmod(vec2 p, float r) {\n    float a = atan(p.x, p.y) + pi/r;\n    float n = pi2 / r;\n    a = floor(a/n)*n;\n    return p*rot(-a);\n}\n\nfloat box( vec3 p, vec3 b ) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat ifsBox(vec3 p) {\n    for (int i=0; i<5; i++) {\n        p = abs(p) - 1.0;\n        p.xy *= rot(iTime*0.3);\n        p.xz *= rot(iTime*0.1);\n    }\n    p.xz *= rot(iTime);\n    return box(p, vec3(0.4,0.8,0.3));\n}\n\nfloat map(vec3 p, vec3 cPos) {\n    vec3 p1 = p;\n    p1.x = mod(p1.x-5., 10.) - 5.;\n    p1.y = mod(p1.y-5., 10.) - 5.;\n    p1.z = mod(p1.z, 16.)-8.;\n    p1.xy = pmod(p1.xy, 5.0);\n    return ifsBox(p1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    vec3 cPos = vec3(0.0,0.0, -3.0 * iTime);\n    // vec3 cPos = vec3(0.3*sin(iTime*0.8), 0.4*cos(iTime*0.3), -6.0 * iTime);\n    vec3 cDir = normalize(vec3(0.0, 0.0, -1.0));\n    vec3 cUp  = vec3(sin(iTime), 1.0, 0.0);\n    vec3 cSide = cross(cDir, cUp);\n\n    vec3 ray = normalize(cSide * p.x + cUp * p.y + cDir);\n\n    // Phantom Mode https://www.shadertoy.com/view/MtScWW by aiekick\n    float acc = 0.0;\n    float acc2 = 0.0;\n    float t = 0.0;\n    for (int i = 0; i < 99; i++) {\n        vec3 pos = cPos + ray * t;\n        float dist = map(pos, cPos);\n        dist = max(abs(dist), 0.02);\n        float a = exp(-dist*3.0);\n        if (mod(length(pos)+24.0*iTime, 30.0) < 3.0) {\n            a *= 2.0;\n            acc2 += a;\n        }\n        acc += a;\n        t += dist * 0.5;\n    }\n\n    vec3 col = vec3(acc * 0.01, acc * 0.011 + acc2*0.002, acc * 0.012+ acc2*0.005);\n    fragColor = vec4(col, 1.0 - t * 0.03);\n}",
    "tags": [
      "raymarching",
      "ifs",
      "phantommode"
    ],
    "author": "kasari39",
    "views": 0,
    "likes": 524,
    "published": 3
  },
  {
    "id": "llXfRr",
    "title": "fractal trees gif",
    "description": "the idea is to rotate the fractal based on distance from the camera.\ni used it to make this gif https://media.giphy.com/media/l2QE1mlTRVy7Y7Hfa/giphy.gif",
    "code": "#define MAXDIST 50.\n\nstruct Ray {\n\tvec3 ro;\n    vec3 rd;\n};\n  \n// from netgrind\nvec3 hue(vec3 color, float shift) {\n\n    const vec3  kRGBToYPrime = vec3 (0.299, 0.587, 0.114);\n    const vec3  kRGBToI     = vec3 (0.596, -0.275, -0.321);\n    const vec3  kRGBToQ     = vec3 (0.212, -0.523, 0.311);\n\n    const vec3  kYIQToR   = vec3 (1.0, 0.956, 0.621);\n    const vec3  kYIQToG   = vec3 (1.0, -0.272, -0.647);\n    const vec3  kYIQToB   = vec3 (1.0, -1.107, 1.704);\n\n    // Convert to YIQ\n    float   YPrime  = dot (color, kRGBToYPrime);\n    float   I      = dot (color, kRGBToI);\n    float   Q      = dot (color, kRGBToQ);\n\n    // Calculate the hue and chroma\n    float   hue     = atan (Q, I);\n    float   chroma  = sqrt (I * I + Q * Q);\n\n    // Make the user's adjustments\n    hue += shift;\n\n    // Convert back to YIQ\n    Q = chroma * sin (hue);\n    I = chroma * cos (hue);\n\n    // Convert back to RGB\n    vec3    yIQ   = vec3 (YPrime, I, Q);\n    color.r = dot (yIQ, kYIQToR);\n    color.g = dot (yIQ, kYIQToG);\n    color.b = dot (yIQ, kYIQToB);\n\n    return color;\n}\n\n// ------\n\n// by iq\n\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat smin( float a, float b, float k ){\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat length6( vec3 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y + p.z, 1.0/6.0 );\n}\n\n// ------\n\n// from hg_sdf \n\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n\treturn dot(p, n) + distanceFromOrigin;\n}\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// -------\n\n\nfloat fractal(vec3 p)\n{\n    const int iterations = 20;\n\t\n    float d = iTime*5. - p.z;\n   \tp=p.yxz;\n    pR(p.yz, 1.570795);\n    p.x += 6.5;\n\n    p.yz = mod(abs(p.yz)-.0, 20.) - 10.;\n    float scale = 1.25;\n    \n    p.xy /= (1.+d*d*0.0005);\n    \n\tfloat l = 0.;\n\t\n    for (int i=0; i<iterations; i++) {\n\t\tp.xy = abs(p.xy);\n\t\tp = p*scale + vec3(-3. + d*0.0095,-1.5,-.5);\n        \n\t\tpR(p.xy,0.35-d*0.015);\n\t\tpR(p.yz,0.5+d*0.02);\n\t\t\n        l =length6(p);\n\t}\n\treturn l*pow(scale, -float(iterations))-.15;\n}\n\nvec2 map(vec3 pos) \n{\n    float dist = 10.; \n    dist = opU(dist, fractal(pos));\n    dist = smin(dist, fPlane(pos,vec3(0.0,1.0,0.0),10.), 4.6);\n    return vec2(dist, 0.);\n}\n\nvec3 vmarch(Ray ray, float dist)\n{   \n    vec3 p = ray.ro;\n    vec2 r = vec2(0.);\n    vec3 sum = vec3(0);\n    vec3 c = hue(vec3(0.,0.,1.),5.5);\n    for( int i=0; i<20; i++ )\n    {\n        r = map(p);\n        if (r.x > .01) break;\n        p += ray.rd*.015;\n        vec3 col = c;\n        col.rgb *= smoothstep(.0,0.15,-r.x);\n        sum += abs(col)*.5;\n    }\n    return sum;\n}\n\nvec2 march(Ray ray) \n{\n    const int steps = 50;\n    const float prec = 0.001;\n    vec2 res = vec2(0.);\n    \n    for (int i = 0; i < steps; i++) \n    {        \n        vec2 s = map(ray.ro + ray.rd * res.x);\n        \n        if (res.x > MAXDIST || s.x < prec) \n        {\n        \tbreak;    \n        }\n        \n        res.x += s.x;\n        res.y = s.y;\n        \n    }\n   \n    return res;\n}\n\nvec3 calcNormal(vec3 pos) \n{\n\tconst vec3 eps = vec3(0.005, 0.0, 0.0);\n                          \n    return normalize(\n        vec3(map(pos + eps).x - map(pos - eps).x,\n             map(pos + eps.yxz).x - map(pos - eps.yxz).x,\n             map(pos + eps.yzx).x - map(pos - eps.yzx).x ) \n    );\n}\n\nvec4 render(Ray ray) \n{\n    vec3 col = vec3(0.);\n\tvec2 res = march(ray);\n   \n    if (res.x > MAXDIST) \n    {\n        return vec4(col, 50.);\n    }\n    \n    vec3 pos = ray.ro+res.x*ray.rd;\n    ray.ro = pos;\n   \tcol = vmarch(ray, res.x);\n    \n    col = mix(col, vec3(0.), clamp(res.x/50., 0., 1.));\n   \treturn vec4(col, res.x);\n}\n\nmat3 camera(in vec3 ro, in vec3 rd, float rot) \n{\n\tvec3 forward = normalize(rd - ro);\n    vec3 worldUp = vec3(sin(rot), cos(rot), 0.0);\n    vec3 x = normalize(cross(forward, worldUp));\n    vec3 y = normalize(cross(x, forward));\n    return mat3(x, y, forward);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    uv.y -= uv.x*uv.x*0.15;\n    vec3 camPos = vec3(3., -1.5, iTime*5.);\n    vec3 camDir = camPos+vec3(-1.25,0.1, 1.);\n    mat3 cam = camera(camPos, camDir, 0.);\n    vec3 rayDir = cam * normalize( vec3(uv, .8));\n    \n    Ray ray;\n    ray.ro = camPos;\n    ray.rd = rayDir;\n    \n    vec4 col = render(ray);\n    \n\tfragColor = vec4(1.-col.xyz,clamp(1.-col.w/MAXDIST, 0., 1.));\n}",
    "tags": [
      "fractal",
      "raymarch",
      "cineshader"
    ],
    "author": "macbooktall",
    "views": 0,
    "likes": 274,
    "published": 3
  },
  {
    "id": "WslGWl",
    "title": "Cloud raymarching",
    "description": "Cloud raymarching sample. This is cloned from https://www.shadertoy.com/view/lss3zr\n\nI also post an article of detail of this post.\nhttps://qiita.com/edo_m18/items/cbba0cc4e33a5aa3be55",
    "code": "// ------------------------------------------\n//\n// This post cloned from \"https://www.shadertoy.com/view/lss3zr\"\n//\n// I also refer this blog post below.\n// https://shaderbits.com/blog/creating-volumetric-ray-marcher\n//\n// This post is to learn how to cloud raymarching is working.\n//\n// ------------------------------------------\n\n#define USE_LIGHT 0\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64);\n\nfloat hash(float n)\n{\n    return fract(sin(n) * 43758.5453);\n}\n\n///\n/// Noise function\n///\nfloat noise(in vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    \n    f = f * f * (3.0 - 2.0 * f);\n    \n    float n = p.x + p.y * 57.0 + 113.0 * p.z;\n    \n    float res = mix(mix(mix(hash(n +   0.0), hash(n +   1.0), f.x),\n                        mix(hash(n +  57.0), hash(n +  58.0), f.x), f.y),\n                    mix(mix(hash(n + 113.0), hash(n + 114.0), f.x),\n                        mix(hash(n + 170.0), hash(n + 171.0), f.x), f.y), f.z);\n    return res;\n}\n\n///\n/// Fractal Brownian motion.\n///\n/// Refer to:\n/// EN: https://thebookofshaders.com/13/\n/// JP: https://thebookofshaders.com/13/?lan=jp\n///\nfloat fbm(vec3 p)\n{\n    float f;\n    f  = 0.5000 * noise(p); p = m * p * 2.02;\n    f += 0.2500 * noise(p); p = m * p * 2.03;\n    f += 0.1250 * noise(p);\n    return f;\n}\n\n//////////////////////////////////////////////////\n\n///\n/// Sphere distance function.\n///\n/// But this function return inverse value.\n/// Normal dist function is like below.\n/// \n/// return length(pos) - 0.1;\n///\n/// Because this function is used for density.\n///\nfloat scene(in vec3 pos)\n{\n    return 0.1 - length(pos) * 0.05 + fbm(pos * 0.3);\n}\n\n///\n/// Get normal of the cloud.\n///\nvec3 getNormal(in vec3 p)\n{\n    const float e = 0.01;\n    return normalize(vec3(scene(vec3(p.x + e, p.y, p.z)) - scene(vec3(p.x - e, p.y, p.z)),\n                          scene(vec3(p.x, p.y + e, p.z)) - scene(vec3(p.x, p.y - e, p.z)),\n                          scene(vec3(p.x, p.y, p.z + e)) - scene(vec3(p.x, p.y, p.z - e))));\n}\n\n///\n/// Create a camera pose control matrix.\n///\nmat3 camera(vec3 ro, vec3 ta)\n{\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(0.0, 1.0, 0.0);\n    vec3 cu = cross(cw, cp);\n    vec3 cv = cross(cu, cw);\n    return mat3(cu, cv, cw);\n}\n\n///\n/// Main function.\n///\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    vec2 mo = vec2(iTime * 0.1, cos(iTime * 0.25) * 3.0);\n    \n    // Camera\n    float camDist = 25.0;\n    \n    // target\n    vec3 ta = vec3(0.0, 1.0, 0.0);\n    \n    // Ray origin\n    //vec3 ori = vec3(sin(iTime) * camDist, 0, cos(iTime) * camDist);\n    vec3 ro = camDist * normalize(vec3(cos(2.75 - 3.0 * mo.x), 0.7 - 1.0 * (mo.y - 1.0), sin(2.75 - 3.0 * mo.x)));\n    \n    float targetDepth = 1.3;\n    \n    // Camera pose.\n    mat3 c = camera(ro, ta);\n    vec3 dir = c * normalize(vec3(uv, targetDepth));\n    \n    // For raymarching const values.\n    const int sampleCount = 64;\n    const int sampleLightCount = 6;\n    const float eps = 0.01;\n    \n    // Raymarching step settings.\n    float zMax = 40.0;\n    float zstep = zMax / float(sampleCount);\n    \n    float zMaxl = 20.0;\n    float zstepl = zMaxl / float(sampleLightCount);\n    \n    // Easy access to the ray origin\n    vec3 p = ro;\n    \n    // Transmittance\n    float T = 1.0;\n    \n    // Substantially transparency parameter.\n    float absorption = 100.0;\n    \n    // Light Direction\n    vec3 sun_direction = normalize(vec3(1.0, 0.0, 0.0));\n    \n    // Result of culcration\n    vec4 color = vec4(0.0);\n    \n    for (int i = 0; i < sampleCount; i++)\n    {\n        // Using distance function for density.\n        // So the function not normal value.\n        // Please check it out on the function comment.\n        float density = scene(p);\n        \n        // The density over 0.0 then start cloud ray marching.\n        // Why? because the function will return negative value normally.\n        // But if ray is into the cloud, the function will return positive value.\n        if (density > 0.0)\n        {\n            // Let's start cloud ray marching!\n            \n            // why density sub by sampleCount?\n            // This mean integral for each sampling points.\n            float tmp = density / float(sampleCount);\n            \n            T *= 1.0 - (tmp * absorption);\n            \n            // Return if transmittance under 0.01. \n            // Because the ray is almost absorbed.\n            if (T <= 0.01)\n            {\n                break;\n            }\n            \n            #if USE_LIGHT == 1\n            // Light scattering\n            \n            // Transmittance for Light\n            float Tl = 1.0;\n            \n            // Start light scattering with raymarching.\n            \n            // Raymarching position for the light.\n            vec3 lp = p;\n            \n            // Iteration of sampling light.\n            for (int j = 0; j < sampleLightCount; j++)\n            {\n                float densityLight = scene(lp);\n                \n                // If densityLight is over 0.0, the ray is stil in the cloud.\n                if (densityLight > 0.0)\n                {\n                    float tmpl = densityLight / float(sampleCount);\n                    Tl *= 1.0 - (tmpl * absorption);\n                }\n                \n                if (Tl <= 0.01)\n                {\n                    break;\n                }\n                \n                // Step to next position.\n                lp += sun_direction * zstepl;\n            }\n            #endif\n            \n            // Add ambient + light scattering color\n            float opaity = 50.0;\n            float k = opaity * tmp * T;\n            vec4 cloudColor = vec4(1.0);\n            vec4 col1 = cloudColor * k;\n            \n            #if USE_LIGHT == 1\n            float opacityl = 30.0;\n            float kl = opacityl * tmp * T * Tl;\n            vec4 lightColor = vec4(1.0, 0.7, 0.9, 1.0);\n            vec4 col2 = lightColor * kl;\n            #else\n            vec4 col2 = vec4(0.0);\n            #endif\n            \n            color += col1 + col2;\n        }\n        \n        p += dir * zstep;\n    }\n    \n    vec3 bg = mix(vec3(0.3, 0.1, 0.8), vec3(0.7, 0.7, 1.0), 1.0 - (uv.y + 1.0) * 0.5);\n    color.rgb += bg;\n    \n\tfragColor = color;\n}",
    "tags": [
      "raymarching",
      "cloud",
      "cineshader"
    ],
    "author": "edo_m18",
    "views": 0,
    "likes": 208,
    "published": 3
  },
  {
    "id": "3sc3z4",
    "title": "GLSL ray tracing test",
    "description": "you can drag left/right to control roughness\nopen using CineShader: https://cineshader.com/view/3sc3z4",
    "code": "//drag the window LR to control roughness\n\n//--graphics setting (lower = better fps)---------------------------------------------------------------------\n#define AVERAGECOUNT 16\n#define MAX_BOUNCE 32\n\n//--scene data---------------------------------------------------------------------\n#define SPHERECOUNT 6\n//xyz = pos, w = radius\nconst vec4 AllSpheres[SPHERECOUNT]=vec4[SPHERECOUNT](\n    vec4(0.0,0.0,0.0,2.0),//sphere A\n    vec4(0.0,0.0,-1.0,2.0),//sphere B\n    vec4(0.0,-1002.0,0.0,1000.0),//ground\n    vec4(0.0,0.0,+1002,1000.0),//back wall\n    vec4(-1004.0,0.0,0.0,1000.0),//left wall    \n    vec4(+1004.0,0.0,0.0,1000.0)//right wall\n);\n//-----------------------------------------------------------------------\nfloat raySphereIntersect(vec3 r0, vec3 rd, vec3 s0, float sr) {\n    // - r0: ray origin\n    // - rd: normalized ray direction\n    // - s0: sphere center\n    // - sr: sphere radius\n    // - Returns distance from r0 to first intersecion with sphere,\n    //   or -1.0 if no intersection.\n    float a = dot(rd, rd);\n    vec3 s0_r0 = r0 - s0;\n    float b = 2.0 * dot(rd, s0_r0);\n    float c = dot(s0_r0, s0_r0) - (sr * sr);\n    if (b*b - 4.0*a*c < 0.0) {\n        return -1.0;\n    }\n    return (-b - sqrt((b*b) - 4.0*a*c))/(2.0*a);\n}\n//-----------------------------------------------------------------------\nstruct HitData\n{\n    float rayLength;\n    vec3 normal;\n};\nHitData AllObjectsRayTest(vec3 rayPos, vec3 rayDir)\n{\n    HitData hitData;\n    hitData.rayLength = 9999.0; //default value if can't hit anything\n\n    for(int i = 0; i < SPHERECOUNT; i++)\n    {\n        vec3 sphereCenter = AllSpheres[i].xyz;\n        float sphereRadius = AllSpheres[i].w;\n        //----hardcode sphere pos animations-------------------------------------\n        if(i == 0)\n        {\n            float t = fract(iTime * 0.7);\n            t = -4.0 * t * t + 4.0 * t;\n            sphereCenter.y += t * 0.7;\n            \n            sphereCenter.x += sin(iTime) * 2.0;\n            sphereCenter.z += cos(iTime) * 2.0;\n        }\n             \n        if(i == 1)\n        {\n            float t = fract(iTime*0.47);\n            t = -4.0 * t * t + 4.0 * t;\n            sphereCenter.y += t * 1.7;\n            \n            sphereCenter.x += sin(iTime+3.14) * 2.0;\n            sphereCenter.z += cos(iTime+3.14) * 2.0;\n        }             \n        //---------------------------------------\n                \n        float resultRayLength = raySphereIntersect(rayPos,rayDir,sphereCenter,sphereRadius);\n        if(resultRayLength < hitData.rayLength && resultRayLength > 0.001)\n        {\n            //if a shorter(better) hit ray found, update\n            hitData.rayLength = resultRayLength;\n            vec3 hitPos = rayPos + rayDir * resultRayLength;\n    \t\thitData.normal = normalize(hitPos - sphereCenter);\n        }\n    }\n    \n    //all test finished, return shortest(best) hit data\n    return hitData;\n}\n//--random functions-------------------------------------------------------------------\nfloat rand01(float seed) { return fract(sin(seed)*43758.5453123); }\nvec3 randomInsideUnitSphere(vec3 rayDir,vec3 rayPos, float extraSeed)\n{\n    return vec3(rand01(iTime * (rayDir.x + rayPos.x + 0.357) * extraSeed),\n                rand01(iTime * (rayDir.y + rayPos.y + 16.35647) *extraSeed),\n                rand01(iTime * (rayDir.z + rayPos.z + 425.357) * extraSeed));\n}\n//---------------------------------------------------------------------\nvec4 calculateFinalColor(vec3 cameraPos, vec3 cameraRayDir, float AAIndex)\n{\n    //init\n    vec3 finalColor = vec3(0.0);\n    float absorbMul = 1.0;\n    vec3 rayStartPos = cameraPos;\n    vec3 rayDir = cameraRayDir;\n    \n    //only for CineShader, to show depth\n    float firstHitRayLength = -1.0;\n    \n    //can't write recursive function in GLSL, so write it in a for loop\n    //will loop until hitting any light source / bounces too many times\n    for(int i = 0; i < MAX_BOUNCE; i++)\n    {\n        HitData h = AllObjectsRayTest(rayStartPos + rayDir * 0.0001,rayDir);//+0.0001 to prevent ray already hit at start pos\n        \n        //only for CineShader, to show depth\n        firstHitRayLength = firstHitRayLength < 0.0 ? h.rayLength : firstHitRayLength;\n               \n        //if ray can't hit anything, rayLength will remain default value 9999.0\n        //which enters this if()\n        //** 99999 is too large for mobile, use 9900 as threshold now **\n        if(h.rayLength >= 9900.0)\n        {\n            vec3 skyColor = vec3(0.7,0.85,1.0);//hit nothing = hit sky color\n            finalColor = skyColor * absorbMul;\n            break;\n        }   \n               \n\t\tabsorbMul *= 0.8; //every bounce absorb some light(more bounces = darker)\n        \n        //update rayStartPos for next bounce\n\t\trayStartPos = rayStartPos + rayDir * h.rayLength; \n        //update rayDir for next bounce\n        float rougness = 0.05 + iMouse.x / iResolution.x; //hardcode \"drag the window LR to control roughness\"\n\t\trayDir = normalize(reflect(rayDir,h.normal) + randomInsideUnitSphere(rayDir,rayStartPos,AAIndex) * rougness);       \n    }\n    \n    return vec4(finalColor,firstHitRayLength);//alpha nly for CineShader, to show depth\n}\n//-----------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n\tuv = uv * 2.0 - 1.0;//transform from [0,1] to [-1,1]\n    uv.x *= iResolution.x / iResolution.y; //aspect fix\n\n    vec3 cameraPos = vec3(sin(iTime * 0.47) * 4.0,sin(iTime * 0.7)*8.0+6.0,-25.0);//camera pos animation\n    vec3 cameraFocusPoint = vec3(0,0.0 + sin(iTime),0);//camera look target point animation\n    vec3 cameraDir = normalize(cameraFocusPoint - cameraPos);\n    \n    //TEMPCODE: fov & all ray init dir, it is wrong!!!!\n    //----------------------------------------------------\n    float fovTempMul = 0.2 + sin(iTime * 0.4) * 0.05;//fov animation\n    vec3 rayDir = normalize(cameraDir + vec3(uv,0) * fovTempMul);\n    //----------------------------------------------------\n\n    vec4 finalColor = vec4(0);\n    for(int i = 1; i <= AVERAGECOUNT; i++)\n    {\n        finalColor+= calculateFinalColor(cameraPos,rayDir, float(i));\n    }\n    finalColor = finalColor/float(AVERAGECOUNT);//brute force AA & denoise\n    finalColor.rgb = pow(finalColor.rgb,vec3(1.0/2.2));//gamma correction\n    \n    //only for CineShader, to show depth\n    float z = finalColor.w; //z is linear world space distance from camera to surface\n    float cineShaderZ; //expect 0~1\n    cineShaderZ = pow(clamp(1.0 - max(0.0,z-21.0) * (1.0/6.0),0.0,1.0),2.0);\n    \n    //result\n    fragColor = vec4(finalColor.rgb,cineShaderZ);\n}",
    "tags": [
      "raytracing",
      "cineshader"
    ],
    "author": "colin299",
    "views": 0,
    "likes": 109,
    "published": 3
  },
  {
    "id": "Ml2XRD",
    "title": "Raymarching Basic",
    "description": "basic",
    "code": "\n\nfloat map(vec3 p) {\n\tvec3 n = vec3(0, 1, 0);\n\tfloat k1 = 1.9;\n\tfloat k2 = (sin(p.x * k1) + sin(p.z * k1)) * 0.8;\n\tfloat k3 = (sin(p.y * k1) + sin(p.z * k1)) * 0.8;\n\tfloat w1 = 4.0 - dot(abs(p), normalize(n)) + k2;\n\tfloat w2 = 4.0 - dot(abs(p), normalize(n.yzx)) + k3;\n\tfloat s1 = length(mod(p.xy + vec2(sin((p.z + p.x) * 2.0) * 0.3, cos((p.z + p.x) * 1.0) * 0.5), 2.0) - 1.0) - 0.2;\n\tfloat s2 = length(mod(0.5+p.yz + vec2(sin((p.z + p.x) * 2.0) * 0.3, cos((p.z + p.x) * 1.0) * 0.3), 2.0) - 1.0) - 0.2;\n\treturn min(w1, min(w2, min(s1, s2)));\n}\n\nvec2 rot(vec2 p, float a) {\n\treturn vec2(\n\t\tp.x * cos(a) - p.y * sin(a),\n\t\tp.x * sin(a) + p.y * cos(a));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float time = iTime;\n\tvec2 uv = ( fragCoord.xy / iResolution.xy ) * 2.0 - 1.0;\n\tuv.x *= iResolution.x /  iResolution.y;\n\tvec3 dir = normalize(vec3(uv, 1.0));\n\tdir.xz = rot(dir.xz, time * 0.23);dir = dir.yzx;\n\tdir.xz = rot(dir.xz, time * 0.2);dir = dir.yzx;\n\tvec3 pos = vec3(0, 0, time);\n\tvec3 col = vec3(0.0);\n\tfloat t = 0.0;\n    float tt = 0.0;\n\tfor(int i = 0 ; i < 100; i++) {\n\t\ttt = map(pos + dir * t);\n\t\tif(tt < 0.001) break;\n\t\tt += tt * 0.45;\n\t}\n\tvec3 ip = pos + dir * t;\n\tcol = vec3(t * 0.1);\n\tcol = sqrt(col);\n\tfragColor = vec4(0.05*t+abs(dir) * col + max(0.0, map(ip - 0.1) - tt), 1.0); //Thanks! Shane!\n    fragColor.a = 1.0 / (t * t * t * t);\n}",
    "tags": [
      "raymarching",
      "cineshader"
    ],
    "author": "gyabo",
    "views": 0,
    "likes": 199,
    "published": 3
  },
  {
    "id": "lllSR2",
    "title": "w10",
    "description": "Windows10 wallpapar wip.\n\nOMG\nhttps://www.youtube.com/watch?t=128&v=hL8BBOwupcI\n\n\nhttps://www.youtube.com/watch?t=128&v=hL8BBOwupcI\n\nomg.",
    "code": "\n#define PI     3.1415926535897921284\n#define REP    25\n#define d2r(x) (x * PI / 180.0)\n#define WBCOL  (vec3(0.5, 0.7,  1.7))\n#define WBCOL2 (vec3(0.15, 0.8, 1.7))\n#define ZERO   (min(iFrame,0))\n\nfloat hash( vec2 p ) {\n\tfloat h = dot( p, vec2( 127.1, 311.7 ) );\n\treturn fract( sin( h ) * 458.325421) * 2.0 - 1.0;\n}\n\nfloat noise( vec2 p ) {\n\tvec2 i = floor( p );\n\tvec2 f = fract( p );\n\t\n\tf = f * f * ( 3.0 - 2.0 * f );\n\t\n\treturn mix(\n\t\tmix( hash( i + vec2( 0.0, 0.0 ) ), hash( i + vec2( 1.0, 0.0 ) ), f.x ),\n\t\tmix( hash( i + vec2( 0.0, 1.0 ) ), hash( i + vec2( 1.0, 1.0 ) ), f.x ),\n\t\tf.y\n\t);\n}\n\nvec2 rot(vec2 p, float a) {\n\treturn vec2(\n\t\tp.x * cos(a) - p.y * sin(a),\n\t\tp.x * sin(a) + p.y * cos(a));\n}\n\nfloat nac(vec3 p, vec2 F, vec3 o) {\n\tconst float R = 0.0001;\n\tp += o;\n\treturn length(max(abs(p.xy)-vec2(F),0.0)) - R;\t\n}\n\n\nfloat by(vec3 p, float F, vec3 o) {\n\tconst float R = 0.0001;\n\tp += o;\n\treturn length(max(abs(mod(p.xy, 3.0))-F,0.0)) - R;\t\n}\n\n\nfloat recta(vec3 p, vec3 F, vec3 o) {\n\tconst float R = 0.0001;\n\tp += o;\n\treturn length(max(abs(p)-F,0.0)) - R;\t\n}\n\n\nfloat map1(vec3 p, float scale) {\n\tfloat G = 0.50;\n\tfloat F = 0.50 * scale;\n\tfloat t =  nac(p, vec2(F,F), vec3( G,  G, 0.0));\n\tt = min(t, nac(p, vec2(F,F), vec3( G, -G, 0.0)));\n\tt = min(t, nac(p, vec2(F,F), vec3(-G,  G, 0.0)));\n\tt = min(t, nac(p, vec2(F,F), vec3(-G, -G, 0.0)));\n\treturn t;\n}\n\nfloat map2(vec3 p) {\n\tfloat t = map1(p, 0.9);\n\t//t = max(t, recta(p, vec3(1.0, 1.0, 0.02), vec3(0.0, 0.0, 0.0)));\n    t = max(t, recta(p, vec3(1.0, 1.0, 0.02), vec3(0.0, 0.0, 0.0)));\n\treturn t;\n}\n\n\n// http://glslsandbox.com/e#26840.0\nfloat gennoise(vec2 p) {\n\tfloat d = 0.5;\n\tmat2 h = mat2( 1.6, 1.2, -1.2, 1.6 );\n\t\n\tfloat color = 0.0;\n\tfor( int i = 0; i < 2; i++ ) {\n\t\tcolor += d * noise( p * 5.0 + iTime);\n\t\tp *= h;\n\t\td /= 2.0;\n\t}\n\treturn color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = vec4(0.0);\n    for(int count = 0 ; count < 2; count++) {\n        vec2 uv = -1.0 + 2.0 * ( fragCoord.xy / iResolution.xy );\n        uv *= 1.4;\n        uv.x += hash(uv.xy + iTime + float(count)) / 512.0;\n        uv.y += hash(uv.yx + iTime + float(count)) / 512.0;\n        vec3 dir = normalize(vec3(uv * vec2(iResolution.x / iResolution.y, 1.0), 1.0 + sin(iTime) * 0.01));\n        dir.xz = rot(dir.xz, d2r(70.0));\n        dir.xy = rot(dir.xy, d2r(90.0));\n        vec3 pos    = vec3(-0.1 + sin(iTime * 0.3) * 0.1, 2.0 + cos(iTime * 0.4) * 0.1, -3.5);\n        vec3  col   = vec3(0.0);\n        float t     = 0.0;\n        float M     = 1.002;\n        float bsh   = 0.01;\n        float dens  = 0.0;\n\n        for(int i = ZERO ; i < REP * 24; i++) {\n            float temp = map1(pos + dir * t, 0.6);\n            if(temp < 0.2) {\n                col += WBCOL * 0.005 * dens;\n            }\n            t += bsh * M;\n            bsh *= M;\n            dens += 0.025;\n        }\n\n        //windows\n        t = 0.0;\n        float y = 0.0;\n        //for(int i = 0 ; i < REP * 50; i++)\n        for(int i = ZERO ; i < REP; i++)\n        {\n            float temp = map2(pos + dir * t);\n            if(temp < 0.025) {\n                //col += WBCOL2 * 0.005;\n                col += WBCOL2 * 0.5;\n            }\n            t += temp;\n            y++;\n        }\n        col += ((2.0 + uv.x) * WBCOL2) + (y / (25.0 * 50.0));\n        col += gennoise(dir.xz) * 0.5;\n        col *= 1.0 - uv.y * 0.5;\n        col *= vec3(0.05);\n        col  = pow(col, vec3(0.717));\n        fragColor += vec4(col, 1.0 / (t));\n    }\n    fragColor /= vec4(2.0);\n}\n\n",
    "tags": [
      "raymarching",
      "windows10",
      "cineshader"
    ],
    "author": "gyabo",
    "views": 0,
    "likes": 86,
    "published": 3
  },
  {
    "id": "ll3SWl",
    "title": "Dive to Cloud",
    "description": "cloud\n\nreferred https://www.shadertoy.com/view/4sXGRM",
    "code": "// referred https://www.shadertoy.com/view/4sXGRM\n\nvec3 skytop = vec3(0.05, 0.2, 0.5);\n\nvec3 light = normalize(vec3(0.1, 0.25, 0.9));\n\nvec2 cloudrange = vec2(0.0, 10000.0);\n\nmat3 m = mat3(0.00, 1.60, 1.20, -1.60, 0.72, -0.96, -1.20, -0.96, 1.28);\n\n// hash function              \nfloat hash(float n)\n{\n    return fract(cos(n) * 114514.1919);\n}\n\n// 3d noise function\nfloat noise(in vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = smoothstep(0.0, 1.0, fract(x));\n        \n    float n = p.x + p.y * 10.0 + p.z * 100.0;\n    \n    return mix(\n        mix(mix(hash(n + 0.0), hash(n + 1.0), f.x),\n            mix(hash(n + 10.0), hash(n + 11.0), f.x), f.y),\n        mix(mix(hash(n + 100.0), hash(n + 101.0), f.x),\n            mix(hash(n + 110.0), hash(n + 111.0), f.x), f.y), f.z);\n}\n\n// Fractional Brownian motion\nfloat fbm(vec3 p)\n{\n    float f = 0.5000 * noise(p);\n    p = m * p;\n    f += 0.2500 * noise(p);\n    p = m * p;\n    f += 0.1666 * noise(p);\n    p = m * p;\n    f += 0.0834 * noise(p);\n    return f;\n}\n\nvec3 camera(float time)\n{\n    return vec3(5000.0 * sin(1.0 * time), 5000. + 1500. * sin(0.5 * time), 6000.0 * time);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    float time = (iTime + 13.5 + 44.) * 1.0;\n    vec3 campos = camera(time);\n    vec3 camtar = camera(time + 0.4);\n\n    vec3 front = normalize(camtar - campos);\n    vec3 right = normalize(cross(front, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(right, front));\n    vec3 fragAt = normalize(uv.x * right + uv.y * up + front);\n    \n    // clouds\n    vec4 sum = vec4(0, 0, 0, 0);\n    for (float depth = 0.0; depth < 100000.0; depth += 200.0)\n    {\n        vec3 ray = campos + fragAt * depth;\n        if (cloudrange.x < ray.y && ray.y < cloudrange.y)\n        {\n            float alpha = smoothstep(0.5, 1.0, fbm(ray * 0.00025));\n            vec3 localcolor = mix(vec3(1.1, 1.05, 1.0), vec3(0.3, 0.3, 0.2), alpha);\n            alpha = (1.0 - sum.a) * alpha;\n            sum += vec4(localcolor * alpha, alpha);\n        }\n    }\n    \n    float alpha = smoothstep(0.7, 1.0, sum.a);\n    sum.rgb /= sum.a + 0.0001;\n\n    float sundot = clamp(dot(fragAt, light), 0.0, 1.0);\n    vec3 col = 0.8 * (skytop);\n    col += 0.47 * vec3(1.6, 1.4, 1.0) * pow(sundot, 350.0);\n    col += 0.4 * vec3(0.8, 0.9, 1.0) * pow(sundot, 2.0);\n    \n    sum.rgb -= 0.6 * vec3(0.8, 0.75, 0.7) * pow(sundot, 13.0) * alpha;\n    \n    sum.rgb += 0.2 * vec3(1.3, 1.2, 1.0) * pow(sundot, 5.0) * (1.0 - alpha);\n\n    col = mix(col, sum.rgb, sum.a);\n\n    fragColor = vec4(col, 1.0);\n}",
    "tags": [
      "cloud",
      "cineshader"
    ],
    "author": "lise",
    "views": 0,
    "likes": 100,
    "published": 3
  },
  {
    "id": "wsGczG",
    "title": "ED-209",
    "description": "\"PLEASE NORMALIZE YOUR VECTORS. YOU HAVE 20 SECONDS TO COMPLY...\"\n\nI've always loved the (original) Robocop movie, but have never felt confident enough to try modelling ED-209.\nI hope you like it!",
    "code": "// 'ED-209' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/wsGczG\n//\n// Processed by 'GLSL Shader Shrinker' (10,705 to 9,801 characters)\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n//\n// I've always loved the (original) Robocop movie, but have never\n// felt confident enough to try modelling ED-209.\n// I hope you like it!\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane\n// and a bunch of others for sharing their knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat stretch, gunsUp, gunsForward, edWalk, edTwist, edDown, edShoot, doorOpen, glow = 0.0;\n\n//#define AA  // Enable this line if your GPU can take it!\n\nstruct MarchData {\n\tfloat d;\n\tvec3 mat; // RGB\n\tfloat specPower; // 0: None, 30.0: Shiny\n};\n\nmat2 rot(float a) {\n\tfloat c = cos(a),\n\t      s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nfloat remap(float f, float in1, float in2, float out1, float out2) { return mix(out1, out2, clamp((f - in1) / (in2 - in1), 0., 1.)); }\n\nfloat sdBox(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\nfloat sdChamferedCube(vec3 p, vec3 r, float c) {\n\tfloat cube = sdBox(p, r);\n\tp.xz *= rot(.78525);\n\tr.xz *= -c / 1.41 + 1.41;\n\treturn max(cube, sdBox(p, r));\n}\n\nfloat sdTriPrism(vec3 p, vec2 h) {\n\tvec3 q = abs(p);\n\treturn max(q.z - h.y, max(q.x * .866025 + p.y * .5, -p.y) - h.x * .5);\n}\n\nfloat sdCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb) {\n\tfloat rba = rb - ra,\n\t      baba = dot(b - a, b - a),\n\t      papa = dot(p - a, p - a),\n\t      paba = dot(p - a, b - a) / baba,\n\t      x = sqrt(papa - paba * paba * baba),\n\t      cax = max(0., x - ((paba < .5) ? ra : rb)),\n\t      cay = abs(paba - .5) - .5,\n\t      f = clamp((rba * (x - ra) + paba * baba) / (rba * rba + baba), 0., 1.),\n\t      cbx = x - ra - f * rba,\n\t      cby = paba - f;\n\treturn ((cbx < 0. && cay < 0.) ? -1. : 1.) * sqrt(min(cax * cax + cay * cay * baba, cbx * cbx + cby * cby * baba));\n}\n\nfloat sdCappedCylinder(vec3 p, float h, float r) {\n\tvec2 d = abs(vec2(length(p.xy), p.z)) - vec2(h, r);\n\treturn min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 pa = p - a,\n\t     ba = b - a;\n\treturn length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0., 1.)) - r;\n}\n\nfloat sdOctogon(vec2 p, float r) {\n\tconst vec3 k = vec3(-.92387953, .38268343, .41421356);\n\tp = abs(p);\n\tp -= 2. * min(dot(k.xy, p), 0.) * k.xy;\n\tp -= 2. * min(dot(vec2(-k.x, k.y), p), 0.) * vec2(-k.x, k.y);\n\tp -= vec2(clamp(p.x, -k.z * r, k.z * r), r);\n\treturn length(p) * sign(p.y);\n}\n\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n\tvec3 forward = normalize(lookAt - ro),\n\t     right = normalize(cross(vec3(0, 1, 0), forward));\n\treturn normalize(forward + right * uv.x + cross(forward, right) * uv.y);\n}\n\nMarchData minResult(MarchData a, MarchData b) {\n\tif (a.d < b.d) return a;\n\treturn b;\n}\n\nvoid setBodyMaterial(inout MarchData mat) {\n\tmat.mat = vec3(.36, .45, .5);\n\tmat.specPower = 30.;\n}\n\nfloat legWalkAngle(float f) { return sin(edWalk * 3.141 * 6. * f) * .2; }\n\nfloat edZ() { return mix(5., -2., edWalk); }\n\nfloat fireShock() { return abs(sin(edShoot * 78.5375)); }\n\nfloat headSphere(vec3 p) { return (length(p / vec3(1, .8, 1)) - 1.) * .8; }\n\nMarchData headVisor(vec3 p, float h, float bump) {\n\tbump *= sin(p.x * 150.) * sin(p.y * 150.) * .002;\n\tMarchData result;\n\tresult.d = sdBox(p, vec3(1, h, 2));\n\tresult.d = max(mix(result.d, headSphere(p), .57), -p.y) - bump;\n\tresult.mat = vec3(.05);\n\tresult.specPower = 30.;\n\treturn result;\n}\n\nMarchData headLower(vec3 p) {\n\tvec3 op = p;\n\n\t// Start by mirroring the visor.\n\tMarchData r = headVisor(p * vec3(.95, -1.4, .95), 1., 0.);\n\n\t// Add the side panels.\n\tr.d = min(r.d, max(max(headVisor((p + vec3(0, .01, 0)) * vec3(.95), 1., 0.).d, p.y - .35), p.y * .625 - p.z - .66));\n\n\t// 'Wings'.\n\tp.xy *= rot(.075 * (gunsUp - 1.) * sign(p.x));\n\tp.x = abs(p.x) - 1.33;\n\tp.y -= .1 - p.x * .1;\n\tr.d = min(r.d, sdBox(p, vec3(.4, .06 * (1. - p.x), .3 - p.x * .2)));\n\tp = op;\n\n\t// Cut out a mouth grill.\n\tp.y = abs(abs(p.y + .147) - .0556) - .0278;\n\tr.d = max(r.d, -sdBox(p + vec3(0, 0, 1.5), vec3(mix(.25, .55, -op.y), .015, .1)));\n\n\t// 'Cheeks'.\n\tp = op;\n\tp.y = abs(p.y + .16) - .06;\n\tp.z -= -1.1;\n\tr.d = max(r.d, -max(max(sdCappedCylinder(p.xzy, 1., .03), -sdCappedCylinder(p.xzy, .55, 1.)), p.z + .2));\n\tsetBodyMaterial(r);\n\treturn r;\n}\n\nMarchData gunPod(vec3 p) {\n\tMarchData r;\n\tsetBodyMaterial(r);\n\tp.yz += vec2(.1, .45);\n\n\t// Carousel.\n\tvec3 pp = p;\n\tpp.z = abs(pp.z) - .5;\n\tr.d = sdCappedCone(pp, vec3(0), vec3(0, 0, -.1), .35 - .1, .35);\n\tr.d = min(r.d, sdCappedCylinder(p, .35, .4));\n\n\t// Triangle nobble.\n\tpp = vec3(p.x, .28 - p.y, p.z);\n\tr.d = min(r.d, sdTriPrism(pp, vec2(.1, .5)));\n\n\t// Square outriggers.\n\tpp = p;\n\tpp.x = abs(p.x);\n\tpp.xy *= rot(.78525);\n\tfloat fs,\n\t      bump = sign(sin(pp.z * 33.3)) * .003,\n\t      d = sdBox(pp, vec3(.1 - bump, .38 - bump, .34)) - .02;\n\n\t// Barrels.\n\tpp = p - vec3(0, 0, -.6);\n\tpp.x = abs(pp.x) - .1;\n\td = min(min(min(d, sdCappedCylinder(pp, .06, .15)), sdCappedCylinder(pp + vec3(0, .12, -.05), .06, .05)), sdBox(p + vec3(0, 0, .54), vec3(.1, .06, .04)));\n\tif (d < r.d) {\n\t\td = max(d, -sdCappedCylinder(pp + vec3(0, 0, .1), .03, .2));\n\t\tr.d = d;\n\t\tr.mat = vec3(.02);\n\t}\n\n\t// Muzzle flash.\n\tfs = fireShock();\n\tif (fs > .5) {\n\t\td = sdCappedCylinder(pp, .01 + pp.z * .05, fract(fs * 3322.423) * .5 + .9);\n\t\tif (d < r.d) {\n\t\t\tr.d = d;\n\t\t\tr.mat = vec3(1);\n\t\t\tglow += .1 / (.01 + d * d * 4e2);\n\t\t}\n\t}\n\n\treturn r;\n}\n\nMarchData arms(vec3 p) {\n\tconst vec3 wrist = vec3(1.5, 0, 0) - vec3(0, 0, .3);\n\tMarchData r;\n\tsetBodyMaterial(r);\n\n\t// Position origin.\n\tp.x = abs(p.x);\n\tp.yz += vec2(.24, 0);\n\tp.xy *= rot(.15 * (gunsUp - 1.));\n\n\t// Shoulder and forearm.\n\tr.d = min(sdCapsule(p, vec3(0), vec3(1.5, 0, 0), .2), sdCapsule(p, vec3(1.5, 0, 0), wrist, .2));\n\n\t// Gunz.\n\tp -= wrist;\n\tp.z -= gunsForward * .15;\n\treturn minResult(r, gunPod(p));\n}\n\nfloat toe(vec3 p) {\n\tp.yz += vec2(.1, .32);\n\treturn max(sdBox(p, vec3(.3 + .2 * (p.z - .18) - p.y * .228, .3 + .2 * cos((p.z - .18) * 3.69), .35)), .1 - p.y);\n}\n\nfloat foot(vec3 p) {\n\tp.z += .8;\n\tp.yz *= rot(.86);\n\tfloat d = toe(p);\n\tp.xz *= rot(1.57);\n\tp.x -= .43;\n\tp.z = .25 - abs(p.z);\n\treturn min(d, toe(p));\n}\n\nMarchData waist(vec3 p) {\n\tMarchData r;\n\tsetBodyMaterial(r);\n\tp.y += .65;\n\tp.yz *= rot(-.2);\n\tfloat bump, d,\n\t      legAngle = legWalkAngle(1.);\n\tp.xy *= rot(legAngle * .3);\n\tvec3 pp = p;\n\tpp.y += .3;\n\tr.d = max(sdCappedCylinder(pp.zyx, .5, .5), p.y + .15);\n\n\t// Thorax.\n\tbump = .5 - abs(sin(p.y * 40.)) * .03;\n\td = sdBox(p, vec3(bump, .15, bump));\n\n\t// Leg joins.\n\tbump = .3 - abs(sin(p.x * 40.)) * .03;\n\tpp.y += .18;\n\td = min(d, sdCappedCylinder(pp.zyx, bump, .75));\n\n\t// Hips.\n\tpp.x = abs(pp.x);\n\tpp.yz *= rot(-.58525 + legAngle * sign(p.x));\n\tpp.x -= .98;\n\tr.d = min(r.d, max(sdCappedCylinder(pp.zyx, .4, .24), -pp.y));\n\tr.d = min(r.d, sdBox(pp, vec3(.24, .2, .14 + .2 * pp.y)));\n\n\t// Thigh pistons.\n\tp = pp;\n\tpp.xz = abs(pp.xz) - vec2(.12, .25);\n\tr.d = min(r.d, max(min(sdCappedCylinder(pp.xzy, .1, .325), sdCappedCylinder(pp.xzy, .05, .5)), pp.y));\n\n\t// 'Knees'.\n\tp.y += .68;\n\tr.d = min(r.d, sdBox(p, vec3(sign(abs(p.y) - .04) * .005 + .26, .2, .34)));\n\tif (d < r.d) {\n\t\t// Black segments.\n\t\tr.d = d;\n\t\tr.mat = vec3(.02);\n\t}\n\n\treturn r;\n}\n\nMarchData legs(vec3 p) {\n\tMarchData r;\n\tsetBodyMaterial(r);\n\tfloat silver,\n\t      legAngle = legWalkAngle(1.);\n\tp.z += .27;\n\tp.yz *= rot(legAngle * sign(p.x));\n\tp.z -= .27;\n\tp.y += .65;\n\tp.yz *= rot(-.2);\n\tp.xy *= rot(legAngle * .3);\n\tvec3 cp,\n\t     pp = p;\n\tpp.x = abs(pp.x);\n\tpp.y += .48;\n\tpp.yz *= rot(-.58525);\n\tpp.x -= .98;\n\tcp = pp;\n\tp = pp;\n\tpp.xz = abs(pp.xz) - vec2(.12, .25);\n\tp.y += .68;\n\n\t// Thighs.\n\tp.xy = abs(p.xy) - .12;\n\tsilver = sdBox(p, vec3(.07, .05, 1.2));\n\n\t// Leg end cap.\n\tcp -= vec3(0, -.7, 0);\n\tr.d = sdBox(cp - vec3(0, 0, 1.15), vec3(.17, .17, .07)) - .04;\n\n\t// Shin.\n\tcp.z++;\n\tr.d = min(r.d, sdChamferedCube(cp.xzy, vec2(.28 - sign(abs(cp.z) - .3) * .01, .5).xyx, .18));\n\n\t// Feet.\n\tr.d = min(r.d, foot(cp));\n\tif (silver < r.d) {\n\t\tr.d = silver;\n\t\tr.mat = vec3(.8);\n\t}\n\n\treturn r;\n}\n\nMarchData ed209(vec3 p) {\n\tp.yz += vec2(legWalkAngle(2.) * .2 + .1, -edZ());\n\tMarchData r = legs(p);\n\tfloat f = min(stretch * 2., 1.),\n\t      slide = f < .5 ? smoothstep(0., .5, f) : (1. - smoothstep(.5, 1., f) * .2);\n\tp.yz -= slide * .5;\n\tgunsUp = smoothstep(0., 1., clamp((stretch - .66) * 6., 0., 1.)); // 0.66-0.83\n\tgunsForward = smoothstep(0., 1., clamp((stretch - .83) * 6., 0., 1.)) // 0.83-1.0\n\t + fireShock() * .5;\n\tr = minResult(r, waist(p));\n\tp.yz *= rot(.1 * (-edDown + legWalkAngle(2.) + smoothstep(0., 1., clamp((stretch - .5) * 6., 0., 1.)) - 1.)); // 0.5-0.66\n\tp.xz *= rot(edTwist * .2);\n\treturn minResult(minResult(minResult(r, headLower(p)), headVisor(p, .8, 1.)), arms(p));\n}\n\nMarchData room(vec3 p) {\n\tconst vec3 frameInner = vec3(2.8, 2.6, .1);\n\tMarchData r;\n\tr.mat = vec3(.4);\n\tr.specPower = 1e7;\n\tvec2 xy = p.xy - vec2(0, 2);\n\tp.x = abs(p.x);\n\tp.yz += vec2(.5, -3.4);\n\tfloat doorFrame, doorWidth, door, d,\n\t      doorHole = sdBox(p, frameInner + vec3(0, 0, 1)),\n\t      backWall = length(p.z - 8.);\n\tr.d = min(backWall, max(length(p.z), -doorHole + .1));\n\tif (r.d == backWall) {\n\t\tfloat ocp = min(abs(sdOctogon(xy, 2.6)), abs(sdOctogon(xy, 1.9)));\n\t\tocp = min(max(ocp, min(.7 - abs(xy.x + 1.2), -xy.y)), max(abs(sdOctogon(xy, 1.2)), min(xy.x, .7 - abs(xy.y))));\n\t\tif (ocp < .3) r.mat = vec3(.39, .57, .71);\n\t}\n\n\tdoorFrame = max(sdBox(p, frameInner + vec3(.4, .4, .1)), -doorHole);\n\tdoorWidth = frameInner.x * .5;\n\tp.x -= frameInner.x;\n\tp.xz *= rot(doorOpen * 2.1);\n\tp.x += doorWidth;\n\tdoor = sdBox(p, vec3(doorWidth, frameInner.yz));\n\tp = abs(p) - vec3(doorWidth * .5, 1.1, .14);\n\td = min(doorFrame, max(door, -max(sdBox(p, vec3(.45, .9, .1)), -sdBox(p, vec3(.35, .8, 1)))));\n\tif (d < r.d) {\n\t\tr.d = d;\n\t\tr.mat = vec3(.02, .02, .024);\n\t\tr.specPower = 10.;\n\t}\n\n\treturn r;\n}\n\n// Map the scene using SDF functions.\nMarchData map(vec3 p) {\n\tMarchData r = minResult(room(p), ed209(p));\n\tfloat gnd = length(p.y + 3.);\n\tif (gnd < r.d) {\n\t\tr.d = gnd;\n\t\tr.mat = vec3(.1);\n\t}\n\n\treturn r;\n}\n\nfloat calcShadow(vec3 p, vec3 lightPos) {\n\t// Thanks iq.\n\tvec3 rd = normalize(lightPos - p);\n\tfloat res = 1.,\n\t      t = .1;\n\tfor (float i = 0.; i < 30.; i++) {\n\t\tfloat h = map(p + rd * t).d;\n\t\tres = min(res, 12. * h / t);\n\t\tt += h;\n\t\tif (res < .001 || t > 25.) break;\n\t}\n\n\treturn clamp(res, 0., 1.);\n}\n\nvec3 calcNormal(vec3 p, float t) {\n\tfloat d = .01 * t * .33;\n\tvec2 e = vec2(1, -1) * .5773 * d;\n\treturn normalize(e.xyy * map(p + e.xyy).d + e.yyx * map(p + e.yyx).d + e.yxy * map(p + e.yxy).d + e.xxx * map(p + e.xxx).d);\n}\n\n// Quick ambient occlusion.\nfloat ao(vec3 p, vec3 n, float h) { return clamp(map(p + h * n).d / h, 0., 1.); }\n\n/**********************************************************************************/\nvec3 vignette(vec3 col, vec2 fragCoord) {\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\tcol *= .5 + .5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .4);\n\treturn col;\n}\n\nvec3 applyLighting(vec3 p, vec3 rd, float d, MarchData data) {\n\tvec3 sunP = vec3(10, 10, -10),\n         sunDir = normalize(sunP - p),\n\t     n = calcNormal(p, d);\n\n\t// Primary light.\n\tfloat primary = max(0., dot(sunDir, n)),\n\t      bounce = max(0., dot(-sunDir, n)) * .3,\n\t      spe = pow(max(0., dot(rd, reflect(sunDir, n))), data.specPower) * 2.,\n\t      fre = smoothstep(.7, 1., 1. + dot(rd, n)),\n\t      fog = exp(-length(p) * .05);\n          \n    primary /= pow(length(sunP - p) / 15., 3.0);\n    if (data.specPower > 1e6) spe *= 0.;\n\n\t// Combine.\n\tprimary *= mix(.2, 1., calcShadow(p, vec3(10, 10, -10)));\n\treturn mix(data.mat * ((primary + bounce) * ao(p, n, .33) + spe) * vec3(2, 1.6, 1.7), vec3(.01), fre) * fog;\n}\n\nvec3 getSceneColor(vec3 ro, vec3 rd) {\n\t// Raymarch.\n\tvec3 p;\n\tfloat g,\n\t      d = .01;\n\tMarchData h;\n\tfor (float steps = 0.; steps < 120.; steps++) {\n\t\tp = ro + rd * d;\n\t\th = map(p);\n\t\tif (abs(h.d) < .0015 * d) break;\n\t\tif (d > 64.) return vec3(0); // Distance limit reached - Stop.\n\t\td += h.d; // No hit, so keep marching.\n\t}\n\n\t// Lighting.\n\tg = glow;\n\treturn applyLighting(p, rd, d, h) + fireShock() * .3 + g;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n\tedWalk = 1.;\n\tedTwist = 0.;\n\tedDown = 0.;\n\tedShoot = 0.;\n\tdoorOpen = 1.;\n\tstretch = 1.;\n\n\t// Camera.\n\tvec3 ro, lookAt, col;\n\tfloat startScene, endScene, dim,\n\t      time = mod(iTime, 55.);\n\tif (time < 12.) {\n\t\tstartScene = 0.;\n\t\tendScene = 12.;\n\t\tedWalk = 0.;\n\t\tro = vec3(0, -1.5, -.625);\n\t\tlookAt = vec3(0, -1, edZ());\n\t\tdoorOpen = smoothstep(0., 1., time / 5.);\n\t\tstretch = remap(time, 7., 10., 0., 1.);\n\t}\n\telse if (time < 25.) {\n\t\tstartScene = 12.;\n\t\tendScene = 25.;\n\t\tfloat t = time - startScene;\n\t\tedWalk = smoothstep(0., 1., remap(t, 3., 8., 0., 1.));\n\t\tro = vec3(-.5 * cos(t * .7), .5 - t * .1, edZ() - 3.);\n\t\tlookAt = vec3(0, 0, edZ());\n\t}\n\telse if (time < 29.) {\n\t\tstartScene = 25.;\n\t\tendScene = 29.;\n\t\tro = vec3(-2, .5 + (time - startScene) * .1, edZ() - 3.);\n\t\tlookAt = vec3(0, 0, edZ());\n\t}\n\telse if (time < 37.) {\n\t\tstartScene = 29.;\n\t\tendScene = 37.;\n\t\tfloat t = time - startScene;\n\t\tro = vec3(1.5, -1. - t * .05, edZ() - 5.);\n\t\tlookAt = vec3(0, -1, edZ());\n\t\tstretch = remap(t, 2., 5., 1., 0.);\n\t}\n\telse if (time < 55.) {\n\t\tstartScene = 37.;\n\t\tendScene = 55.;\n\t\tfloat t = time - startScene;\n\t\tro = vec3(-1.8, -.5, edZ() - 2.5);\n\t\tstretch = remap(t, 2., 3., 0., 1.) - remap(t, 11.5, 14.5, 0., 1.);\n\t\tlookAt = vec3(0, stretch * .5 - .5, edZ());\n\t\tedTwist = remap(t, 3., 3.2, 0., 1.) * stretch;\n\t\tedDown = remap(t, 3.2, 3.4, 0., 1.) * stretch;\n\t\tedShoot = t <= 9.5 ? remap(t, 4., 9.5, 0., 1.) : 0.;\n\t}\n\n\tdim = 1. - cos(min(1., 2. * min(abs(time - startScene), abs(time - endScene))) * 1.5705);\n\tcol = vec3(0);\n#ifdef AA\n\tfor (float dx = 0.; dx <= 1.; dx++) {\n\t\tfor (float dy = 0.; dy <= 1.; dy++) {\n\t\t\tvec2 coord = fragCoord + vec2(dx, dy) * .5;\n#else\n\t\t\tvec2 coord = fragCoord;\n#endif\n\t\t\tcoord += (fract(fireShock() * vec2(23242.232, 978.23465)) - .5) * 10.;\n\t\t\tvec2 uv = (coord - .5 * iResolution.xy) / iResolution.y;\n\t\t\tcol += getSceneColor(ro, getRayDir(ro, lookAt, uv));\n#ifdef AA\n\t\t}\n\t}\n\n\tcol /= 4.;\n#endif\n\n\t// Output to screen.\n\tfragColor = vec4(vignette(pow(col * dim, vec3(.4545)), fragCoord), 1);\n}",
    "tags": [
      "3d",
      "raymarching",
      "robot",
      "movie",
      "cineshader",
      "robocop"
    ],
    "author": "dean_the_coder",
    "views": 0,
    "likes": 253,
    "published": 3
  },
  {
    "id": "wtdSR8",
    "title": "Parallax view on Cineshader",
    "description": "It uses the iCamPos for parallax view but it cause issues on the reflection. Still fun to mess with it though. [url]https://cineshader.com/view/wtdSR8[/url]",
    "code": "float sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec3 opRep( in vec3 p, in vec3 c, in vec3 l)\n{\n    return p-c*clamp(round(p/c),-l,l);\n}\n\nfloat map(vec3 p)\n{\n    p.z += 5.0;\n    p = opRep(p, vec3(4.0), vec3(1.0));\n    return sdBox(p, vec3(1.0));\n}\n\nvec3 calcNormal( in vec3 p )\n{\n    const float h = 1e-5; // or some other value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*h ) + \n                      k.yyx*map( p + k.yyx*h ) + \n                      k.yxy*map( p + k.yxy*h ) + \n                      k.xxx*map( p + k.xxx*h ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // use different camera setting for CineShader\n    #ifdef IS_CINESHADER\n    \n    // use the relative position of the camera to the center of the screen as ray origin\n\tvec3 rayOri = iCamPos;\n    \n    // screen size is 6m x 6m, or you can use iScreenSize.xy(CineShader only) to get the screen size\n\tvec3 rayDir = normalize(vec3((uv - 0.5) * vec2(iResolution.x/iResolution.y, 1.0) * 6.0, 0.0) - iCamPos);\n    \n    // make the maxDepth further\n    float maxDepth = 30.0;\n    #else\n\tvec3 rayOri = vec3((uv - 0.5) * vec2(iResolution.x/iResolution.y, 1.0) * 6.0, 3.0);\n\tvec3 rayDir = vec3(0.0, 0.0, -1.0);\n    float maxDepth = 6.0;\n    #endif\n\t\n\tfloat depth = 0.0;\n\tvec3 p;\n\t\n\tfor(int i = 0; i < 64; i++) {\n\t\tp = rayOri + rayDir * depth;\n\t\tfloat dist = map(p);\n        depth += dist;\n\t\tif (dist < 1e-6) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n    depth = min(maxDepth, depth);\n\tvec3 n = calcNormal(p);\n    float b = max(0.0, dot(n, vec3(0.577)));\n    vec3 col = (0.5 + 0.5 * cos((b + iTime * 3.0) + uv.xyx * 2.0 + vec3(0,2,4))) * (0.85 + b * 0.35);\n    col *= exp( -depth / maxDepth );\n\t\n    #ifdef IS_CINESHADER\n    // set the screen thickness to zero in CineShader\n    fragColor = vec4(col, 0.0);\n    #else\n    // maximum thickness is 2m in alpha channel\n    fragColor = vec4(col, 1.0 - (depth - 0.5) / 2.0);\n    #endif\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"Parallax view on Cineshader\",\n\t\"description\": \"It uses the iCamPos for parallax view but it cause issues on the reflection. Still fun to mess with it though.\",\n\t\"model\": \"person\"\n}\n*/",
    "tags": [
      "cineshader"
    ],
    "author": "edankwan",
    "views": 0,
    "likes": 37,
    "published": 3
  },
  {
    "id": "tt3XDn",
    "title": "FWA logo",
    "description": "Trace the FWA logo with capsule sdf. View this shader at [url]https://cineshader.com/view/tt3XDn[/url]",
    "code": "\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 opRep( in vec3 p, in vec3 c, out vec3 idx)\n{\n    p = (p + 0.5 * c) / c;\n    vec3 floorP = floor(p);\n    vec3 fractP = fract(p);\n    idx = floorP;\n    return fractP * c - 0.5 * c;\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nvec2 map(vec3 p)\n{\n    vec3 idx;\n    p = opRep(p, vec3(6.0, 3.0, 5.0), idx);\n    \n    vec2 res = vec2(0.0, 0.0);\n    float thickness = 0.275;\n    float fwaD = 100.0;\n    \n    float r = hash13(idx * 100.0 + floor(iTime * 2.14));\n    \n    if (r > 0.2 + step(dot(idx, idx), 0.5)) {\n        return vec2(0.75, 0.0);\n    }\n    \nfwaD = min(fwaD, sdCapsule(p, vec3(-2.1975012, 0, 0.0), vec3(-1.1325011999999999, 0, 0.0), thickness));\nfwaD = min(fwaD, sdCapsule(p, vec3(-1.7825011499999996, -0.44249114999999994, 0.0), vec3(-1.7825011499999996, 0.42000885000000004, 0.0), thickness));\nfwaD = min(fwaD, sdCapsule(p, vec3(-0.9700012499999998, 0.42000885000000004, 0.0), vec3(-1.7825011499999996, 0.42000885000000004, 0.0), thickness));\nfwaD = min(fwaD, sdCapsule(p, vec3(-0.5375011499999998, -0.44249114999999994, 0.0), vec3(-0.9700012499999998, 0.42000885000000004, 0.0), thickness));\nfwaD = min(fwaD, sdCapsule(p, vec3(-0.10000124999999968, 0.42000885000000004, 0.0), vec3(-0.5375011499999998, -0.44249114999999994, 0.0), thickness));\nfwaD = min(fwaD, sdCapsule(p, vec3(0.3274987500000003, -0.44249114999999994, 0.0), vec3(-0.10000124999999968, 0.42000885000000004, 0.0), thickness));\nfwaD = min(fwaD, sdCapsule(p, vec3(0.7749988500000001, 0.42000885000000004, 0.0), vec3(0.3274987500000003, -0.44249114999999994, 0.0), thickness));\nfwaD = min(fwaD, sdCapsule(p, vec3(1.7774988, 0.42000885000000004, 0.0), vec3(0.7749988500000001, 0.42000885000000004, 0.0), thickness));\nfwaD = min(fwaD, sdCapsule(p, vec3(1.7774988, -0.41249115, 0.0), vec3(1.7774988, 0.42000885000000004, 0.0), thickness));\nfwaD = min(fwaD, sdCapsule(p, vec3(0.9424987500000003, -0.41249115, 0.0), vec3(1.7774988, -0.41249115, 0.0), thickness));\nfwaD = min(fwaD, sdCapsule(p, vec3(0.9424741500000001, -0.012491100000000017, 0.0), vec3(0.9424987500000003, -0.41249115, 0.0), thickness));\nfwaD = min(fwaD, sdCapsule(p, vec3(2.2149741000000005, -0.015, 0.0), vec3(0.9424741500000001, -0.012491100000000017, 0.0), thickness));\n\t\n    res.x = fwaD;\n    res.y = step(0.24, p.z);\n    \n    return res;\n}\n\nvec3 calcNormal( in vec3 p )\n{\n    const float h = 1e-5; // or some other value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*h ).x + \n                      k.yyx*map( p + k.yyx*h ).x + \n                      k.yxy*map( p + k.yxy*h ).x + \n                      k.xxx*map( p + k.xxx*h ).x );\n}\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, s, -s, c);\n\treturn m * v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // screen size is 6m x 6m\n    \n    float t = iTime * 0.2;\n    vec3 off0 = fract(vec3(t * 2.516 - 0.642, -t * 0.541 - 0.624, t * 0.532 - 0.74)) - 0.5;\n    vec3 off1 = fract(vec3(-t * 0.512 - 0.3412, t * 2.537 - 0.92, -t * 0.5327 - 0.24)) - 0.5;\n    vec3 off2 = fract(vec3(t * 0.47 - 0.835, t * 0.537 - 0.753, -t * 0.47 - 0.845)) - 0.5;\n    vec3 off3 = fract(vec3(t * 0.324 - 0.23, -t * 0.537 - 0.324, t * 2.5327 - 0.56)) - 0.5;\n    \n\tvec3 rayOri = vec3(0.0, 0.0, 3.0) + off0 * off2 * vec3(12.0, 12.0, 6.0);\n    vec3 target = vec3(rotate((uv - 0.5) * vec2(iResolution.x/iResolution.y, 1.0), dot(off0, off1) * 3.0) * 6.0, 0.0) + off1 * off3 * vec3(12.0, 12.0, 6.0);\n\tvec3 rayDir = normalize(target - rayOri);\n\t\n\tfloat depth = 0.0;\n\tvec3 p;\n    vec2 res;\n\t\n\tfor(int i = 0; i < 64; i++) {\n\t\tp = rayOri + rayDir * depth;\n\t\tres = map(p);\n        depth += res.x;\n\t\tif (res.x < 1e-5) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n    depth = min(50.0, depth);\n\tvec3 n = calcNormal(p);\n    float b = max(0.0, dot(n, vec3(0.577)));\n    vec3 col = mix(vec3(0.5), vec3(1.0), b) * 1.75;\n    col *= exp((-depth + 0.5) * 0.15);\n    col *= max(smoothstep(0.1, 0.5, res.x) + 0.075 * b, res.y);\n\t\n    // maximum thickness is 2m in alpha channel\n    fragColor = vec4(col, 1.0 - (depth - 1.0) / 20.0);\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"FWA logo\",\n\t\"description\": \"Trace the FWA logo with capsule sdf.\",\n\t\"model\": \"person\"\n}\n*/",
    "tags": [
      "cineshader"
    ],
    "author": "edankwan",
    "views": 0,
    "likes": 31,
    "published": 3
  },
  {
    "id": "3lsSzf",
    "title": "Happy Jumping",
    "description": "A happy and blobby creature jumping. Making of and related math/shader/art explanations (6 hours long): [url=https://www.youtube.com/watch?v=Cfe5UQ-1L9Q&list=PL0EpikNmjs2CYUMePMGh3IjjP4tQlYqji]https://www.youtube.com/watch?v=Cfe5UQ-1L9Q[/url]. ",
    "code": "// Copyright Inigo Quilez, 2019 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work neither\n// as it is or altered, here on Shadertoy or anywhere else, in any\n// form including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it or train a neural\n// network with it without permission. I share this Work for educational\n// purposes, and you can link to it, through an URL, proper attribution\n// and unmodified screenshot, as part of your educational material. If\n// these conditions are too restrictive please contact me and we'll\n// definitely work it out.\n\n\n// An animation test - a happy and blobby creature jumping and looking\n// around. It gets off-model very often, but it looks good enough I think.\n//\n// Making-of live stream: https://www.youtube.com/watch?v=Cfe5UQ-1L9Q\n\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2  // Set AA to 1 if your machine is too slow\n#endif\n\n\n//------------------------------------------------------------------\n\n\n// https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\n// https://iquilezles.org/articles/smin\nvec2 smin( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// https://iquilezles.org/articles/smin\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nvec2 sdStick(vec3 p, vec3 a, vec3 b, float r1, float r2) // approximated\n{\n    vec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( length( pa - ba*h ) - mix(r1,r2,h*h*(3.0-2.0*h)), h );\n}\n\n// https://iquilezles.org/articles/smin\nvec4 opU( vec4 d1, vec4 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\n\nfloat href;\nfloat hsha;\n\nvec4 map( in vec3 pos, float atime )\n{\n    hsha = 1.0;\n    \n    float t1 = fract(atime);\n    float t4 = abs(fract(atime*0.5)-0.5)/0.5;\n\n    float p = 4.0*t1*(1.0-t1);\n    float pp = 4.0*(1.0-2.0*t1); // derivative of p\n\n    vec3 cen = vec3( 0.5*(-1.0 + 2.0*t4),\n                     pow(p,2.0-p) + 0.1,\n                     floor(atime) + pow(t1,0.7) -1.0 );\n\n    // body\n    vec2 uu = normalize(vec2( 1.0, -pp ));\n    vec2 vv = vec2(-uu.y, uu.x);\n    \n    float sy = 0.5 + 0.5*p;\n    float compress = 1.0-smoothstep(0.0,0.4,p);\n    sy = sy*(1.0-compress) + compress;\n    float sz = 1.0/sy;\n\n    vec3 q = pos - cen;\n    float rot = -0.25*(-1.0 + 2.0*t4);\n    float rc = cos(rot);\n    float rs = sin(rot);\n    q.xy = mat2x2(rc,rs,-rs,rc)*q.xy;\n    vec3 r = q;\n\thref = q.y;\n    q.yz = vec2( dot(uu,q.yz), dot(vv,q.yz) );\n    \n    float deli = sdEllipsoid( q, vec3(0.25, 0.25*sy, 0.25*sz) );\n    vec4 res = vec4( deli, 2.0, 0.0, 1.0 );\n\n    // ground\n    float fh = -0.1 - 0.05*(sin(pos.x*2.0)+sin(pos.z*2.0));\n    float t5f = fract(atime+0.05);\n    float t5i = floor(atime+0.05); \n    float bt4 = abs(fract(t5i*0.5)-0.5)/0.5;\n    vec2  bcen = vec2( 0.5*(-1.0+2.0*bt4),t5i+pow(t5f,0.7)-1.0 );\n    \n    float k = length(pos.xz-bcen);\n    float tt = t5f*15.0-6.2831 - k*3.0;\n    fh -= 0.1*exp(-k*k)*sin(tt)*exp(-max(tt,0.0)/2.0)*smoothstep(0.0,0.01,t5f);\n    float d = pos.y - fh;\n    \n    // bubbles\n    {\n    vec3 vp = vec3( mod(abs(pos.x),3.0)-1.5,pos.y,mod(pos.z+1.5,3.0)-1.5);\n    vec2 id = vec2( floor(pos.x/3.0), floor((pos.z+1.5)/3.0) );\n    float fid = id.x*11.1 + id.y*31.7;\n    float fy = fract(fid*1.312+atime*0.1);\n    float y = -1.0+4.0*fy;\n    vec3  rad = vec3(0.7,1.0+0.5*sin(fid),0.7);\n    rad -= 0.1*(sin(pos.x*3.0)+sin(pos.y*4.0)+sin(pos.z*5.0));    \n    float siz = 4.0*fy*(1.0-fy);\n    float d2 = sdEllipsoid( vp-vec3(0.5,y,0.0), siz*rad );\n    \n    d2 -= 0.03*smoothstep(-1.0,1.0,sin(18.0*pos.x)+sin(18.0*pos.y)+sin(18.0*pos.z));\n    d2 *= 0.6;\n    d2 = min(d2,2.0);\n    d = smin( d, d2, 0.32 );\n    if( d<res.x ) { res = vec4(d,1.0,0.0,1.0); hsha=sqrt(siz); }\n    }\n\n    // rest of body\n    if( deli-1.0 < res.x ) // bounding volume\n\t{\n    float t2 = fract(atime+0.8);\n    float p2 = 0.5-0.5*cos(6.2831*t2);\n    r.z += 0.05-0.2*p2;\n    r.y += 0.2*sy-0.2;\n    vec3 sq = vec3( abs(r.x), r.yz );\n\n\t// head\n    vec3 h = r;\n    float hr = sin(0.791*atime);\n    hr = 0.7*sign(hr)*smoothstep(0.5,0.7,abs(hr));\n    h.xz = mat2x2(cos(hr),sin(hr),-sin(hr),cos(hr))*h.xz;\n    vec3 hq = vec3( abs(h.x), h.yz );\n   \tfloat d  = sdEllipsoid( h-vec3(0.0,0.20,0.02), vec3(0.08,0.2,0.15) );\n\tfloat d2 = sdSphere( h-vec3(0.0,0.21,-0.1), 0.2 );\n\td = smin( d, d2, 0.1 );\n    res.x = smin( res.x, d, 0.1 );\n    \n    // belly wrinkles\n    {\n    float yy = r.y-0.02-2.5*r.x*r.x;\n    res.x += 0.001*sin(yy*120.0)*(1.0-smoothstep(0.0,0.1,abs(yy)));\n    }\n        \n    // arms\n    {\n    vec2 arms = sdStick( sq, vec3(0.18-0.06*hr*sign(r.x),0.2,-0.05), vec3(0.3+0.1*p2,-0.2+0.3*p2,-0.15), 0.03, 0.06 );\n    res.xz = smin( res.xz, arms, 0.01+0.04*(1.0-arms.y)*(1.0-arms.y)*(1.0-arms.y) );\n    }\n        \n    // ears\n    {\n    float t3 = fract(atime+0.9);\n    float p3 = 4.0*t3*(1.0-t3);\n    vec2 ear = sdStick( hq, vec3(0.15,0.32,-0.05), vec3(0.2+0.05*p3,0.2+0.2*p3,-0.07), 0.01, 0.04 );\n    res.xz = smin( res.xz, ear, 0.01 );\n    }\n    \n    // mouth\n    {\n   \td = sdEllipsoid( h-vec3(0.0,0.15+4.0*hq.x*hq.x,0.15), vec3(0.1,0.04,0.2) );\n    res.w = 0.3+0.7*clamp( d*150.0,0.0,1.0);\n    res.x = smax( res.x, -d, 0.03 );\n    }\n\n\t// legs\n    {\n    float t6 = cos(6.2831*(atime*0.5+0.25));\n    float ccc = cos(1.57*t6*sign(r.x));\n    float sss = sin(1.57*t6*sign(r.x));\n\tvec3 base = vec3(0.12,-0.07,-0.1); base.y -= 0.1/sy;\n    vec2 legs = sdStick( sq, base, base + vec3(0.2,-ccc,sss)*0.2, 0.04, 0.07 );\n    res.xz = smin( res.xz, legs, 0.07 );\n    }\n        \n    // eye\n    {\n    float blink = pow(0.5+0.5*sin(2.1*iTime),20.0);\n    float eyeball = sdSphere(hq-vec3(0.08,0.27,0.06),0.065+0.02*blink);\n    res.x = smin( res.x, eyeball, 0.03 );\n    \n    vec3 cq = hq-vec3(0.1,0.34,0.08);\n    cq.xy = mat2x2(0.8,0.6,-0.6,0.8)*cq.xy;\n    d = sdEllipsoid( cq, vec3(0.06,0.03,0.03) );\n    res.x = smin( res.x, d, 0.03 );\n\n    float eo = 1.0-0.5*smoothstep(0.01,0.04,length((hq.xy-vec2(0.095,0.285))*vec2(1.0,1.1)));\n    res = opU( res, vec4(sdSphere(hq-vec3(0.08,0.28,0.08),0.060),3.0,0.0,eo));\n    res = opU( res, vec4(sdSphere(hq-vec3(0.075,0.28,0.102),0.0395),4.0,0.0,1.0));\n    }\n\t}\n\n    // candy\n    if( pos.y-1.0 < res.x ) // bounding volume\n    {\n    float fs = 5.0;\n    vec3 qos = fs*vec3(pos.x, pos.y-fh, pos.z );\n    vec2 id = vec2( floor(qos.x+0.5), floor(qos.z+0.5) );\n    vec3 vp = vec3( fract(qos.x+0.5)-0.5,qos.y,fract(qos.z+0.5)-0.5);\n    vp.xz += 0.1*cos( id.x*130.143 + id.y*120.372 + vec2(0.0,2.0) );\n    float den = sin(id.x*0.1+sin(id.y*0.091))+sin(id.y*0.1);\n    float fid = id.x*0.143 + id.y*0.372;\n    float ra = smoothstep(0.0,0.1,den*0.1+fract(fid)-0.95);\n    d = sdSphere( vp, 0.35*ra )/fs;\n    if( d<res.x ) res = vec4(d,5.0,qos.y,1.0);\n    }\n    \n    return res;\n}\n\nvec4 raycast( in vec3 ro, in vec3 rd, float time )\n{\n    vec4 res = vec4(-1.0,-1.0,0.0,1.0);\n\n    float tmin = 0.5;\n    float tmax = 20.0;\n    \n\t#if 1\n    // raytrace bounding plane\n    float tp = (3.4-ro.y)/rd.y;\n    if( tp>0.0 ) tmax = min( tmax, tp );\n\t#endif    \n    \n    // raymarch scene\n    float t = tmin;\n    for( int i=0; i<256 && t<tmax; i++ )\n    {\n        vec4 h = map( ro+rd*t, time );\n        if( abs(h.x)<(0.0005*t) )\n        { \n            res = vec4(t,h.yzw); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float time )\n{\n    float res = 1.0;\n\n    float tmax = 12.0;\n    #if 1\n    float tp = (3.4-ro.y)/rd.y; // raytrace bounding plane\n    if( tp>0.0 ) tmax = min( tmax, tp );\n\t#endif    \n    \n    float t = 0.02;\n    for( int i=0; i<50; i++ )\n    {\n\t\tfloat h = map( ro + rd*t, time ).x;\n        res = min( res, mix(1.0,16.0*h/t, hsha) );\n        t += clamp( h, 0.05, 0.40 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, float time )\n{\n    \n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.001;\n    return normalize( e.xyy*map( pos + e.xyy, time ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, time ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, time ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx, time ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.001*e,time).x;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor, float time )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float h = 0.01 + 0.11*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = map( opos, time ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvec3 render( in vec3 ro, in vec3 rd, float time )\n{ \n    // sky dome\n    vec3 col = vec3(0.5, 0.8, 0.9) - max(rd.y,0.0)*0.5;\n    // sky clouds\n    vec2 uv = 1.5*rd.xz/rd.y;\n    float cl  = 1.0*(sin(uv.x)+sin(uv.y)); uv *= mat2(0.8,0.6,-0.6,0.8)*2.1;\n          cl += 0.5*(sin(uv.x)+sin(uv.y));\n    col += 0.1*(-1.0+2.0*smoothstep(-0.1,0.1,cl-0.4));\n    // sky horizon\n\tcol = mix( col, vec3(0.5, 0.7, .9), exp(-10.0*max(rd.y,0.0)) );    \n\n    // scene geometry\n    vec4 res = raycast(ro,rd, time);\n    if( res.y>-0.5 )\n    {\n        float t = res.x;\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, time );\n        vec3 ref = reflect( rd, nor );\n        float focc = res.w;\n        \n        // material        \n\t\tcol = vec3(0.2);\n        float ks = 1.0;\n\n        if( res.y>4.5 )  // candy\n        { \n             col = vec3(0.14,0.048,0.0); \n             vec2 id = floor(5.0*pos.xz+0.5);\n\t\t     col += 0.036*cos((id.x*11.1+id.y*37.341) + vec3(0.0,1.0,2.0) );\n             col = max(col,0.0);\n             focc = clamp(4.0*res.z,0.0,1.0);\n        }\n        else if( res.y>3.5 ) // eyeball\n        { \n            col = vec3(0.0);\n        } \n        else if( res.y>2.5 ) // iris\n        { \n            col = vec3(0.4);\n        } \n        else if( res.y>1.5 ) // body\n        { \n            col = mix(vec3(0.144,0.09,0.0036),vec3(0.36,0.1,0.04),res.z*res.z);\n            col = mix(col,vec3(0.14,0.09,0.06)*2.0, (1.0-res.z)*smoothstep(-0.15, 0.15, -href));\n        }\n\t\telse // terrain\n        {\n            // base green            \n            col = vec3(0.05,0.09,0.02);\n            float f = 0.2*(-1.0+2.0*smoothstep(-0.2,0.2,sin(18.0*pos.x)+sin(18.0*pos.y)+sin(18.0*pos.z)));\n            col += f*vec3(0.06,0.06,0.02);\n            ks = 0.5 + pos.y*0.15;\n            \n\t\t\t// footprints            \n            vec2 mp = vec2(pos.x-0.5*(mod(floor(pos.z+0.5),2.0)*2.0-1.0), fract(pos.z+0.5)-0.5 );\n            float mark = 1.0-smoothstep(0.1, 0.5, length(mp));\n            mark *= smoothstep(0.0, 0.1, floor(time) - floor(pos.z+0.5) );\n            col *= mix( vec3(1.0), vec3(0.5,0.5,0.4), mark );\n            ks *= 1.0-0.5*mark;\n        }\n        \n        // lighting (sun, sky, bounce, back, sss)\n        float occ = calcOcclusion( pos, nor, time )*focc;\n        float fre = clamp(1.0+dot(nor,rd),0.0,1.0);\n        \n        vec3  sun_lig = normalize( vec3(0.6, 0.35, 0.5) );\n        float sun_dif = clamp(dot( nor, sun_lig ), 0.0, 1.0 );\n        vec3  sun_hal = normalize( sun_lig-rd );\n        float sun_sha = calcSoftshadow( pos, sun_lig, time );\n\t\tfloat sun_spe = ks*pow(clamp(dot(nor,sun_hal),0.0,1.0),8.0)*sun_dif*(0.04+0.96*pow(clamp(1.0+dot(sun_hal,rd),0.0,1.0),5.0));\n\t\tfloat sky_dif = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n        float sky_spe = ks*smoothstep( 0.0, 0.5, ref.y )*(0.04+0.96*pow(fre,4.0));\n        float bou_dif = sqrt(clamp( 0.1-0.9*nor.y, 0.0, 1.0 ))*clamp(1.0-0.1*pos.y,0.0,1.0);\n        float bac_dif = clamp(0.1+0.9*dot( nor, normalize(vec3(-sun_lig.x,0.0,-sun_lig.z))), 0.0, 1.0 );\n        float sss_dif = fre*sky_dif*(0.25+0.75*sun_dif*sun_sha);\n\n\t\tvec3 lin = vec3(0.0);\n        lin += sun_dif*vec3(8.10,6.00,4.20)*vec3(sun_sha,sun_sha*sun_sha*0.5+0.5*sun_sha,sun_sha*sun_sha);\n        lin += sky_dif*vec3(0.50,0.70,1.00)*occ;\n        lin += bou_dif*vec3(0.20,0.70,0.10)*occ;\n        lin += bac_dif*vec3(0.45,0.35,0.25)*occ;\n        lin += sss_dif*vec3(3.25,2.75,2.50)*occ;\n\t\tcol = col*lin;\n\t\tcol += sun_spe*vec3(9.90,8.10,6.30)*sun_sha;\n        col += sky_spe*vec3(0.20,0.30,0.65)*occ*occ;\n      \t\n        col = pow(col,vec3(0.8,0.9,1.0) );\n        \n        // fog\n        col = mix( col, vec3(0.5,0.7,0.9), 1.0-exp( -0.0001*t*t*t ) );\n    }\n\n    return col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        // time coordinate (motion blurred, shutter=0.5)\n        // see https://www.shadertoy.com/view/4sBGD1\n        float d = 0.5+0.5*sin(fragCoord.x*147.0)*sin(fragCoord.y*131.0);\n        float time = iTime - 0.5*(1.0/24.0)*(float(m*AA+n)+d)/float(AA*AA);\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        float time = iTime;\n#endif\n        time += -2.6;\n        time *= 0.9;\n        \n        // camera\t\n        float cl = sin(0.5*time);\n        float an = 1.57 + 0.7*sin(0.15*time);\n        vec3  ta = vec3( 0.0, 0.65, -0.6+time*1.0 - 0.4*cl);\n        vec3  ro = ta + vec3( 1.3*cos(an), -0.250, 1.3*sin(an) );\n        float ti = fract(time-0.15);\n        ti = 4.0*ti*(1.0-ti);        \n        ta.y += 0.15*ti*ti*(3.0-2.0*ti)*smoothstep(0.4,0.9,cl);\n        \n        // camera bounce\n        float t4 = abs(fract(time*0.5)-0.5)/0.5;\n        float bou = -1.0 + 2.0*t4;\n        ro += 0.06*sin(time*12.0+vec3(0.0,2.0,4.0))*smoothstep( 0.85, 1.0, abs(bou) );\n\n        // camera-to-world rotation\n        mat3 ca = setCamera( ro, ta, 0.0 );\n\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p,1.8) );\n        \n        // render\t\n        vec3 col = render( ro, rd, time );\n\n        // color grading\n        col = col*vec3(1.11,0.89,0.79);\n\n        // compress        \n        col = 1.35*col/(1.0+col);\n        \n        // gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    // s-surve    \n    tot = clamp(tot,0.0,1.0);\n    tot = tot*tot*(3.0-2.0*tot);\n\n    // vignetting        \n    vec2 q = fragCoord/iResolution.xy;\n    tot *= 0.5 + 0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.25);\n\n    // output    \n    fragColor = vec4( tot, 1.0 );\n}",
    "tags": [
      "procedural",
      "3d",
      "raymarching",
      "sdf",
      "animation"
    ],
    "author": "iq",
    "views": 0,
    "likes": 1032,
    "published": 3
  },
  {
    "id": "lsl3RH",
    "title": "Warping - procedural 2",
    "description": "Warp. Tutorial here: https://iquilezles.org/articles/warp",
    "code": "// Copyright Inigo Quilez, 2013 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work neither\n// as it is or altered, here on Shadertoy or anywhere else, in any\n// form including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it or train a neural\n// network with it without permission. I share this Work for educational\n// purposes, and you can link to it, through an URL, proper attribution\n// and unmodified screenshot, as part of your educational material. If\n// these conditions are too restrictive please contact me and we'll\n// definitely work it out.\n\n\n// See here for a tutorial on how to make this:\n//\n// https://iquilezles.org/articles/warp\n\n//====================================================================\n\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat noise( in vec2 p )\n{\n\treturn sin(p.x)*sin(p.y);\n}\n\nfloat fbm4( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\n\nfloat fbm6( vec2 p )\n{\n    float f = 0.0;\n    f += 0.500000*(0.5+0.5*noise( p )); p = m*p*2.02;\n    f += 0.250000*(0.5+0.5*noise( p )); p = m*p*2.03;\n    f += 0.125000*(0.5+0.5*noise( p )); p = m*p*2.01;\n    f += 0.062500*(0.5+0.5*noise( p )); p = m*p*2.04;\n    f += 0.031250*(0.5+0.5*noise( p )); p = m*p*2.01;\n    f += 0.015625*(0.5+0.5*noise( p ));\n    return f/0.96875;\n}\n\nvec2 fbm4_2( vec2 p )\n{\n    return vec2(fbm4(p), fbm4(p+vec2(7.8)));\n}\n\nvec2 fbm6_2( vec2 p )\n{\n    return vec2(fbm6(p+vec2(16.8)), fbm6(p+vec2(11.5)));\n}\n\n//====================================================================\n\nfloat func( vec2 q, out vec4 ron )\n{\n    q += 0.03*sin( vec2(0.27,0.23)*iTime + length(q)*vec2(4.1,4.3));\n\n\tvec2 o = fbm4_2( 0.9*q );\n\n    o += 0.04*sin( vec2(0.12,0.14)*iTime + length(o));\n\n    vec2 n = fbm6_2( 3.0*o );\n\n\tron = vec4( o, n );\n\n    float f = 0.5 + 0.5*fbm4( 1.8*q + 6.0*n );\n\n    return mix( f, f*f*f*3.5, f*abs(n.x) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    float e = 2.0/iResolution.y;\n\n    vec4 on = vec4(0.0);\n    float f = func(p, on);\n\n\tvec3 col = vec3(0.0);\n    col = mix( vec3(0.2,0.1,0.4), vec3(0.3,0.05,0.05), f );\n    col = mix( col, vec3(0.9,0.9,0.9), dot(on.zw,on.zw) );\n    col = mix( col, vec3(0.4,0.3,0.3), 0.2 + 0.5*on.y*on.y );\n    col = mix( col, vec3(0.0,0.2,0.4), 0.5*smoothstep(1.2,1.3,abs(on.z)+abs(on.w)) );\n    col = clamp( col*f*2.0, 0.0, 1.0 );\n    \n#if 0\n    // gpu derivatives - bad quality, but fast\n\tvec3 nor = normalize( vec3( dFdx(f)*iResolution.x, 6.0, dFdy(f)*iResolution.y ) );\n#else    \n    // manual derivatives - better quality, but slower\n    vec4 kk;\n \tvec3 nor = normalize( vec3( func(p+vec2(e,0.0),kk)-f, \n                                2.0*e,\n                                func(p+vec2(0.0,e),kk)-f ) );\n#endif    \n\n    vec3 lig = normalize( vec3( 0.9, 0.2, -0.4 ) );\n    float dif = clamp( 0.3+0.7*dot( nor, lig ), 0.0, 1.0 );\n    vec3 lin = vec3(0.70,0.90,0.95)*(nor.y*0.5+0.5) + vec3(0.15,0.10,0.05)*dif;\n    col *= 1.2*lin;\n\tcol = 1.0 - col;\n\tcol = 1.1*col*col;\n    \n    fragColor = vec4( col, 1.0 );\n}\n",
    "tags": [
      "procedural",
      "2d",
      "fbm"
    ],
    "author": "iq",
    "views": 0,
    "likes": 757,
    "published": 3
  },
  {
    "id": "MdXyzX",
    "title": "Very fast procedural ocean",
    "description": "It's fast because it doesn't use noise but rather sin waves",
    "code": "// afl_ext 2017-2024\n// MIT License\n\n// Use your mouse to move the camera around! Press the Left Mouse Button on the image to look around!\n\n#define DRAG_MULT 0.38 // changes how much waves pull on the water\n#define WATER_DEPTH 1.0 // how deep is the water\n#define CAMERA_HEIGHT 1.5 // how high the camera should be\n#define ITERATIONS_RAYMARCH 12 // waves iterations of raymarching\n#define ITERATIONS_NORMAL 36 // waves iterations when calculating normals\n\n#define NormalizedMouse (iMouse.xy / iResolution.xy) // normalize mouse coords\n\n// Calculates wave value and its derivative, \n// for the wave direction, position in space, wave frequency and time\nvec2 wavedx(vec2 position, vec2 direction, float frequency, float timeshift) {\n  float x = dot(direction, position) * frequency + timeshift;\n  float wave = exp(sin(x) - 1.0);\n  float dx = wave * cos(x);\n  return vec2(wave, -dx);\n}\n\n// Calculates waves by summing octaves of various waves with various parameters\nfloat getwaves(vec2 position, int iterations) {\n  float wavePhaseShift = length(position) * 0.1; // this is to avoid every octave having exactly the same phase everywhere\n  float iter = 0.0; // this will help generating well distributed wave directions\n  float frequency = 1.0; // frequency of the wave, this will change every iteration\n  float timeMultiplier = 2.0; // time multiplier for the wave, this will change every iteration\n  float weight = 1.0;// weight in final sum for the wave, this will change every iteration\n  float sumOfValues = 0.0; // will store final sum of values\n  float sumOfWeights = 0.0; // will store final sum of weights\n  for(int i=0; i < iterations; i++) {\n    // generate some wave direction that looks kind of random\n    vec2 p = vec2(sin(iter), cos(iter));\n    \n    // calculate wave data\n    vec2 res = wavedx(position, p, frequency, iTime * timeMultiplier + wavePhaseShift);\n\n    // shift position around according to wave drag and derivative of the wave\n    position += p * res.y * weight * DRAG_MULT;\n\n    // add the results to sums\n    sumOfValues += res.x * weight;\n    sumOfWeights += weight;\n\n    // modify next octave ;\n    weight = mix(weight, 0.0, 0.2);\n    frequency *= 1.18;\n    timeMultiplier *= 1.07;\n\n    // add some kind of random value to make next wave look random too\n    iter += 1232.399963;\n  }\n  // calculate and return\n  return sumOfValues / sumOfWeights;\n}\n\n// Raymarches the ray from top water layer boundary to low water layer boundary\nfloat raymarchwater(vec3 camera, vec3 start, vec3 end, float depth) {\n  vec3 pos = start;\n  vec3 dir = normalize(end - start);\n  for(int i=0; i < 64; i++) {\n    // the height is from 0 to -depth\n    float height = getwaves(pos.xz, ITERATIONS_RAYMARCH) * depth - depth;\n    // if the waves height almost nearly matches the ray height, assume its a hit and return the hit distance\n    if(height + 0.01 > pos.y) {\n      return distance(pos, camera);\n    }\n    // iterate forwards according to the height mismatch\n    pos += dir * (pos.y - height);\n  }\n  // if hit was not registered, just assume hit the top layer, \n  // this makes the raymarching faster and looks better at higher distances\n  return distance(start, camera);\n}\n\n// Calculate normal at point by calculating the height at the pos and 2 additional points very close to pos\nvec3 normal(vec2 pos, float e, float depth) {\n  vec2 ex = vec2(e, 0);\n  float H = getwaves(pos.xy, ITERATIONS_NORMAL) * depth;\n  vec3 a = vec3(pos.x, H, pos.y);\n  return normalize(\n    cross(\n      a - vec3(pos.x - e, getwaves(pos.xy - ex.xy, ITERATIONS_NORMAL) * depth, pos.y), \n      a - vec3(pos.x, getwaves(pos.xy + ex.yx, ITERATIONS_NORMAL) * depth, pos.y + e)\n    )\n  );\n}\n\n// Helper function generating a rotation matrix around the axis by the angle\nmat3 createRotationMatrixAxisAngle(vec3 axis, float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  float oc = 1.0 - c;\n  return mat3(\n    oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s, \n    oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s, \n    oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c\n  );\n}\n\n// Helper function that generates camera ray based on UV and mouse\nvec3 getRay(vec2 fragCoord) {\n  vec2 uv = ((fragCoord.xy / iResolution.xy) * 2.0 - 1.0) * vec2(iResolution.x / iResolution.y, 1.0);\n  // for fisheye, uncomment following line and comment the next one\n  //vec3 proj = normalize(vec3(uv.x, uv.y, 1.0) + vec3(uv.x, uv.y, -1.0) * pow(length(uv), 2.0) * 0.05);  \n  vec3 proj = normalize(vec3(uv.x, uv.y, 1.5));\n  if(iResolution.x < 600.0) {\n    return proj;\n  }\n  return createRotationMatrixAxisAngle(vec3(0.0, -1.0, 0.0), 3.0 * ((NormalizedMouse.x + 0.5) * 2.0 - 1.0)) \n    * createRotationMatrixAxisAngle(vec3(1.0, 0.0, 0.0), 0.5 + 1.5 * (((NormalizedMouse.y == 0.0 ? 0.27 : NormalizedMouse.y) * 1.0) * 2.0 - 1.0))\n    * proj;\n}\n\n// Ray-Plane intersection checker\nfloat intersectPlane(vec3 origin, vec3 direction, vec3 point, vec3 normal) { \n  return clamp(dot(point - origin, normal) / dot(direction, normal), -1.0, 9991999.0); \n}\n\n// Some very barebones but fast atmosphere approximation\nvec3 extra_cheap_atmosphere(vec3 raydir, vec3 sundir) {\n  //sundir.y = max(sundir.y, -0.07);\n  float special_trick = 1.0 / (raydir.y * 1.0 + 0.1);\n  float special_trick2 = 1.0 / (sundir.y * 11.0 + 1.0);\n  float raysundt = pow(abs(dot(sundir, raydir)), 2.0);\n  float sundt = pow(max(0.0, dot(sundir, raydir)), 8.0);\n  float mymie = sundt * special_trick * 0.2;\n  vec3 suncolor = mix(vec3(1.0), max(vec3(0.0), vec3(1.0) - vec3(5.5, 13.0, 22.4) / 22.4), special_trick2);\n  vec3 bluesky= vec3(5.5, 13.0, 22.4) / 22.4 * suncolor;\n  vec3 bluesky2 = max(vec3(0.0), bluesky - vec3(5.5, 13.0, 22.4) * 0.002 * (special_trick + -6.0 * sundir.y * sundir.y));\n  bluesky2 *= special_trick * (0.24 + raysundt * 0.24);\n  return bluesky2 * (1.0 + 1.0 * pow(1.0 - raydir.y, 3.0));\n} \n\n// Calculate where the sun should be, it will be moving around the sky\nvec3 getSunDirection() {\n  return normalize(vec3(-0.0773502691896258 , 0.5 + sin(iTime * 0.2 + 2.6) * 0.45 , 0.5773502691896258));\n}\n\n// Get atmosphere color for given direction\nvec3 getAtmosphere(vec3 dir) {\n   return extra_cheap_atmosphere(dir, getSunDirection()) * 0.5;\n}\n\n// Get sun color for given direction\nfloat getSun(vec3 dir) { \n  return pow(max(0.0, dot(dir, getSunDirection())), 720.0) * 210.0;\n}\n\n// Great tonemapping function from my other shader: https://www.shadertoy.com/view/XsGfWV\nvec3 aces_tonemap(vec3 color) {  \n  mat3 m1 = mat3(\n    0.59719, 0.07600, 0.02840,\n    0.35458, 0.90834, 0.13383,\n    0.04823, 0.01566, 0.83777\n  );\n  mat3 m2 = mat3(\n    1.60475, -0.10208, -0.00327,\n    -0.53108,  1.10813, -0.07276,\n    -0.07367, -0.00605,  1.07602\n  );\n  vec3 v = m1 * color;  \n  vec3 a = v * (v + 0.0245786) - 0.000090537;\n  vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n  return pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));  \n}\n\n// Main\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  // get the ray\n  vec3 ray = getRay(fragCoord);\n  if(ray.y >= 0.0) {\n    // if ray.y is positive, render the sky\n    vec3 C = getAtmosphere(ray) + getSun(ray);\n    fragColor = vec4(aces_tonemap(C * 2.0),1.0);   \n    return;\n  }\n\n  // now ray.y must be negative, water must be hit\n  // define water planes\n  vec3 waterPlaneHigh = vec3(0.0, 0.0, 0.0);\n  vec3 waterPlaneLow = vec3(0.0, -WATER_DEPTH, 0.0);\n\n  // define ray origin, moving around\n  vec3 origin = vec3(iTime * 0.2, CAMERA_HEIGHT, 1);\n\n  // calculate intersections and reconstruct positions\n  float highPlaneHit = intersectPlane(origin, ray, waterPlaneHigh, vec3(0.0, 1.0, 0.0));\n  float lowPlaneHit = intersectPlane(origin, ray, waterPlaneLow, vec3(0.0, 1.0, 0.0));\n  vec3 highHitPos = origin + ray * highPlaneHit;\n  vec3 lowHitPos = origin + ray * lowPlaneHit;\n\n  // raymatch water and reconstruct the hit pos\n  float dist = raymarchwater(origin, highHitPos, lowHitPos, WATER_DEPTH);\n  vec3 waterHitPos = origin + ray * dist;\n\n  // calculate normal at the hit position\n  vec3 N = normal(waterHitPos.xz, 0.01, WATER_DEPTH);\n\n  // smooth the normal with distance to avoid disturbing high frequency noise\n  N = mix(N, vec3(0.0, 1.0, 0.0), 0.8 * min(1.0, sqrt(dist*0.01) * 1.1));\n\n  // calculate fresnel coefficient\n  float fresnel = (0.04 + (1.0-0.04)*(pow(1.0 - max(0.0, dot(-N, ray)), 5.0)));\n\n  // reflect the ray and make sure it bounces up\n  vec3 R = normalize(reflect(ray, N));\n  R.y = abs(R.y);\n  \n  // calculate the reflection and approximate subsurface scattering\n  vec3 reflection = getAtmosphere(R) + getSun(R);\n  vec3 scattering = vec3(0.0293, 0.0698, 0.1717) * 0.1 * (0.2 + (waterHitPos.y + WATER_DEPTH) / WATER_DEPTH);\n\n  // return the combined result\n  vec3 C = fresnel * reflection + scattering;\n  fragColor = vec4(aces_tonemap(C * 2.0), 1.0);\n}",
    "tags": [
      "waves",
      "sea",
      "water",
      "ocean",
      "seascape",
      "scape"
    ],
    "author": "afl_ext",
    "views": 0,
    "likes": 792,
    "published": 3
  },
  {
    "id": "MdX3zr",
    "title": "Flame",
    "description": "Simple flame in distance field.",
    "code": "// Created by anatole duprat - XT95/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat noise(vec3 p) //Thx to Las^Mercury\n{\n\tvec3 i = floor(p);\n\tvec4 a = dot(i, vec3(1., 57., 21.)) + vec4(0., 57., 21., 78.);\n\tvec3 f = cos((p-i)*acos(-1.))*(-.5)+.5;\n\ta = mix(sin(cos(a)*a),sin(cos(1.+a)*(1.+a)), f.x);\n\ta.xy = mix(a.xz, a.yw, f.y);\n\treturn mix(a.x, a.y, f.z);\n}\n\nfloat sphere(vec3 p, vec4 spr)\n{\n\treturn length(spr.xyz-p) - spr.w;\n}\n\nfloat flame(vec3 p)\n{\n\tfloat d = sphere(p*vec3(1.,.5,1.), vec4(.0,-1.,.0,1.));\n\treturn d + (noise(p+vec3(.0,iTime*2.,.0)) + noise(p*3.)*.5)*.25*(p.y) ;\n}\n\nfloat scene(vec3 p)\n{\n\treturn min(100.-length(p) , abs(flame(p)) );\n}\n\nvec4 raymarch(vec3 org, vec3 dir)\n{\n\tfloat d = 0.0, glow = 0.0, eps = 0.02;\n\tvec3  p = org;\n\tbool glowed = false;\n\t\n\tfor(int i=0; i<64; i++)\n\t{\n\t\td = scene(p) + eps;\n\t\tp += d * dir;\n\t\tif( d>eps )\n\t\t{\n\t\t\tif(flame(p) < .0)\n\t\t\t\tglowed=true;\n\t\t\tif(glowed)\n       \t\t\tglow = float(i)/64.;\n\t\t}\n\t}\n\treturn vec4(p,glow);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 v = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\tv.x *= iResolution.x/iResolution.y;\n\t\n\tvec3 org = vec3(0., -2., 4.);\n\tvec3 dir = normalize(vec3(v.x*1.6, -v.y, -1.5));\n\t\n\tvec4 p = raymarch(org, dir);\n\tfloat glow = p.w;\n\t\n\tvec4 col = mix(vec4(1.,.5,.1,1.), vec4(0.1,.5,1.,1.), p.y*.02+.4);\n\t\n\tfragColor = mix(vec4(0.), col, pow(glow*2.,4.));\n\t//fragColor = mix(vec4(1.), mix(vec4(1.,.5,.1,1.),vec4(0.1,.5,1.,1.),p.y*.02+.4), pow(glow*2.,4.));\n\n}\n\n",
    "tags": [
      "3d",
      "distancefield",
      "transparency"
    ],
    "author": "XT95",
    "views": 0,
    "likes": 1260,
    "published": 3
  },
  {
    "id": "XtlSD7",
    "title": "[SIG15] Mario World 1-1",
    "description": "NES Super Mario Bros. World 1-1. My favorite game moment (just like for most kids in the early 90s). 20 years later implemented in a single shader.",
    "code": "// Interesting findings from original NES Super Mario Bros.:\n// -Clouds and brushes of all sizes are drawn using the same small sprite (32x24)\n// -Hills, clouds and bushes weren't placed manually. Every background object type is repeated after 768 pixels.\n// -Overworld (main theme) drum sound uses only the APU noise generator\n\n#define SPRITE_DEC( x, i ) \tmod( floor( i / pow( 4.0, mod( x, 8.0 ) ) ), 4.0 )\n#define SPRITE_DEC2( x, i ) mod( floor( i / pow( 4.0, mod( x, 11.0 ) ) ), 4.0 )\n#define RGB( r, g, b ) vec3( float( r ) / 255.0, float( g ) / 255.0, float( b ) / 255.0 )\n\nconst float MARIO_SPEED\t = 89.0;\nconst float GOOMBA_SPEED = 32.0;\nconst float INTRO_LENGTH = 2.0;\n\nvoid SpriteBlock( inout vec3 color, float x, float y )\n{\n    // black\n    float idx = 1.0;\n    \n    // light orange\n    idx = x < y ? 3.0 : idx;\n    \n    // dark orange\n    idx = x > 3.0 && x < 12.0 && y > 3.0 && y < 12.0 ? 2.0 : idx;\n    idx = x == 15.0 - y ? 2.0 : idx;\n    \n    color = RGB( 0, 0, 0 );\n\tcolor = idx == 2.0 ? RGB( 231,  90,  16 ) : color;\n\tcolor = idx == 3.0 ? RGB( 247, 214, 181 ) : color;\n}\n\nvoid SpriteHill( inout vec3 color, float x, float y )\n{\n    float idx = 0.0;\n    \n    // dark green\n    idx = ( x > y && 79.0 - x > y ) && y < 33.0 ? 2.0 : idx;\n    idx = ( x >= 37.0 && x <= 42.0 ) && y == 33.0 ? 2.0 : idx;\n    \n    // black\n    idx = ( x == y || 79.0 - x == y ) && y < 33.0 ? 1.0 : idx;\n    idx = ( x == 33.0 || x == 46.0 ) && y == 32.0 ? 1.0 : idx;\n    idx = ( x >= 34.0 && x <= 36.0 ) && y == 33.0 ? 1.0 : idx;\n    idx = ( x >= 43.0 && x <= 45.0 ) && y == 33.0 ? 1.0 : idx;\n    idx = ( x >= 37.0 && x <= 42.0 ) && y == 34.0 ? 1.0 : idx;\n    idx = ( x >= 25.0 && x <= 26.0 ) && ( y >= 8.0  && y <= 11.0 ) ? 1.0 : idx;\n    idx = ( x >= 41.0 && x <= 42.0 ) && ( y >= 24.0 && y <= 27.0 ) ? 1.0 : idx;\n    idx = ( x >= 49.0 && x <= 50.0 ) && ( y >= 8.0  && y <= 11.0 ) ? 1.0 : idx;\n    idx = ( x >= 28.0 && x <= 30.0 ) && ( y >= 11.0 && y <= 14.0 ) ? 1.0 : idx;\n    idx = ( x >= 28.0 && x <= 30.0 ) && ( y >= 11.0 && y <= 14.0 ) ? 1.0 : idx;\n    idx = ( x >= 44.0 && x <= 46.0 ) && ( y >= 27.0 && y <= 30.0 ) ? 1.0 : idx;\n    idx = ( x >= 44.0 && x <= 46.0 ) && ( y >= 27.0 && y <= 30.0 ) ? 1.0 : idx;\n    idx = ( x >= 52.0 && x <= 54.0 ) && ( y >= 11.0 && y <= 14.0 ) ? 1.0 : idx;\n    idx = ( x == 29.0 || x == 53.0 ) && ( y >= 10.0 && y <= 15.0 ) ? 1.0 : idx;\n    idx = x == 45.0 && ( y >= 26.0 && y <= 31.0 ) ? 1.0 : idx;\n    \n\tcolor = idx == 1.0 ? RGB( 0,     0,  0 ) : color;\n\tcolor = idx == 2.0 ? RGB( 0,   173,  0 ) : color;\n}\n\nvoid SpritePipe( inout vec3 color, float x, float y, float h )\n{\n    float offset = h * 16.0;\n\n    // light green\n\tfloat idx = 3.0;\n    \n    // dark green\n    idx = ( ( x > 5.0 && x < 8.0 ) || ( x == 13.0 ) || ( x > 15.0 && x < 23.0 ) ) && y < 17.0 + offset ? 2.0 : idx;\n    idx = ( ( x > 4.0 && x < 7.0 ) || ( x == 12.0 ) || ( x > 14.0 && x < 24.0 ) ) && ( y > 17.0 + offset && y < 30.0 + offset ) ? 2.0 : idx;    \n    idx = ( x < 5.0 || x > 11.0 ) && y == 29.0 + offset ? 2.0 : idx;\n\tidx = fract( x * 0.5 + y * 0.5 ) == 0.5 && x > 22.0 && ( ( x < 26.0 && y < 17.0 + offset ) || ( x < 28.0 && y > 17.0 + offset && y < 30.0 + offset ) ) ? 2.0 : idx;    \n    \n    // black\n    idx = y == 31.0 + offset || x == 0.0 || x == 31.0 || y == 17.0 + offset ? 1.0 : idx;\n    idx = ( x == 2.0 || x == 29.0 ) && y < 18.0 + offset ? 1.0 : idx;\n    idx = ( x > 1.0 && x < 31.0 ) && y == 16.0 + offset ? 1.0 : idx;    \n    \n    // transparent\n    idx = ( x < 2.0 || x > 29.0 ) && y < 17.0 + offset ? 0.0 : idx;\n\n\tcolor = idx == 1.0 ? RGB( 0,     0,  0 ) : color;\n\tcolor = idx == 2.0 ? RGB( 0,   173,  0 ) : color;\n\tcolor = idx == 3.0 ? RGB( 189, 255, 24 ) : color;\n}\n\nvoid SpriteCloud( inout vec3 color, float x, float y, float isBush )\n{\n\tfloat idx = 0.0;\n    \n\tidx = y == 23.0 ? ( x <= 10.0 ? 0.0 : ( x <= 21.0 ? 5440.0 : 0.0 ) ) : idx;\n\tidx = y == 22.0 ? ( x <= 10.0 ? 0.0 : ( x <= 21.0 ? 32720.0 : 0.0 ) ) : idx;\n\tidx = y == 21.0 ? ( x <= 10.0 ? 0.0 : ( x <= 21.0 ? 131061.0 : 0.0 ) ) : idx;\n\tidx = y == 20.0 ? ( x <= 10.0 ? 1048576.0 : ( x <= 21.0 ? 1179647.0 : 0.0 ) ) : idx;\n\tidx = y == 19.0 ? ( x <= 10.0 ? 1048576.0 : ( x <= 21.0 ? 3670015.0 : 1.0 ) ) : idx;\n\tidx = y == 18.0 ? ( x <= 10.0 ? 1048576.0 : ( x <= 21.0 ? 4190207.0 : 7.0 ) ) : idx;\n\tidx = y == 17.0 ? ( x <= 10.0 ? 3407872.0 : ( x <= 21.0 ? 4177839.0 : 7.0 ) ) : idx;\n\tidx = y == 16.0 ? ( x <= 10.0 ? 3997696.0 : ( x <= 21.0 ? 4194299.0 : 7.0 ) ) : idx;\n\tidx = y == 15.0 ? ( x <= 10.0 ? 4150272.0 : ( x <= 21.0 ? 4194303.0 : 1055.0 ) ) : idx;\n\tidx = y == 14.0 ? ( x <= 10.0 ? 4193536.0 : ( x <= 21.0 ? 4194303.0 : 7455.0 ) ) : idx;\n\tidx = y == 13.0 ? ( x <= 10.0 ? 4194112.0 : ( x <= 21.0 ? 4194303.0 : 8063.0 ) ) : idx;\n\tidx = y == 12.0 ? ( x <= 10.0 ? 4194240.0 : ( x <= 21.0 ? 4194303.0 : 73727.0 ) ) : idx;\n\tidx = y == 11.0 ? ( x <= 10.0 ? 4194260.0 : ( x <= 21.0 ? 4194303.0 : 491519.0 ) ) : idx;\n\tidx = y == 10.0 ? ( x <= 10.0 ? 4194301.0 : ( x <= 21.0 ? 4194303.0 : 524287.0 ) ) : idx;\n\tidx = y == 9.0 ? ( x <= 10.0 ? 4194301.0 : ( x <= 21.0 ? 4194303.0 : 524287.0 ) ) : idx;\n\tidx = y == 8.0 ? ( x <= 10.0 ? 4194292.0 : ( x <= 21.0 ? 4194303.0 : 131071.0 ) ) : idx;\n\tidx = y == 7.0 ? ( x <= 10.0 ? 4193232.0 : ( x <= 21.0 ? 4194303.0 : 32767.0 ) ) : idx;\n\tidx = y == 6.0 ? ( x <= 10.0 ? 3927872.0 : ( x <= 21.0 ? 4193279.0 : 131071.0 ) ) : idx;\n\tidx = y == 5.0 ? ( x <= 10.0 ? 2800896.0 : ( x <= 21.0 ? 4193983.0 : 524287.0 ) ) : idx;\n\tidx = y == 4.0 ? ( x <= 10.0 ? 3144960.0 : ( x <= 21.0 ? 3144362.0 : 262143.0 ) ) : idx;\n\tidx = y == 3.0 ? ( x <= 10.0 ? 4150272.0 : ( x <= 21.0 ? 3845099.0 : 98303.0 ) ) : idx;\n\tidx = y == 2.0 ? ( x <= 10.0 ? 3997696.0 : ( x <= 21.0 ? 4107775.0 : 6111.0 ) ) : idx;\n\tidx = y == 1.0 ? ( x <= 10.0 ? 1310720.0 : ( x <= 21.0 ? 4183167.0 : 325.0 ) ) : idx;\n\tidx = y == 0.0 ? ( x <= 10.0 ? 0.0 : ( x <= 21.0 ? 1392661.0 : 0.0 ) ) : idx;\n\n\tidx = SPRITE_DEC2( x, idx );\n\n\tvec3 colorB = isBush == 1.0 ? RGB( 0,   173,  0 ) : RGB(  57, 189, 255 );\n\tvec3 colorC = isBush == 1.0 ? RGB( 189, 255, 24 ) : RGB( 254, 254, 254 );\n\n\tcolor = idx == 1.0 ? RGB( 0, 0, 0 ) : color;\n\tcolor = idx == 2.0 ? colorB \t\t: color;\n\tcolor = idx == 3.0 ? colorC \t\t: color;\n}\n\nvoid SpriteFlag( inout vec3 color, float x, float y )\n{\n\tfloat idx = 0.0;\n\tidx = y == 15.0 ? 43690.0 : idx;\n\tidx = y == 14.0 ? ( x <= 7.0 ? 43688.0 : 42326.0 ) : idx;\n\tidx = y == 13.0 ? ( x <= 7.0 ? 43680.0 : 38501.0 ) : idx;\n\tidx = y == 12.0 ? ( x <= 7.0 ? 43648.0 : 39529.0 ) : idx;\n\tidx = y == 11.0 ? ( x <= 7.0 ? 43520.0 : 39257.0 ) : idx;\n\tidx = y == 10.0 ? ( x <= 7.0 ? 43008.0 : 38293.0 ) : idx;\n\tidx = y == 9.0 ? ( x <= 7.0 ? 40960.0 : 38229.0 ) : idx;\n\tidx = y == 8.0 ? ( x <= 7.0 ? 32768.0 : 43354.0 ) : idx;\n\tidx = y == 7.0 ? ( x <= 7.0 ? 0.0 : 43690.0 ) : idx;\n\tidx = y == 6.0 ? ( x <= 7.0 ? 0.0 : 43688.0 ) : idx;\n\tidx = y == 5.0 ? ( x <= 7.0 ? 0.0 : 43680.0 ) : idx;\n\tidx = y == 4.0 ? ( x <= 7.0 ? 0.0 : 43648.0 ) : idx;\n\tidx = y == 3.0 ? ( x <= 7.0 ? 0.0 : 43520.0 ) : idx;\n\tidx = y == 2.0 ? ( x <= 7.0 ? 0.0 : 43008.0 ) : idx;\n\tidx = y == 1.0 ? ( x <= 7.0 ? 0.0 : 40960.0 ) : idx;\n\tidx = y == 0.0 ? ( x <= 7.0 ? 0.0 : 32768.0 ) : idx;\n\n\tidx = SPRITE_DEC( x, idx );\n\n\tcolor = idx == 1.0 ? RGB(   0, 173,   0 ) : color;\n\tcolor = idx == 2.0 ? RGB( 255, 255, 255 ) : color;\n}\n\nvoid SpriteCastleFlag( inout vec3 color, float x, float y )\n{\n\tfloat idx = 0.0;\n\tidx = y == 13.0 ? ( x <= 10.0 ? 8.0 : 0.0 ) : idx;\n\tidx = y == 12.0 ? ( x <= 10.0 ? 42.0 : 0.0 ) : idx;\n\tidx = y == 11.0 ? ( x <= 10.0 ? 8.0 : 0.0 ) : idx;\n\tidx = y == 10.0 ? ( x <= 10.0 ? 4194292.0 : 15.0 ) : idx;\n\tidx = y == 9.0 ? ( x <= 10.0 ? 4161524.0 : 15.0 ) : idx;\n\tidx = y == 8.0 ? ( x <= 10.0 ? 4161524.0 : 15.0 ) : idx;\n\tidx = y == 7.0 ? ( x <= 10.0 ? 1398260.0 : 15.0 ) : idx;\n\tidx = y == 6.0 ? ( x <= 10.0 ? 3495924.0 : 15.0 ) : idx;\n\tidx = y == 5.0 ? ( x <= 10.0 ? 4022260.0 : 15.0 ) : idx;\n\tidx = y == 4.0 ? ( x <= 10.0 ? 3528692.0 : 15.0 ) : idx;\n\tidx = y == 3.0 ? ( x <= 10.0 ? 3667956.0 : 15.0 ) : idx;\n\tidx = y == 2.0 ? ( x <= 10.0 ? 4194292.0 : 15.0 ) : idx;\n\tidx = y == 1.0 ? ( x <= 10.0 ? 4.0 : 0.0 ) : idx;\n\tidx = y == 0.0 ? ( x <= 10.0 ? 4.0 : 0.0 ) : idx;\n\n\tidx = SPRITE_DEC2( x, idx );\n\n\tcolor = idx == 1.0 ? RGB( 181,  49,  33 ) : color;\n    color = idx == 2.0 ? RGB( 230, 156,  33 ) : color;\n\tcolor = idx == 3.0 ? RGB( 255, 255, 255 ) : color;\n}\n\nvoid SpriteGoomba( inout vec3 color, float x, float y, float frame )\n{\n\tfloat idx = 0.0;\n\n    // second frame is flipped first frame\n    x = frame == 1.0 ? 15.0 - x : x;\n\n    if ( frame <= 1.0 )\n    {\n        idx = y == 15.0 ? ( x <= 7.0 ? 40960.0 : 10.0 ) : idx;\n        idx = y == 14.0 ? ( x <= 7.0 ? 43008.0 : 42.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 43520.0 : 170.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 43648.0 : 682.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 43360.0 : 2410.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 42920.0 : 10970.0 ) : idx;\n        idx = y ==  9.0 ? ( x <= 7.0 ? 22440.0 : 10965.0 ) : idx;\n        idx = y ==  8.0 ? ( x <= 7.0 ? 47018.0 : 43742.0 ) : idx;\n        idx = y ==  7.0 ? ( x <= 7.0 ? 49066.0 : 43774.0 ) : idx;\n        idx = y ==  6.0 ? 43690.0 : idx;\n        idx = y ==  5.0 ? ( x <= 7.0 ? 65192.0 : 10943.0 ) : idx;\n        idx = y ==  4.0 ? ( x <= 7.0 ? 65280.0 : 255.0 ) : idx;\n        idx = y ==  3.0 ? ( x <= 7.0 ? 65280.0 : 1535.0 ) : idx;\n        idx = y ==  2.0 ? ( x <= 7.0 ? 64832.0 : 5471.0 ) : idx;\n        idx = y ==  1.0 ? ( x <= 7.0 ? 62784.0 : 5463.0 ) : idx;\n        idx = y ==  0.0 ? ( x <= 7.0 ? 5376.0 : 1364.0 ) : idx;\n    }\n    else\n    {\n        idx = y == 7.0 ? ( x <= 7.0 ? 40960.0 : 10.0 ) : idx;\n\t\tidx = y == 6.0 ? ( x <= 7.0 ? 43648.0 : 682.0 ) : idx;\n\t\tidx = y == 5.0 ? ( x <= 7.0 ? 42344.0 : 10586.0 ) : idx;\n\t\tidx = y == 4.0 ? ( x <= 7.0 ? 24570.0 : 45045.0 ) : idx;\n\t\tidx = y == 3.0 ? 43690.0 : idx;\n\t\tidx = y == 2.0 ? ( x <= 7.0 ? 65472.0 : 1023.0 ) : idx;\n\t\tidx = y == 1.0 ? ( x <= 7.0 ? 65280.0 : 255.0 ) : idx;\n\t\tidx = y == 0.0 ? ( x <= 7.0 ? 1364.0 : 5456.0 ) : idx; \n    }\n    \n    idx = SPRITE_DEC( x, idx );\n    \n\tcolor = idx == 1.0 ? RGB( 0,     0,   0 ) : color;\n\tcolor = idx == 2.0 ? RGB( 153,  75,  12 ) : color;\n\tcolor = idx == 3.0 ? RGB( 255, 200, 184 ) : color;\n}\n\nvoid SpriteKoopa( inout vec3 color, float x, float y, float frame )\n{    \n\tfloat idx = 0.0;\n\n\tif ( frame == 0.0 )\n    {\n\t\tidx = y == 23.0 ? ( x <= 7.0 ? 768.0 : 0.0 ) : idx;\n\t\tidx = y == 22.0 ? ( x <= 7.0 ? 4032.0 : 0.0 ) : idx;\n\t\tidx = y == 21.0 ? ( x <= 7.0 ? 4064.0 : 0.0 ) : idx;\n\t\tidx = y == 20.0 ? ( x <= 7.0 ? 12128.0 : 0.0 ) : idx;\n\t\tidx = y == 19.0 ? ( x <= 7.0 ? 12136.0 : 0.0 ) : idx;\n        idx = y == 18.0 ? ( x <= 7.0 ? 12136.0 : 0.0 ) : idx;\n        idx = y == 17.0 ? ( x <= 7.0 ? 12264.0 : 0.0 ) : idx;\n\t\tidx = y == 16.0 ? ( x <= 7.0 ? 11174.0 : 0.0 ) : idx;\n\t\tidx = y == 15.0 ? ( x <= 7.0 ? 10922.0 : 0.0 ) : idx;\n\t\tidx = y == 14.0 ? ( x <= 7.0 ? 10282.0 : 341.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 30730.0 : 1622.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 31232.0 : 1433.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 24192.0 : 8037.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 24232.0 : 7577.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 28320.0 : 9814.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 40832.0 : 6485.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 26496.0 : 9814.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 23424.0 : 5529.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 22272.0 : 5477.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 24320.0 : 64921.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 65024.0 : 12246.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 59904.0 : 11007.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 43008.0 : 10752.0 ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 40960.0 : 2690.0 ) : idx;\n    }\n\telse\n\t{\n        idx = y == 22.0 ? ( x <= 7.0 ? 192.0 : 0.0 ) : idx;\n        idx = y == 21.0 ? ( x <= 7.0 ? 1008.0 : 0.0 ) : idx;\n        idx = y == 20.0 ? ( x <= 7.0 ? 3056.0 : 0.0 ) : idx;\n        idx = y == 19.0 ? ( x <= 7.0 ? 11224.0 : 0.0 ) : idx;\n        idx = y == 18.0 ? ( x <= 7.0 ? 11224.0 : 0.0 ) : idx;\n        idx = y == 17.0 ? ( x <= 7.0 ? 11224.0 : 0.0 ) : idx;\n        idx = y == 16.0 ? ( x <= 7.0 ? 11256.0 : 0.0 ) : idx;\n        idx = y == 15.0 ? ( x <= 7.0 ? 10986.0 : 0.0 ) : idx;\n        idx = y == 14.0 ? ( x <= 7.0 ? 10918.0 : 0.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 2730.0 : 341.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 18986.0 : 1622.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 18954.0 : 5529.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 24202.0 : 8037.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 24200.0 : 7577.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 28288.0 : 9814.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 40864.0 : 6485.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 26496.0 : 9814.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 23424.0 : 5529.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 22272.0 : 5477.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 24320.0 : 64921.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 65152.0 : 4054.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 60064.0 : 11007.0 ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 2728.0 : 43520.0 ) : idx;\n\t}\n\n\tidx = SPRITE_DEC( x, idx );\n\n\tcolor = idx == 1.0 ? RGB( 30,  132,   0 ) : color;\n\tcolor = idx == 2.0 ? RGB( 215, 141,  34 ) : color;\n\tcolor = idx == 3.0 ? RGB( 255, 255, 255 ) : color;    \n}\n\nvoid SpriteQuestion( inout vec3 color, float x, float y, float t )\n{\n\tfloat idx = 0.0;\n\tidx = y == 15.0 ? ( x <= 7.0 ? 43688.0 : 10922.0 ) : idx;\n\tidx = y == 14.0 ? ( x <= 7.0 ? 65534.0 : 32767.0 ) : idx;\n\tidx = y == 13.0 ? ( x <= 7.0 ? 65502.0 : 30719.0 ) : idx;\n\tidx = y == 12.0 ? ( x <= 7.0 ? 44030.0 : 32762.0 ) : idx;\n\tidx = y == 11.0 ? ( x <= 7.0 ? 23294.0 : 32745.0 ) : idx;\n\tidx = y == 10.0 ? ( x <= 7.0 ? 56062.0 : 32619.0 ) : idx;\n\tidx = y == 9.0 ? ( x <= 7.0 ? 56062.0 : 32619.0 ) : idx;\n\tidx = y == 8.0 ? ( x <= 7.0 ? 55294.0 : 32618.0 ) : idx;\n\tidx = y == 7.0 ? ( x <= 7.0 ? 49150.0 : 32598.0 ) : idx;\n\tidx = y == 6.0 ? ( x <= 7.0 ? 49150.0 : 32758.0 ) : idx;\n\tidx = y == 5.0 ? ( x <= 7.0 ? 65534.0 : 32757.0 ) : idx;\n\tidx = y == 4.0 ? ( x <= 7.0 ? 49150.0 : 32766.0 ) : idx;\n\tidx = y == 3.0 ? ( x <= 7.0 ? 49150.0 : 32758.0 ) : idx;\n\tidx = y == 2.0 ? ( x <= 7.0 ? 65502.0 : 30709.0 ) : idx;\n\tidx = y == 1.0 ? ( x <= 7.0 ? 65534.0 : 32767.0 ) : idx;\n\tidx = y == 0.0 ? 21845.0 : idx;\n\n\tidx = SPRITE_DEC( x, idx );\n\n\tcolor = idx == 1.0 ? RGB( 0,     0,   0 ) : color;\n\tcolor = idx == 2.0 ? RGB( 231,  90,  16 ) : color;\n\tcolor = idx == 3.0 ? mix( RGB( 255,  165, 66 ), RGB( 231,  90,  16 ), t ) : color;\n}\n\nvoid SpriteMushroom( inout vec3 color, float x, float y )\n{\n\tfloat idx = 0.0;\n\tidx = y == 15.0 ? ( x <= 7.0 ? 40960.0 : 10.0 ) : idx;\n\tidx = y == 14.0 ? ( x <= 7.0 ? 43008.0 : 22.0 ) : idx;\n\tidx = y == 13.0 ? ( x <= 7.0 ? 43520.0 : 85.0 ) : idx;\n\tidx = y == 12.0 ? ( x <= 7.0 ? 43648.0 : 341.0 ) : idx;\n\tidx = y == 11.0 ? ( x <= 7.0 ? 43680.0 : 2646.0 ) : idx;\n\tidx = y == 10.0 ? ( x <= 7.0 ? 42344.0 : 10922.0 ) : idx;\n\tidx = y == 9.0 ? ( x <= 7.0 ? 38232.0 : 10922.0 ) : idx;\n\tidx = y == 8.0 ? ( x <= 7.0 ? 38234.0 : 42410.0 ) : idx;\n\tidx = y == 7.0 ? ( x <= 7.0 ? 38234.0 : 38314.0 ) : idx;\n\tidx = y == 6.0 ? ( x <= 7.0 ? 42346.0 : 38570.0 ) : idx;\n\tidx = y == 5.0 ? 43690.0 : idx;\n\tidx = y == 4.0 ? ( x <= 7.0 ? 64856.0 : 9599.0 ) : idx;\n\tidx = y == 3.0 ? ( x <= 7.0 ? 65280.0 : 255.0 ) : idx;\n\tidx = y == 2.0 ? ( x <= 7.0 ? 65280.0 : 239.0 ) : idx;\n\tidx = y == 1.0 ? ( x <= 7.0 ? 65280.0 : 239.0 ) : idx;\n\tidx = y == 0.0 ? ( x <= 7.0 ? 64512.0 : 59.0 ) : idx;\n\n\tidx = SPRITE_DEC( x, idx );\n\n\tcolor = idx == 1.0 ? RGB( 181, 49,   33 ) : color;\n\tcolor = idx == 2.0 ? RGB( 230, 156,  33 ) : color;\n\tcolor = idx == 3.0 ? RGB( 255, 255, 255 ) : color;\n}\n\nvoid SpriteGround( inout vec3 color, float x, float y )\n{   \n\tfloat idx = 0.0;\n\tidx = y == 15.0 ? ( x <= 7.0 ? 65534.0 : 49127.0 ) : idx;\n\tidx = y == 14.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\n\tidx = y == 13.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\n\tidx = y == 12.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\n\tidx = y == 11.0 ? ( x <= 7.0 ? 43691.0 : 27254.0 ) : idx;\n\tidx = y == 10.0 ? ( x <= 7.0 ? 43691.0 : 38246.0 ) : idx;\n\tidx = y == 9.0 ? ( x <= 7.0 ? 43691.0 : 32758.0 ) : idx;\n\tidx = y == 8.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\n\tidx = y == 7.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\n\tidx = y == 6.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\n\tidx = y == 5.0 ? ( x <= 7.0 ? 43685.0 : 27309.0 ) : idx;\n\tidx = y == 4.0 ? ( x <= 7.0 ? 43615.0 : 27309.0 ) : idx;\n\tidx = y == 3.0 ? ( x <= 7.0 ? 22011.0 : 27307.0 ) : idx;\n\tidx = y == 2.0 ? ( x <= 7.0 ? 32683.0 : 27307.0 ) : idx;\n\tidx = y == 1.0 ? ( x <= 7.0 ? 27307.0 : 23211.0 ) : idx;\n\tidx = y == 0.0 ? ( x <= 7.0 ? 38230.0 : 38231.0 ) : idx;\n\n\tidx = SPRITE_DEC( x, idx );\n\n\tcolor = RGB( 0, 0, 0 );\n\tcolor = idx == 2.0 ? RGB( 231,  90,  16 ) : color;\n\tcolor = idx == 3.0 ? RGB( 247, 214, 181 ) : color;\n}\n\nvoid SpriteFlagpoleEnd( inout vec3 color, float x, float y )\n{   \n\tfloat idx = 0.0;\n\n\tidx = y == 7.0 ? 1360.0  : idx;\n\tidx = y == 6.0 ? 6836.0  : idx;\n\tidx = y == 5.0 ? 27309.0 : idx;\n\tidx = y == 4.0 ? 27309.0 : idx;\n\tidx = y == 3.0 ? 27305.0 : idx;\n\tidx = y == 2.0 ? 27305.0 : idx;\n\tidx = y == 1.0 ? 6820.0  : idx;\n\tidx = y == 0.0 ? 1360.0  : idx;\n\n\tidx = SPRITE_DEC( x, idx );\n\n\tcolor = idx == 1.0 ? RGB( 0,     0,  0 ) : color;\n\tcolor = idx == 2.0 ? RGB( 0,   173,  0 ) : color;\n\tcolor = idx == 3.0 ? RGB( 189, 255, 24 ) : color;\n}\n\nvoid SpriteMario( inout vec3 color, float x, float y, float frame )\n{    \n    float idx = 0.0;\n\n\tif ( frame == 0.0 )\n    {\n        idx = y == 14.0 ? ( x <= 7.0 ? 40960.0 : 42.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 43008.0 : 2730.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 21504.0 : 223.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 56576.0 : 4063.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 23808.0 : 16255.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 62720.0 : 1375.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 61440.0 : 1023.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 21504.0 : 793.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 22272.0 : 4053.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 23488.0 : 981.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 43328.0 : 170.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 43584.0 : 170.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 10832.0 : 42.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 16400.0 : 5.0 ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 16384.0 : 21.0 ) : idx;\n\t}\n    else if ( frame == 1.0 ) \n    {\n        idx = y == 15.0 ? ( x <= 7.0 ? 43008.0 : 10.0 ) : idx;\n        idx = y == 14.0 ? ( x <= 7.0 ? 43520.0 : 682.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 54528.0 : 55.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 63296.0 : 1015.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 55104.0 : 4063.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 64832.0 : 343.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 64512.0 : 255.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 25856.0 : 5.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 38208.0 : 22.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 42304.0 : 235.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 38208.0 : 170.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 62848.0 : 171.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 62976.0 : 42.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 43008.0 : 21.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 21504.0 : 85.0 ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 21504.0 : 1.0 ) : idx;\n    }\n    else if ( frame == 2.0 ) \n    {\n        idx = y == 15.0 ? ( x <= 7.0 ? 43008.0 : 10.0 ) : idx;\n        idx = y == 14.0 ? ( x <= 7.0 ? 43520.0 : 682.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 54528.0 : 55.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 63296.0 : 1015.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 55104.0 : 4063.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 64832.0 : 343.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 64512.0 : 255.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 42320.0 : 5.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 42335.0 : 16214.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 58687.0 : 15722.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 43535.0 : 1066.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 43648.0 : 1450.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 43680.0 : 1450.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 2708.0 : 1448.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 84.0 : 0.0 ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 336.0 : 0.0 ) : idx;\n    }\n    else if ( frame == 3.0 )\n    {\n        idx = y == 15.0 ? ( x <= 7.0 ? 0.0 : 64512.0 ) : idx;\n        idx = y == 14.0 ? ( x <= 7.0 ? 40960.0 : 64554.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 43008.0 : 64170.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 21504.0 : 21727.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 56576.0 : 22495.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 23808.0 : 32639.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 62720.0 : 5471.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 61440.0 : 2047.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 38224.0 : 405.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 21844.0 : 16982.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 21855.0 : 17066.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 39487.0 : 23470.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 43596.0 : 23210.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 43344.0 : 23210.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 43604.0 : 42.0 ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 43524.0 : 0.0 ) : idx;\n    }\n    else if ( frame == 4.0 )\n    {\n        idx = y == 29.0 ? ( x <= 7.0 ? 32768.0 : 170.0 ) : idx;\n        idx = y == 28.0 ? ( x <= 7.0 ? 43008.0 : 234.0 ) : idx;\n        idx = y == 27.0 ? ( x <= 7.0 ? 43520.0 : 250.0 ) : idx;\n        idx = y == 26.0 ? ( x <= 7.0 ? 43520.0 : 10922.0 ) : idx;\n        idx = y == 25.0 ? ( x <= 7.0 ? 54528.0 : 1015.0 ) : idx;\n        idx = y == 24.0 ? ( x <= 7.0 ? 57152.0 : 16343.0 ) : idx;\n        idx = y == 23.0 ? ( x <= 7.0 ? 24384.0 : 65535.0 ) : idx;\n        idx = y == 22.0 ? ( x <= 7.0 ? 24400.0 : 65407.0 ) : idx;\n        idx = y == 21.0 ? ( x <= 7.0 ? 65360.0 : 5463.0 ) : idx;\n        idx = y == 20.0 ? ( x <= 7.0 ? 64832.0 : 5471.0 ) : idx;\n        idx = y == 19.0 ? ( x <= 7.0 ? 62464.0 : 4095.0 ) : idx;\n        idx = y == 18.0 ? ( x <= 7.0 ? 43264.0 : 63.0 ) : idx;\n        idx = y == 17.0 ? ( x <= 7.0 ? 22080.0 : 6.0 ) : idx;\n        idx = y == 16.0 ? ( x <= 7.0 ? 22080.0 : 25.0 ) : idx;\n        idx = y == 15.0 ? ( x <= 7.0 ? 22096.0 : 4005.0 ) : idx;\n        idx = y == 14.0 ? ( x <= 7.0 ? 22160.0 : 65365.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 23184.0 : 65365.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 23168.0 : 64853.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 27264.0 : 64853.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 43648.0 : 598.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 43648.0 : 682.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 43648.0 : 426.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 43605.0 : 2666.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 43605.0 : 2710.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 43605.0 : 681.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 10837.0 : 680.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 85.0 : 340.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 5.0 : 340.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 1.0 : 5460.0 ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 0.0 : 5460.0 ) : idx;\n    }\n    else if ( frame == 5.0 )\n    {\n        idx = y == 30.0 ? ( x <= 7.0 ? 40960.0 : 42.0 ) : idx;\n        idx = y == 29.0 ? ( x <= 7.0 ? 43520.0 : 58.0 ) : idx;\n        idx = y == 28.0 ? ( x <= 7.0 ? 43648.0 : 62.0 ) : idx;\n        idx = y == 27.0 ? ( x <= 7.0 ? 43648.0 : 2730.0 ) : idx;\n        idx = y == 26.0 ? ( x <= 7.0 ? 62784.0 : 253.0 ) : idx;\n        idx = y == 25.0 ? ( x <= 7.0 ? 63440.0 : 4085.0 ) : idx;\n        idx = y == 24.0 ? ( x <= 7.0 ? 55248.0 : 16383.0 ) : idx;\n        idx = y == 23.0 ? ( x <= 7.0 ? 55252.0 : 16351.0 ) : idx;\n        idx = y == 22.0 ? ( x <= 7.0 ? 65492.0 : 1365.0 ) : idx;\n        idx = y == 21.0 ? ( x <= 7.0 ? 65360.0 : 1367.0 ) : idx;\n        idx = y == 20.0 ? ( x <= 7.0 ? 64832.0 : 1023.0 ) : idx;\n        idx = y == 19.0 ? ( x <= 7.0 ? 43520.0 : 15.0 ) : idx;\n        idx = y == 18.0 ? ( x <= 7.0 ? 38464.0 : 22.0 ) : idx;\n        idx = y == 17.0 ? ( x <= 7.0 ? 21904.0 : 26.0 ) : idx;\n        idx = y == 16.0 ? ( x <= 7.0 ? 21904.0 : 90.0 ) : idx;\n        idx = y == 15.0 ? ( x <= 7.0 ? 21904.0 : 106.0 ) : idx;\n        idx = y == 14.0 ? ( x <= 7.0 ? 21904.0 : 125.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 21904.0 : 255.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 21920.0 : 767.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 22176.0 : 2815.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 23200.0 : 2751.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 43680.0 : 2725.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 43648.0 : 661.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 27136.0 : 341.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 23040.0 : 85.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 26624.0 : 21.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 41984.0 : 86.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 21504.0 : 81.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 21760.0 : 1.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 21760.0 : 21.0 ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 20480.0 : 21.0 ) : idx;\n    }\n    else if ( frame == 6.0 )\n    {\n        idx = y == 31.0 ? ( x <= 7.0 ? 40960.0 : 42.0 ) : idx;\n        idx = y == 30.0 ? ( x <= 7.0 ? 43520.0 : 58.0 ) : idx;\n        idx = y == 29.0 ? ( x <= 7.0 ? 43648.0 : 62.0 ) : idx;\n        idx = y == 28.0 ? ( x <= 7.0 ? 43648.0 : 2730.0 ) : idx;\n        idx = y == 27.0 ? ( x <= 7.0 ? 62784.0 : 253.0 ) : idx;\n        idx = y == 26.0 ? ( x <= 7.0 ? 63440.0 : 4085.0 ) : idx;\n        idx = y == 25.0 ? ( x <= 7.0 ? 55248.0 : 16383.0 ) : idx;\n        idx = y == 24.0 ? ( x <= 7.0 ? 55252.0 : 16351.0 ) : idx;\n        idx = y == 23.0 ? ( x <= 7.0 ? 65492.0 : 1365.0 ) : idx;\n        idx = y == 22.0 ? ( x <= 7.0 ? 65364.0 : 1367.0 ) : idx;\n        idx = y == 21.0 ? ( x <= 7.0 ? 64832.0 : 1023.0 ) : idx;\n        idx = y == 20.0 ? ( x <= 7.0 ? 21504.0 : 15.0 ) : idx;\n        idx = y == 19.0 ? ( x <= 7.0 ? 43520.0 : 12325.0 ) : idx;\n        idx = y == 18.0 ? ( x <= 7.0 ? 38208.0 : 64662.0 ) : idx;\n        idx = y == 17.0 ? ( x <= 7.0 ? 21840.0 : 64922.0 ) : idx;\n        idx = y == 16.0 ? ( x <= 7.0 ? 21844.0 : 65114.0 ) : idx;\n        idx = y == 15.0 ? ( x <= 7.0 ? 21844.0 : 30298.0 ) : idx;\n        idx = y == 14.0 ? ( x <= 7.0 ? 38228.0 : 5722.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 42325.0 : 1902.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 43605.0 : 682.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 44031.0 : 682.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 44031.0 : 17066.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 43775.0 : 21162.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 43772.0 : 21866.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 43392.0 : 21866.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 42640.0 : 21866.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 23189.0 : 21866.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 43605.0 : 21824.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 2389.0 : 0.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 84.0 : 0.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 84.0 : 0.0 ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 336.0 : 0.0 ) : idx;\n    }\n    else\n    {\n        idx = y == 31.0 ? ( x <= 7.0 ? 0.0 : 16128.0 ) : idx;\n        idx = y == 30.0 ? ( x <= 7.0 ? 0.0 : 63424.0 ) : idx;\n        idx = y == 29.0 ? ( x <= 7.0 ? 40960.0 : 55274.0 ) : idx;\n        idx = y == 28.0 ? ( x <= 7.0 ? 43520.0 : 65514.0 ) : idx;\n        idx = y == 27.0 ? ( x <= 7.0 ? 43648.0 : 21866.0 ) : idx;\n        idx = y == 26.0 ? ( x <= 7.0 ? 43648.0 : 23210.0 ) : idx;\n        idx = y == 25.0 ? ( x <= 7.0 ? 62784.0 : 22013.0 ) : idx;\n        idx = y == 24.0 ? ( x <= 7.0 ? 63440.0 : 24573.0 ) : idx;\n        idx = y == 23.0 ? ( x <= 7.0 ? 55248.0 : 32767.0 ) : idx;\n        idx = y == 22.0 ? ( x <= 7.0 ? 55248.0 : 32735.0 ) : idx;\n        idx = y == 21.0 ? ( x <= 7.0 ? 65492.0 : 5461.0 ) : idx;\n        idx = y == 20.0 ? ( x <= 7.0 ? 64852.0 : 7511.0 ) : idx;\n        idx = y == 19.0 ? ( x <= 7.0 ? 64832.0 : 6143.0 ) : idx;\n        idx = y == 18.0 ? ( x <= 7.0 ? 43520.0 : 5477.0 ) : idx;\n        idx = y == 17.0 ? ( x <= 7.0 ? 38228.0 : 1382.0 ) : idx;\n        idx = y == 16.0 ? ( x <= 7.0 ? 21845.0 : 1430.0 ) : idx;\n        idx = y == 15.0 ? ( x <= 7.0 ? 21845.0 : 410.0 ) : idx;\n        idx = y == 14.0 ? ( x <= 7.0 ? 22005.0 : 602.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 38909.0 : 874.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 43007.0 : 686.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 44031.0 : 682.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 43763.0 : 17066.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 43708.0 : 21162.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 43648.0 : 21930.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 43584.0 : 21930.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 42389.0 : 21930.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 23189.0 : 21930.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 43669.0 : 21920.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 43669.0 : 0.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 10901.0 : 0.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 5.0 : 0.0 ) : idx;\n    }\n    \n    idx = SPRITE_DEC( x, idx );\n    \n\tcolor = idx == 1.0 ? RGB( 106, 107,  4 ) : color;\n\tcolor = idx == 2.0 ? RGB( 177,  52, 37 ) : color;\n\tcolor = idx == 3.0 ? RGB( 227, 157, 37 ) : color;    \n}\n\nvoid SpriteCoin( inout vec3 color, float x, float y, float frame )\n{    \n    float idx = 0.0;\n\tif ( frame == 0.0 )\n    {\n        idx = y == 14.0 ? ( x <= 7.0 ? 32768.0 : 1.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 32768.0 : 1.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 28672.0 : 5.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 28672.0 : 5.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 32768.0 : 1.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 32768.0 : 1.0 ) : idx;\n\t}\n    else if ( frame == 1.0 ) \n    {\n        idx = y == 14.0 ? ( x <= 7.0 ? 32768.0 : 2.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 40960.0 : 10.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 43008.0 : 42.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 59392.0 : 41.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 59392.0 : 41.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 43008.0 : 42.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 40960.0 : 10.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 32768.0 : 2.0 ) : idx;;\n    }\n    else if ( frame == 2.0 ) \n    {\n        idx = y == 14.0 ? ( x <= 7.0 ? 49152.0 : 1.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 49152.0 : 1.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 49152.0 : 1.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 49152.0 : 1.0 ) : idx;\n    }\n    else\n    {\n        idx = y == 14.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 0.0 : 3.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 0.0 : 3.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\n    }\n    \n\tidx = SPRITE_DEC( x, idx );\n\n\tcolor = idx == 1.0 ? RGB( 181, 49,   33 ) : color;\n\tcolor = idx == 2.0 ? RGB( 230, 156,  33 ) : color;\n\tcolor = idx == 3.0 ? RGB( 255, 255, 255 ) : color;    \n}\n\nvoid SpriteBrick( inout vec3 color, float x, float y )\n{    \n\tfloat ymod4 = floor( mod( y, 4.0 ) );    \n    float xmod8 = floor( mod( x, 8.0 ) );\n    float ymod8 = floor( mod( y, 8.0 ) );\n    \n    // dark orange\n    float idx = 2.0;\n   \n    // black\n    idx = ymod4 == 0.0 ? 1.0 : idx;\n    idx = xmod8 == ( ymod8 < 4.0 ? 3.0 : 7.0 ) ? 1.0 : idx;\n\n    // light orange\n    idx = y == 15.0 ? 3.0 : idx;\n\n    color = idx == 1.0 ? RGB( 0,     0,   0 ) : color;\n\tcolor = idx == 2.0 ? RGB( 231,  90,  16 ) : color;\n\tcolor = idx == 3.0 ? RGB( 247, 214, 181 ) : color;\n}\n\nvoid DrawCastle( inout vec3 color, float x, float y )\n{\n\tif ( x >= 0.0 && x < 80.0 && y >= 0.0 && y < 80.0 )\n\t{\n\t\tfloat ymod4    = mod( y, 4.0 );\n\t\tfloat xmod8    = mod( x, 8.0 );\n\t\tfloat xmod16_4 = mod( x + 4.0, 16.0 );\n\t\tfloat xmod16_3 = mod( x + 5.0, 16.0 );\n\t\tfloat ymod8    = mod( y, 8.0 );\n\n\t\t// dark orange\n\t\tfloat idx = 2.0;\n\n\t\t// black\n\t\tidx = ymod4 == 0.0 && y <= 72.0 && ( y != 44.0 || xmod16_3 > 8.0 ) ? 1.0 : idx;\n\t\tidx = x >= 24.0 && x <= 32.0 && y >= 48.0 && y <= 64.0 ? 1.0 : idx;\n\t\tidx = x >= 48.0 && x <= 56.0 && y >= 48.0 && y <= 64.0 ? 1.0 : idx;\n\t\tidx = x >= 32.0 && x <= 47.0 && y <= 25.0 ? 1.0 : idx;\n\t\tidx = xmod8 == ( ymod8 < 4.0 ? 3.0 : 7.0 ) && y <= 72.0 && ( xmod16_3 > 8.0 || y <= 40.0 || y >= 48.0 ) ? 1.0 : idx;  \n\n\t\t// white\n\t\tidx = y == ( xmod16_4 < 8.0 ? 47.0 : 40.0 ) ? 3.0 : idx;\n\t\tidx = y == ( xmod16_4 < 8.0 ? 79.0 : 72.0 ) ? 3.0 : idx;\n\t\tidx = xmod8 == 3.0 && y >= 40.0 && y <= 47.0 ? 3.0 : idx;\n\t\tidx = xmod8 == 3.0 && y >= 72.0 ? 3.0 : idx;\n\n\t\t// transparent\n\t\tidx = ( x < 16.0 || x >= 64.0 ) && y >= 48.0 ? 0.0 : idx;\n\t\tidx = x >= 4.0  && x <= 10.0 && y >= 41.0 && y <= 47.0 ? 0.0 : idx;\n\t\tidx = x >= 68.0 && x <= 74.0 && y >= 41.0 && y <= 47.0 ? 0.0 : idx;             \n\t\tidx = y >= 73.0 && xmod16_3 > 8.0 ? 0.0 : idx;\n\n\t\tcolor = idx == 1.0 ? RGB(   0,   0,   0 ) : color;\n\t\tcolor = idx == 2.0 ? RGB( 231,  90,  16 ) : color;\n\t\tcolor = idx == 3.0 ? RGB( 247, 214, 181 ) : color;\n\t}\n}\n\nvoid DrawKoopa( inout vec3 color, float x, float y, float frame )\n{\n    if ( x >= 0.0 && x <= 15.0 )\n    {\n        SpriteKoopa( color, x, y, frame );\n    }\n}\n\nvoid KoopaWalk( inout vec3 color, float worldX, float worldY, float time, float frame, float startX )\n{\n    float x = worldX - startX + floor( time * GOOMBA_SPEED );\n    DrawKoopa( color, x, worldY - 16.0, frame );    \n}\n\nvoid DrawHitQuestion( inout vec3 color, float questionX, float questionY, float time, float questionT, float questionHitTime )\n{\n\tfloat t = clamp( ( time - questionHitTime ) / 0.25, 0.0, 1.0 );\n    t = 1.0 - abs( 2.0 * t - 1.0 );\n\n    questionY -= floor( t * 8.0 );\n    if ( questionX >= 0.0 && questionX <= 15.0 )\n    {            \n    \tif ( time >= questionHitTime )\n        {                \n        \tSpriteQuestion( color, questionX, questionY, 1.0 );\n            if ( questionX >= 3.0 && questionX <= 12.0 && questionY >= 1.0 && questionY <= 15.0 )\n            {\n                color = RGB( 231, 90, 16 );\n            }\n        }\n        else\n        {\n         \tSpriteQuestion( color, questionX, questionY, questionT );\n        }\n    }\n}\n\nvoid DrawW( inout vec3 color, float x, float y )\n{\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\n    {\n        if (    ( x <= 3.0 || x >= 10.0 ) \n             || ( x >= 4.0 && x <= 5.0 && y >= 2.0 && y <= 7.0 )\n             || ( x >= 8.0 && x <= 9.0 && y >= 2.0 && y <= 7.0 )\n             || ( x >= 6.0 && x <= 7.0 && y >= 4.0 && y <= 9.0 )\n           )\n        {\n            color = RGB( 255, 255, 255 );\n        }\n    }\n}\n\nvoid DrawO( inout vec3 color, float x, float y )\n{\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\n    {\n        if (    ( x <= 1.0 || x >= 12.0 ) && ( y >= 2.0 && y <= 11.0 )\n             || ( x >= 2.0 && x <= 4.0 )\n             || ( x >= 9.0 && x <= 11.0 )\n             || ( y <= 1.0 || y >= 11.0 ) && ( x >= 2.0 && x <= 11.0 )\n           )\n        {\n            color = RGB( 255, 255, 255 );\n        }\n    }\n}\n\nvoid DrawR( inout vec3 color, float x, float y )\n{\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\n    {\n        if (    ( x <= 3.0 )\n\t\t\t || ( y >= 12.0 && x <= 11.0 )\n             || ( x >= 10.0 && y >= 6.0 && y <= 11.0 )\n             || ( x >= 8.0  && x <= 9.0 && y <= 7.0 )\n             || ( x <= 9.0  && y >= 4.0 && y <= 5.0 )\n             || ( x >= 8.0  && y <= 1.0 )\n             || ( x >= 6.0  && x <= 11.0 && y >= 2.0 && y <= 3.0 )\n           )\n        {\n            color = RGB( 255, 255, 255 );\n        }\n    }\n}\n\nvoid DrawL( inout vec3 color, float x, float y )\n{\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\n    {\n        if ( x <= 3.0 || y <= 1.0 )\n        {\n            color = RGB( 255, 255, 255 );\n        }\n    }\n}\n\nvoid DrawD( inout vec3 color, float x, float y )\n{    \n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\n    {\n    \tcolor = RGB( 255, 255, 255 );        \n        \n        if (    ( x >= 4.0 && x <= 7.0 && y >= 2.0 && y <= 11.0 ) \n           \t || ( x >= 8.0 && x <= 9.0 && y >= 4.0 && y <= 9.0 ) \n             || ( x >= 12.0 && ( y <= 3.0 || y >= 10.0 ) )\n             || ( x >= 10.0 && ( y <= 1.0 || y >= 12.0 ) )\n           )\n        {\n            color = RGB( 0, 0, 0 );\n        }\n    }\n}\n\nvoid Draw1( inout vec3 color, float x, float y )\n{    \n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\n    {\n        if (    ( y <= 1.0 )\n             || ( x >= 5.0 && x <= 8.0 )\n             || ( x >= 3.0 && x <= 4.0 && y >= 10.0 && y <= 11.0 )\n           )\n        {\n            color = RGB( 255, 255, 255 );\n        }\n    }\n}\n\nvoid DrawM( inout vec3 color, float x, float y )\n{    \n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\n    {\n        if ( y >= 4.0 && y <= 7.0 )\n        {\n            color = RGB( 255, 255, 255 );\n        }\n    }\n}\n\nvoid DrawIntro( inout vec3 color, float x, float y, float screenWidth, float screenHeight )\n{\n    color = RGB( 0, 0, 0 );\n        \n    float offset \t= 18.0;     \n    float textX \t= floor( x - ( screenWidth - offset * 8.0 - 7.0 ) / 2.0 );\n    float textY \t= floor( y - ( screenHeight - 7.0 ) / 2.0 - 16.0 * 2.0 );\n    float marioX\t= textX - offset * 4.0;\n    float marioY\t= textY + 16.0 * 3.0;\n\t\n    DrawW( color, textX - offset * 0.0, textY );\n    DrawO( color, textX - offset * 1.0, textY );\n    DrawR( color, textX - offset * 2.0, textY );\n    DrawL( color, textX - offset * 3.0, textY );\n    DrawD( color, textX - offset * 4.0, textY );\n    Draw1( color, textX - offset * 6.0, textY );\n    DrawM( color, textX - offset * 7.0, textY );\n    Draw1( color, textX - offset * 8.0, textY );\n    \n    if ( marioX >= 0.0 && marioX <= 15.0 )\n    {\n    \tSpriteMario( color, marioX, marioY, 4.0 );\n    }\n}\n\nfloat CoinAnimY( float worldY, float time, float coinTime )\n{\n\treturn worldY - 4.0 * 16.0 - floor( 64.0 * ( 1.0 - abs( 2.0 * ( clamp( ( time - coinTime ) / 0.8, 0.0, 1.0 ) ) - 1.0 ) ) );\n}\n\nfloat QuestionAnimY( float worldY, float time, float questionHitTime )\n{\n     return worldY - 4.0 * 16.0 - floor( 8.0 * ( 1.0 - abs( 2.0 * clamp( ( time - questionHitTime ) / 0.25, 0.0, 1.0 ) - 1.0 ) ) );\n}\n\nfloat GoombaSWalkX( float worldX, float startX, float time, float goombaLifeTime )\n{\n    return worldX + floor( min( time, goombaLifeTime ) * GOOMBA_SPEED ) - startX;\n}\n\nvoid DrawGame( inout vec3 color, float time, float pixelX, float pixelY, float screenWidth, float screenHeight )\n{\n    float mushroomPauseStart \t= 16.25;    \n    float mushroomPauseLength \t= 2.0;    \n    float flagPauseStart\t\t= 38.95;\n    float flagPauseLength\t\t= 1.5;\n\n    float cameraP1\t\t= clamp( time - mushroomPauseStart, 0.0, mushroomPauseLength );\n    float cameraP2\t\t= clamp( time - flagPauseStart,     0.0, flagPauseLength );\n    float cameraX \t\t= floor( min( ( time - cameraP1 - cameraP2 ) * MARIO_SPEED - 240.0, 3152.0 ) );\n    float worldX \t\t= pixelX + cameraX;\n    float worldY  \t\t= pixelY - 8.0;\n    float tileX\t\t\t= floor( worldX / 16.0 );\n    float tileY\t\t\t= floor( worldY / 16.0 );\n    float tile2X\t\t= floor( worldX / 32.0 );\n    float tile2Y\t\t= floor( worldY / 32.0 );    \n    float worldXMod16\t= mod( worldX, 16.0 );\n    float worldYMod16 \t= mod( worldY, 16.0 );\n\n\n    // default background color\n    color = RGB( 92, 148, 252 );\n\n    \n    // draw hills\n    float bigHillX \t = mod( worldX, 768.0 );\n    float smallHillX = mod( worldX - 240.0, 768.0 );\n    float hillX \t = min( bigHillX, smallHillX );\n    float hillY      = worldY - ( smallHillX < bigHillX ? 0.0 : 16.0 );\n    SpriteHill( color, hillX, hillY );\n\n\n    // draw clouds and bushes\n\tfloat sc1CloudX = mod( worldX - 296.0, 768.0 );\n    float sc2CloudX = mod( worldX - 904.0, 768.0 );\n    float mcCloudX  = mod( worldX - 584.0, 768.0 );\n    float lcCloudX  = mod( worldX - 440.0, 768.0 );    \n    float scCloudX  = min( sc1CloudX, sc2CloudX );\n    float sbCloudX \t= mod( worldX - 376.0, 768.0 );\n    float mbCloudX  = mod( worldX - 664.0, 768.0 );  \n\tfloat lbCloudX  = mod( worldX - 184.0, 768.0 );\n    float cCloudX\t= min( min( scCloudX, mcCloudX ), lcCloudX );\n    float bCloudX\t= min( min( sbCloudX, mbCloudX ), lbCloudX );\n    float sCloudX\t= min( scCloudX, sbCloudX );\n    float mCloudX\t= min( mcCloudX, mbCloudX );\n    float lCloudX\t= min( lcCloudX, lbCloudX );\n    float cloudX\t= min( cCloudX, bCloudX );\n    float isBush\t= bCloudX < cCloudX ? 1.0 : 0.0;\n    float cloudSeg\t= cloudX == sCloudX ? 0.0 : ( cloudX == mCloudX ? 1.0 : 2.0 );\n    float cloudY\t= worldY - ( isBush == 1.0 ? 8.0 : ( ( cloudSeg == 0.0 && sc1CloudX < sc2CloudX ) || cloudSeg == 1.0 ? 168.0 : 152.0 ) );\n\tif ( cloudX >= 0.0 && cloudX < 32.0 + 16.0 * cloudSeg )\n    {\n        if ( cloudSeg == 1.0 )\n        {\n        \tcloudX = cloudX < 24.0 ? cloudX : cloudX - 16.0;\n        }\n        if ( cloudSeg == 2.0 )\n        {\n        \tcloudX = cloudX < 24.0 ? cloudX : ( cloudX < 40.0 ? cloudX - 16.0 : cloudX - 32.0 );\n        }\n        \n    \tSpriteCloud( color, cloudX, cloudY, isBush );\n    }\n\n    \n    \n    // draw flag pole\n    if ( worldX >= 3175.0 && worldX <= 3176.0 && worldY <= 176.0 )        \n    {\n        color = RGB( 189, 255, 24 );\n    }\n    \n    // draw flag\n    float flagX = worldX - 3160.0;\n    float flagY = worldY - 159.0 + floor( 122.0 * clamp( ( time - 39.0 ) / 1.0, 0.0, 1.0 ) );\n    if ( flagX >= 0.0 && flagX <= 15.0 )\n    {\n    \tSpriteFlag( color, flagX, flagY );\n    }     \n    \n    // draw flagpole end\n    float flagpoleEndX = worldX - 3172.0;\n    float flagpoleEndY = worldY - 176.0;\n    if ( flagpoleEndX >= 0.0 && flagpoleEndX <= 7.0 )\n    {\n    \tSpriteFlagpoleEnd( color, flagpoleEndX, flagpoleEndY );\n    }\n    \n    \n\n    // draw blocks\n   \tif (    ( tileX >= 134.0 && tileX < 138.0 && tileX - 132.0 > tileY )\n         || ( tileX >= 140.0 && tileX < 144.0 && 145.0 - tileX > tileY )\n         || ( tileX >= 148.0 && tileX < 153.0 && tileX - 146.0 > tileY && tileY < 5.0 )\n         || ( tileX >= 155.0 && tileX < 159.0 && 160.0 - tileX > tileY ) \n         || ( tileX >= 181.0 && tileX < 190.0 && tileX - 179.0 > tileY && tileY < 9.0 )\n         || ( tileX == 198.0 && tileY == 1.0 )\n       )\n    {\n        SpriteBlock( color, worldXMod16, worldYMod16 );\n    }\n    \n    \n    // draw pipes\n    float pipeY = worldY - 16.0;  \n    float pipeH\t= 0.0;    \n    float pipeX = worldX - 179.0 * 16.0;\n    if ( pipeX < 0.0 )\n    {\n        pipeX = worldX - 163.0 * 16.0;\n        pipeH = 0.0;\n    }\n    if ( pipeX < 0.0 )\n    {\n        pipeX = worldX - 57.0 * 16.0;\n        pipeH = 2.0;\n    }\n    if ( pipeX < 0.0 )\n    {\n        pipeX = worldX - 46.0 * 16.0;\n        pipeH = 2.0;\n    } \n    if ( pipeX < 0.0 )\n    {\n        pipeX = worldX - 38.0 * 16.0;\n        pipeH = 1.0;\n    }         \n    if ( pipeX < 0.0 )\n    {\n        pipeX = worldX - 28.0 * 16.0;\n        pipeH = 0.0;\n    }\n    if ( pipeX >= 0.0 && pipeX <= 31.0 && pipeY >= 0.0 && pipeY <= 31.0 + pipeH * 16.0 )\n\t{\n\t\tSpritePipe( color, pipeX, pipeY, pipeH );\n\t}\n    \n    \n    // draw mushroom\n    float mushroomStart = 15.7;    \n    if ( time >= mushroomStart && time <= 17.0 )\n    {\n        float jumpTime = 0.5;\n        \n        float mushroomX = worldX - 1248.0;\n        float mushroomY = worldY - 4.0 * 16.0;\n        if ( time >= mushroomStart )\n        {\n            mushroomY = worldY - 4.0 * 16.0 - floor( 16.0 * clamp( ( time - mushroomStart ) / 0.5, 0.0, 1.0 ) );\n        }\n        if ( time >= mushroomStart + 0.5 )\n        {\n            mushroomX -= floor( MARIO_SPEED * ( time - mushroomStart - 0.5 ) );\n        }\n        if ( time >= mushroomStart + 0.5 + 0.4 )\n        {\n            mushroomY = mushroomY + floor( sin( ( ( time - mushroomStart - 0.5 - 0.4 ) ) * 3.14 ) * 4.0 * 16.0 );\n        }\n        \n        if ( mushroomX >= 0.0 && mushroomX <= 15.0 )\n        {\n        \tSpriteMushroom( color, mushroomX, mushroomY );\n        }\n    }\n\n    \n    // draw coins\n    float coinFrame = floor( mod( time * 12.0, 4.0 ) );\n    float coinX \t= worldX - 2720.0;\n    float coinTime \t= 33.9;    \n    float coinY \t= CoinAnimY( worldY, time, coinTime );\n    if ( coinX < 0.0 )\n    {\n    \tcoinX \t\t= worldX - 1696.0;\n    \tcoinTime \t= 22.4;    \n    \tcoinY \t\t= CoinAnimY( worldY, time, coinTime );        \n    }\n    if ( coinX < 0.0 )\n    {\n    \tcoinX \t\t= worldX - 352.0;\n    \tcoinTime \t= 5.4;    \n    \tcoinY \t\t= CoinAnimY( worldY, time, coinTime );\n    } \n    \n    if ( coinX >= 0.0 && coinX <= 15.0 && time >= coinTime + 0.1 )\n    {   \n        SpriteCoin( color, coinX, coinY, coinFrame );\n    }\n\n    \n    // draw questions\n\tfloat questionT = clamp( sin( time * 6.0 ), 0.0, 1.0 );    \n    if (    ( tileY == 4.0 && ( tileX == 16.0 || tileX == 20.0 || tileX == 109.0 || tileX == 112.0 ) )\n         || ( tileY == 8.0 && ( tileX == 21.0 || tileX == 94.0 || tileX == 109.0 ) )\n         || ( tileY == 8.0 && ( tileX >= 129.0 && tileX <= 130.0 ) )\n       )\n    {\n        SpriteQuestion( color, worldXMod16, worldYMod16, questionT );\n    }\n    \n    \n    // draw hitted questions\n    float questionHitTime \t= 33.9;\n    float questionX \t\t= worldX - 2720.0;\n    if ( questionX < 0.0 )\n    {\n        questionHitTime = 22.4;\n        questionX\t\t= worldX - 1696.0;\n    }\n    if ( questionX < 0.0 )\n    {\n        questionHitTime = 15.4;\n        questionX\t\t= worldX - 1248.0;\n    }\n    if ( questionX < 0.0 )\n    {\n        questionHitTime = 5.3;\n        questionX\t\t= worldX - 352.0;\n    }    \n    questionT\t\t= time >= questionHitTime ? 1.0 : questionT;    \n    float questionY = QuestionAnimY( worldY, time, questionHitTime );\n    if ( questionX >= 0.0 && questionX <= 15.0 )\n    {\n    \tSpriteQuestion( color, questionX, questionY, questionT );\n    }\n    if ( time >= questionHitTime && questionX >= 3.0 && questionX <= 12.0 && questionY >= 1.0 && questionY <= 15.0 )\n    {\n        color = RGB( 231, 90, 16 );\n    }    \n\n    \n    // draw bricks\n   \tif (    ( tileY == 4.0 && ( tileX == 19.0 || tileX == 21.0 || tileX == 23.0 || tileX == 77.0 || tileX == 79.0 || tileX == 94.0 || tileX == 118.0 || tileX == 168.0 || tileX == 169.0 || tileX == 171.0 ) )\n         || ( tileY == 8.0 && ( tileX == 128.0 || tileX == 131.0 ) )\n         || ( tileY == 8.0 && ( tileX >= 80.0 && tileX <= 87.0 ) )\n         || ( tileY == 8.0 && ( tileX >= 91.0 && tileX <= 93.0 ) )\n         || ( tileY == 4.0 && ( tileX >= 100.0 && tileX <= 101.0 ) )\n         || ( tileY == 8.0 && ( tileX >= 121.0 && tileX <= 123.0 ) )\n         || ( tileY == 4.0 && ( tileX >= 129.0 && tileX <= 130.0 ) )\n       )\n    {\n        SpriteBrick( color, worldXMod16, worldYMod16 );\n    }   \n    \n    \n    // draw castle flag\n    float castleFlagX = worldX - 3264.0;\n    float castleFlagY = worldY - 64.0 - floor( 32.0 * clamp( ( time - 44.6 ) / 1.0, 0.0, 1.0 ) );\n    if ( castleFlagX > 0.0 && castleFlagX < 14.0 )\n    {\n    \tSpriteCastleFlag( color, castleFlagX, castleFlagY );\n\t}\n    \n    DrawCastle( color, worldX - 3232.0, worldY - 16.0 );\n\n    // draw ground\n    if ( tileY <= 0.0\n         && !( tileX >= 69.0  && tileX < 71.0 )\n         && !( tileX >= 86.0  && tileX < 89.0 ) \n         && !( tileX >= 153.0 && tileX < 155.0 ) \n       )\n    {\n        SpriteGround( color, worldXMod16, worldYMod16 );\n    }    \n    \n\n    // draw Koopa\n    float goombaFrame = floor( mod( time * 5.0, 2.0 ) );\n    KoopaWalk( color, worldX, worldY, time, goombaFrame, 2370.0 );\n    \n    \n    // draw stomped walking Goombas\n    float goombaY \t\t\t= worldY - 16.0;        \n    float goombaLifeTime \t= 26.3;\n    float goombaX \t\t\t= GoombaSWalkX( worldX, 2850.0 + 24.0, time, goombaLifeTime );\n    if ( goombaX < 0.0 )\n    {\n        goombaLifeTime \t= 25.3;\n        goombaX \t\t= GoombaSWalkX( worldX, 2760.0, time, goombaLifeTime );\n    }\n    if ( goombaX < 0.0 ) \n    {\n\t\tgoombaLifeTime \t= 23.5;\n        goombaX \t\t= GoombaSWalkX( worldX, 2540.0, time, goombaLifeTime );\n    }\n    if ( goombaX < 0.0 ) \n    {\n        goombaLifeTime \t= 20.29;\n        goombaX \t\t= GoombaSWalkX( worldX, 2150.0, time, goombaLifeTime );\n    }\n    if ( goombaX < 0.0 )\n    {\n        goombaLifeTime \t= 10.3;\n\t\tgoombaX \t\t= worldX - 790.0 - floor( abs( mod( ( min( time, goombaLifeTime ) + 6.3 ) * GOOMBA_SPEED, 2.0 * 108.0 ) - 108.0 ) );\n    }\n\tgoombaFrame = time > goombaLifeTime ? 2.0 : goombaFrame;\n    if ( goombaX >= 0.0 && goombaX <= 15.0 )\n    {\n        SpriteGoomba( color, goombaX, goombaY, goombaFrame );\n    }    \n    \n    // draw walking Goombas\n    goombaFrame \t\t= floor( mod( time * 5.0, 2.0 ) );\n    float goombaWalkX \t= worldX + floor( time * GOOMBA_SPEED );\n    goombaX \t\t\t= goombaWalkX - 3850.0 - 24.0;\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 3850.0;\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 2850.0;\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 2760.0 - 24.0;\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 2540.0 - 24.0;\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 2150.0 - 24.0;\n    if ( goombaX < 0.0 ) goombaX = worldX - 766.0 - floor( abs( mod( ( time + 6.3 ) * GOOMBA_SPEED, 2.0 * 108.0 ) - 108.0 ) );\n    if ( goombaX < 0.0 ) goombaX = worldX - 638.0 - floor( abs( mod( ( time + 6.6 ) * GOOMBA_SPEED, 2.0 * 84.0 ) - 84.0 ) );\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 435.0;\n    if ( goombaX >= 0.0 && goombaX <= 15.0 )\n    {\n        SpriteGoomba( color, goombaX, goombaY, goombaFrame );\n    }\n    \n\n    \n    // Mario jump\n    float marioBigJump1 \t= 27.1;\n    float marioBigJump2 \t= 29.75;\n    float marioBigJump3 \t= 35.05;    \n    float marioJumpTime \t= 0.0;\n    float marioJumpScale\t= 0.0;\n    \n    if ( time >= 4.2   ) { marioJumpTime = 4.2;   marioJumpScale = 0.45; }\n    if ( time >= 5.0   ) { marioJumpTime = 5.0;   marioJumpScale = 0.5;  }\n    if ( time >= 6.05  ) { marioJumpTime = 6.05;  marioJumpScale = 0.7;  }\n    if ( time >= 7.8   ) { marioJumpTime = 7.8;   marioJumpScale = 0.8;  }\n    if ( time >= 9.0   ) { marioJumpTime = 9.0;   marioJumpScale = 1.0;  }\n    if ( time >= 10.3  ) { marioJumpTime = 10.3;  marioJumpScale = 0.3;  }\n    if ( time >= 11.05 ) { marioJumpTime = 11.05; marioJumpScale = 1.0;  }\n    if ( time >= 13.62 ) { marioJumpTime = 13.62; marioJumpScale = 0.45; }\n    if ( time >= 15.1  ) { marioJumpTime = 15.1;  marioJumpScale = 0.5;  }\n    if ( time >= 18.7  ) { marioJumpTime = 18.7;  marioJumpScale = 0.6;  }\n    if ( time >= 19.65 ) { marioJumpTime = 19.65; marioJumpScale = 0.45; }\n    if ( time >= 20.29 ) { marioJumpTime = 20.29; marioJumpScale = 0.3;  }\n    if ( time >= 21.8  ) { marioJumpTime = 21.8;  marioJumpScale = 0.35; }\n    if ( time >= 22.3  ) { marioJumpTime = 22.3;  marioJumpScale = 0.35; }\n    if ( time >= 23.0  ) { marioJumpTime = 23.0;  marioJumpScale = 0.40; }\n    if ( time >= 23.5  ) { marioJumpTime = 23.5;  marioJumpScale = 0.3;  }\n    if ( time >= 24.7  ) { marioJumpTime = 24.7;  marioJumpScale = 0.45; }\n    if ( time >= 25.3  ) { marioJumpTime = 25.3;  marioJumpScale = 0.3;  }\n    if ( time >= 25.75 ) { marioJumpTime = 25.75; marioJumpScale = 0.4;  }\n    if ( time >= 26.3  ) { marioJumpTime = 26.3;  marioJumpScale = 0.25; }\n    if ( time >= marioBigJump1 ) \t\t{ marioJumpTime = marioBigJump1; \t\tmarioJumpScale = 1.0; }\n    if ( time >= marioBigJump1 + 1.0 ) \t{ marioJumpTime = marioBigJump1 + 1.0; \tmarioJumpScale = 0.6; }\n    if ( time >= marioBigJump2 ) \t\t{ marioJumpTime = marioBigJump2; \t\tmarioJumpScale = 1.0; }\n    if ( time >= marioBigJump2 + 1.0 ) \t{ marioJumpTime = marioBigJump2 + 1.0;\tmarioJumpScale = 0.6; }    \n    if ( time >= 32.3  ) { marioJumpTime = 32.3;  marioJumpScale = 0.7;  }\n    if ( time >= 33.7  ) { marioJumpTime = 33.7;  marioJumpScale = 0.3;  }\n    if ( time >= 34.15 ) { marioJumpTime = 34.15; marioJumpScale = 0.45; }\n    if ( time >= marioBigJump3 ) \t\t\t\t{ marioJumpTime = marioBigJump3; \t\t\t\tmarioJumpScale = 1.0; }\n    if ( time >= marioBigJump3 + 1.2 ) \t\t\t{ marioJumpTime = marioBigJump3 + 1.2; \t\t\tmarioJumpScale = 0.89; }\n    if ( time >= marioBigJump3 + 1.2 + 0.75 ) \t{ marioJumpTime = marioBigJump3 + 1.2 + 0.75; \tmarioJumpScale = 0.5; }\n    \n    float marioJumpOffset \t\t= 0.0;\n    float marioJumpLength \t\t= 1.5  * marioJumpScale;\n    float marioJumpAmplitude\t= 76.0 * marioJumpScale;\n    if ( time >= marioJumpTime && time <= marioJumpTime + marioJumpLength )\n    {\n        float t = ( time - marioJumpTime ) / marioJumpLength;\n        marioJumpOffset = floor( sin( t * 3.14 ) * marioJumpAmplitude );\n    }\n    \n    \n    // Mario land\n    float marioLandTime \t= 0.0;\n    float marioLandAplitude = 0.0;\n    if ( time >= marioBigJump1 + 1.0 + 0.45 ) \t\t\t{ marioLandTime = marioBigJump1 + 1.0 + 0.45; \t\t\tmarioLandAplitude = 109.0; }\n    if ( time >= marioBigJump2 + 1.0 + 0.45 ) \t\t\t{ marioLandTime = marioBigJump2 + 1.0 + 0.45; \t\t\tmarioLandAplitude = 109.0; }\n\tif ( time >= marioBigJump3 + 1.2 + 0.75 + 0.375 ) \t{ marioLandTime = marioBigJump3 + 1.2 + 0.75 + 0.375; \tmarioLandAplitude = 150.0; }\n    \n    float marioLandLength = marioLandAplitude / 120.0;\n\tif ( time >= marioLandTime && time <= marioLandTime + marioLandLength )\n    {\n        float t = 0.5 * ( time - marioLandTime ) / marioLandLength + 0.5;\n       \tmarioJumpOffset = floor( sin( t * 3.14 ) * marioLandAplitude );\n    }\n    \n    \n    // Mario flag jump\n    marioJumpTime \t\t= flagPauseStart - 0.3;\n    marioJumpLength \t= 1.5  * 0.45;\n    marioJumpAmplitude\t= 76.0 * 0.45;\n    if ( time >= marioJumpTime && time <= marioJumpTime + marioJumpLength + flagPauseLength ) \n    {\n        float time2 = time;\n        if ( time >= flagPauseStart && time <= flagPauseStart + flagPauseLength ) \n        {\n            time2 = flagPauseStart;\n        }\n        else if ( time >= flagPauseStart )\n        {\n            time2 = time - flagPauseLength;\n        }\n\t\tfloat t = ( time2 - marioJumpTime ) / marioJumpLength;\n        marioJumpOffset = floor( sin( t * 3.14 ) * marioJumpAmplitude );\n    }\n    \n\n    // Mario base (ground offset)\n    float marioBase = 0.0;\n    if ( time >= marioBigJump1 + 1.0 && time < marioBigJump1 + 1.0 + 0.45 )\n    {\n        marioBase = 16.0 * 4.0;\n    }\n    if ( time >= marioBigJump2 + 1.0 && time < marioBigJump2 + 1.0 + 0.45 )\n    {\n        marioBase = 16.0 * 4.0;\n    }    \n    if ( time >= marioBigJump3 + 1.2 && time < marioBigJump3 + 1.2 + 0.75 )\n    {\n        marioBase = 16.0 * 3.0;\n    }    \n    if ( time >= marioBigJump3 + 1.2 + 0.75 && time < marioBigJump3 + 1.2 + 0.75 + 0.375 )\n    {\n        marioBase = 16.0 * 7.0;\n    }\n\n    float marioX\t\t= pixelX - 112.0;\n    float marioY\t\t= pixelY - 16.0 - 8.0 - marioBase - marioJumpOffset;    \n    float marioFrame \t= marioJumpOffset == 0.0 ? floor( mod( time * 10.0, 3.0 ) ) : 3.0;\n    if ( time >= mushroomPauseStart && time <= mushroomPauseStart + mushroomPauseLength )\n    {\n    \tmarioFrame = 1.0;\n    }    \n    if ( time > mushroomPauseStart + 0.7 )\n    {\n        float t = time - mushroomPauseStart - 0.7;\n    \tif ( mod( t, 0.2 ) <= mix( 0.0, 0.2, clamp( t / 1.3, 0.0, 1.0 ) ) )\n        {\n            // super mario offset\n            marioFrame += 4.0;\n        }\n    }    \n    if ( marioX >= 0.0 && marioX <= 15.0 && cameraX < 3152.0 )\n    {\n        SpriteMario( color, marioX, marioY, marioFrame );\n    }\n}\n\nvec2 CRTCurveUV( vec2 uv )\n{\n    uv = uv * 2.0 - 1.0;\n    vec2 offset = abs( uv.yx ) / vec2( 6.0, 4.0 );\n    uv = uv + uv * offset * offset;\n    uv = uv * 0.5 + 0.5;\n    return uv;\n}\n\nvoid DrawVignette( inout vec3 color, vec2 uv )\n{    \n    float vignette = uv.x * uv.y * ( 1.0 - uv.x ) * ( 1.0 - uv.y );\n    vignette = clamp( pow( 16.0 * vignette, 0.3 ), 0.0, 1.0 );\n    color *= vignette;\n}\n\nvoid DrawScanline( inout vec3 color, vec2 uv )\n{\n    float scanline \t= clamp( 0.95 + 0.05 * cos( 3.14 * ( uv.y + 0.008 * iTime ) * 240.0 * 1.0 ), 0.0, 1.0 );\n    float grille \t= 0.85 + 0.15 * clamp( 1.5 * cos( 3.14 * uv.x * 640.0 * 1.0 ), 0.0, 1.0 );    \n    color *= scanline * grille * 1.2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // we want to see at least 224x192 (overscan) and we want multiples of pixel size\n    float resMultX  = floor( iResolution.x / 224.0 );\n    float resMultY  = floor( iResolution.y / 192.0 );\n    float resRcp\t= 1.0 / max( min( resMultX, resMultY ), 1.0 );\n    \n    float time\t\t\t= iTime;\n    float screenWidth\t= floor( iResolution.x * resRcp );\n    float screenHeight\t= floor( iResolution.y * resRcp );\n    float pixelX \t\t= floor( fragCoord.x * resRcp );\n    float pixelY \t\t= floor( fragCoord.y * resRcp );\n\n    vec3 color = RGB( 92, 148, 252 );\n \tDrawGame( color, time, pixelX, pixelY, screenWidth, screenHeight );\n    if ( time < INTRO_LENGTH )\n    {\n        DrawIntro( color, pixelX, pixelY, screenWidth, screenHeight );\n    }    \n\n    \n    // CRT effects (curvature, vignette, scanlines and CRT grille)\n    vec2 uv    = fragCoord.xy / iResolution.xy;\n    vec2 crtUV = CRTCurveUV( uv );\n    if ( crtUV.x < 0.0 || crtUV.x > 1.0 || crtUV.y < 0.0 || crtUV.y > 1.0 )\n    {\n        color = vec3( 0.0, 0.0, 0.0 );\n    }\n    DrawVignette( color, crtUV );\n    DrawScanline( color, uv );\n    \n\tfragColor.xyz \t= color;\n    fragColor.w\t\t= 1.0;\n}",
    "tags": [
      "2d",
      "sound",
      "music",
      "crt",
      "sprite",
      "mario",
      "nes",
      "sig15"
    ],
    "author": "knarkowicz",
    "views": 0,
    "likes": 640,
    "published": 3
  },
  {
    "id": "4sfGWX",
    "title": "Wolfenstein 3D",
    "description": "Experiment to generate some well-known textures (from the [url=https://en.wikipedia.org/wiki/Wolfenstein_3D]first-person shooter video game developed by id Software[/url]) in a textureless shader.",
    "code": "// Wolfenstein. Created by Reinder Nijhoff 2013\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n// @reindernijhoff\n//\n// https://www.shadertoy.com/view/4sfGWX\n//\n\n#define NUM_MATERIALS 3\n#define NUM_OBJECTS 1\n#define SECONDS_IN_ROOM 3.\n#define ROOM_SIZE 10.\n#define MAXSTEPS 17\n#define MATERIAL_DOOR 200\n#define MATERIAL_DOORWAY 201\n\n#define COL(r,g,b) vec3(r/255.,g/255.,b/255.)\n\n#define time (iTime+40.)\nvec3 rdcenter;\n\n//----------------------------------------------------------------------\n// Math functions\n\nfloat hash( const float n ) {\n    return fract(sin(n*14.1234512)*51231.545341231);\n}\nfloat hash( const vec2 x ) {\n\tfloat n = dot( x, vec2(14.1432,1131.15532) );\n    return fract(sin(n)*51231.545341231);\n}\nfloat crossp( const vec2 a, const vec2 b ) { return a.x*b.y - a.y*b.x; }\nvec3 rotate(vec3 r, float v){ return vec3(r.x*cos(v)+r.z*sin(v),r.y,r.z*cos(v)-r.x*sin(v));}\nbool intersectSegment(const vec3 ro, const vec3 rd, const vec2 a, const vec2 b, out float dist, out float u) {\n\tvec2 p = ro.xz;\tvec2 r = rd.xz;\n\tvec2 q = a-p;\tvec2 s = b-a;\n\tfloat rCrossS = crossp(r, s);\n\t\n\tif( rCrossS == 0.){\n\t\treturn false;\n    } else {\n\t\tdist = crossp(q, s) / rCrossS;\n\t\tu = crossp(q, r) / rCrossS;\n\t\n\t\tif(0. <= dist && 0. <= u && u <= 1.){\n\t\t\treturn true;\n        } else {\n\t\t\treturn false;\n        }\n    }\n}\n\n//----------------------------------------------------------------------\n// Material helper functions\n\nfloat onCircle( const vec2 c, const vec2 centre, const float radius ) {\n\treturn clamp( 4.*(radius - distance(c,centre)), 0., 1. );\n}\nfloat onCircleLine( const vec2 c, const vec2 centre, const float radius ) {\n\treturn clamp( 1.-1.5*abs(radius - distance(c,centre)), 0., 1. );\n}\nfloat onLine( const float c, const float b ) {\n\treturn clamp( 1.-abs(b-c), 0., 1. );\n}\nfloat onBand( const float c, const float mi, const float ma ) {\n\treturn clamp( (ma-c+1.), 0., 1. )*clamp( (c-mi+1.), 0., 1. );\n}\nfloat onLineSegmentX( const vec2 c, const float b, const float mi, const float ma ) {\n\treturn onLine( c.x, b )*onBand( c.y, mi, ma );\n}\nfloat onLineSegmentY( const vec2 c, const float b, const float mi, const float ma ) {\n\treturn onLine( c.y, b )*onBand( c.x, mi, ma );\n}\nfloat onRect( const vec2 c, const vec2 lt, const vec2 rb ) {\n\treturn onBand( c.x, lt.x, rb.x )*onBand( c.y, lt.y, rb.y );\n}\nvec3 addBevel( const vec2 c, const vec2 lt, const vec2 rb, const float size, const float strength, const float lil, const float lit, const vec3 col ) {\n\tfloat xl = clamp( (c.x-lt.x)/size, 0., 1. ); \n\tfloat xr = clamp( (rb.x-c.x)/size, 0., 1. );\t\n\tfloat yt = clamp( (c.y-lt.y)/size, 0., 1. ); \n\tfloat yb = clamp( (rb.y-c.y)/size, 0., 1. );\t\n\n\treturn mix( col, col*clamp(1.0+strength*(lil*(xl-xr)+lit*(yb-yt)), 0., 2.), onRect( c, lt, rb ) );\n}\nvec3 addKnob( const vec2 c, const vec2 centre, const float radius, const float strength, const vec3 col ) {\n\tvec2 lv = normalize( centre-c );\n\treturn mix( col, col*(1.0+strength*dot(lv,vec2(-0.7071,0.7071))), onCircle(c, centre, radius ) );\n}\nfloat stepeq( float a, float b ) { \n\treturn step( a, b )*step( b, a );\n}\n//----------------------------------------------------------------------\n// Generate materials!\n\nvoid getMaterialColor( const int material, in vec2 uv, const float decorationHash, out vec3 col ) {\t\n\tvec3 fgcol;\n\t\n\tuv = floor( mod(uv+64., vec2(64.)) );\n\tvec2 uvs = uv / 64.;\n\t\n\t// basecolor\n\tvec3 basecol = vec3( mix(55./255.,84./255.,uvs.y ) );\t\n\tfloat br = hash(uv);\n\tcol = basecol;\n// grey bricks\n\tif( material == 0 || material == 1 ) {\n\t\tvec2 buv = vec2( mod(uv.x+1. + (floor((uv.y+1.) / 16.) * 16.), 32.) , mod( uv.y+1., 16.) );\n\t\tfloat bbr = mix( 190./255., 91./255., (buv.y)/14. ) + 0.05*br;\n\t\tif ( buv.x < 2. || buv.y < 2.) {\n\t\t\tbbr = 72./255.; \n\t\t}\n\t\tcol = vec3(bbr*0.95);\n\t\tcol = addBevel( buv, vec2(1.,1.), vec2( 31.5, 15.), 2., 0.35, 1., 1., col);\n\t// blue wall\n\t\tif( material == 1 ) {\n\t\t\tcol *= 1.3*COL(11.,50.,209.);\n\t\t\tcol = mix( col, COL(2.,15.,86.), onBand(uv.y,14.,49.));\n\t\t\tcol = mix( col, COL(9.,44.,185.)*(0.9+0.1*br), onBand(uv.y,16.,47.));\n\t\t\tcol = mix( col, COL(3.,25.,122.), onBand(uv.y,21.,42.));\n\t\t\tcol = addBevel( uv, vec2(-1.,16.), vec2( 65., 21.), 1., 0.35, 1., 1., col);\n\t\t\tcol = addBevel( uv, vec2(-1.,43.), vec2( 65., 48.), 1., 0.35, 1., 1., col);\n\t\t\t\n\t\t\tcol = mix( col, COL(2.,11.,74.), onRect(uv, vec2(22.,22.), vec2(42.,42.)));\t\t\n\t\t\tcol = mix( col, COL(9.,44.,185.)*(0.95+0.1*br), onRect(uv, vec2(22.,23.), vec2(42.,40.)));\n\t\t\tcol = addBevel( uv, vec2(22.,23.), vec2(42.,40.), 1., 0.2, -1., 1., col);\n\t\t\tcol = mix( col, mix(COL(2.,11.,74.), COL(3.,25.,122.), (uv.x-26.)/3.), onRect(uv, vec2(26.,23.), vec2(29.,29.)));\n\t\t\tcol = mix( col, mix(COL(2.,11.,74.), COL(3.,25.,122.), (uv.y-34.)/2.), onRect(uv, vec2(22.,34.), vec2(29.,36.)));\n\t\t\tcol = mix( col, mix(COL(2.,11.,74.), COL(3.,25.,122.), (uv.y-27.)/2.), onRect(uv, vec2(35.,27.), vec2(42.,29.)));\n\t\t\tcol = mix( col, mix(COL(2.,11.,74.), COL(3.,25.,122.), (uv.y-34.)/8.), onRect(uv, vec2(35.,34.), vec2(38.,42.)));\n\t\t}\n\t}\n// wooden wall\n\telse if( material == 2 ) {\n\t\tfloat mx = mod( uv.x, 64./5. ); \n\t\tfloat h1 = hash( floor(uv.x/(64./5.)) );\n\t\tfloat h2 = hash( 1.+1431.16*floor(uv.x/(64./5.)) );\n\t\tcol = mix( COL(115.,75.,43.),COL( 71.,56.,26.), smoothstep( 0.2, 1., (0.7+h2)*abs(mod( h2-uv.y*(0.05+0.1*h2)+(1.+h1+h2)*sin(mx*(0.1+0.2*h2)), 2. )-1.) ) );\n\n\t\tcol = mix( col, mix(COL(40.,31.,13.), COL(142.,91.,56.), (uv.x)/2.), step(uv.x,2.) );\n\t\tcol = mix( col, mix(COL(40.,31.,13.), COL(142.,91.,56.), (uv.x-10.)/2.), step(10.,uv.x)*step(uv.x,12.) );\n\t\tcol = mix( col, mix(COL(40.,31.,13.), COL(142.,91.,56.), (uv.x-26.)/2.), step(26.,uv.x)*step(uv.x,28.) );\n\t\tcol = mix( col, mix(COL(40.,31.,13.), COL(142.,91.,56.), (uv.x-40.)/2.), step(40.,uv.x)*step(uv.x,42.) );\n\t\tcol = mix( col, mix(COL(40.,31.,13.), COL(142.,91.,56.), (uv.x-54.)/2.), step(54.,uv.x)*step(uv.x,56.) );\n\n\t\tcol = mix( col, mix(COL(83.,60.,31.), COL(142.,91.,56.), (uv.x- 8.)), step( 8.,uv.x)*step(uv.x,9.) );\n\t\tcol = mix( col, mix(COL(83.,60.,31.), COL(142.,91.,56.), (uv.x-24.)), step(24.,uv.x)*step(uv.x,25.) );\n\t\tcol = mix( col, mix(COL(83.,60.,31.), COL(142.,91.,56.), (uv.x-38.)), step(38.,uv.x)*step(uv.x,39.) );\n\t\tcol = mix( col, mix(COL(83.,60.,31.), COL(142.,91.,56.), (uv.x-52.)), step(52.,uv.x)*step(uv.x,53.) );\n\t\tcol = mix( col, mix(COL(83.,60.,31.), COL(142.,91.,56.), (uv.x-62.)), step(62.,uv.x) );\n\t\t\n\t\tcol = mix( col, mix(COL(40.,31.,13.), COL(142.,91.,56.), (uv.y)/2.), step(uv.y,2.) );\n\t\tcol *= 1.-0.3*stepeq(uv.y,3.);\n\t}\n// door\n\telse if( material == MATERIAL_DOOR ) {\n\t\tfgcol = COL(44., 176., 175.)*(0.95+0.15*sin(-0.25+ 4.*((-0.9-uvs.y)/(1.3-0.8*uvs.x)) ) );\n\t\tfgcol = addBevel( uv, vec2(-1.,1.), vec2(62.,66.), 2., 0.4, -1., -1., fgcol);\n\t\tfgcol = addBevel( uv, vec2( 6.,6.), vec2(57.,57.), 2.25, 0.5, -1., -1., fgcol);\t\n\t\tfgcol = mix( addKnob( mod( uv, vec2(8.) ), vec2(3.5), 1.65, 0.5, fgcol ), fgcol, onRect( uv,  vec2( 6.,6.), vec2(57.,57.)) ) ;\n\t\t\n\t\t//knob\n\t\tfgcol *= 1.-0.2*onRect( uv, vec2( 13.5, 28.5 ), vec2( 22.5, 44.5 ) );\n\t\tfgcol = mix( fgcol, mix( COL(44.,44.,44.),COL(152.,152.,152.), ((uv.x+(43.-uv.y)-15.)/25. ) ), onRect( uv, vec2( 15., 27. ), vec2( 24., 43. ) ) );\n\t\tfgcol = addBevel( uv, vec2( 15., 27. ), vec2( 24., 43. ), 1., 0.45, 1., 1., fgcol);\t\n\t\tfgcol = mix( fgcol, addKnob( mod( uv, vec2(6.) ), vec2(4.25,5.5), 1.15, 0.75, fgcol ), onRect( uv,  vec2( 15., 27. ), vec2( 24., 43. ) ) ) ;\n\n\t\tfgcol *= 1.-0.5*onRect( uv, vec2( 16.5, 33.5 ), vec2( 20.5, 38.5 ) );\n\t\tfgcol = mix( fgcol, mix( COL(88.,84.,11.),COL(251.,242.,53.), ((uv.x+(37.-uv.y)-18.)/7. ) ), onRect( uv, vec2( 18., 33. ), vec2( 21., 37. ) ) );\n\t\tfgcol = mix( fgcol, COL(0.,0.,0.), onRect( uv, vec2( 19., 34. ), vec2( 20., 35.7 ) ) );\n\n\t\tfgcol *= 1.-0.2*onRect( uv, vec2( 6.5, 29.5 ), vec2( 10.5, 41.5 ) );\n\t\tfgcol = mix( fgcol, mix( COL(88.,84.,11.),COL(251.,242.,53.), ((uv.x+(40.-uv.y)-9.)/13. ) ), onRect( uv, vec2( 9., 29. ), vec2( 11., 40. ) ) );\n\t\tfgcol = addBevel( uv, vec2( 9., 29. ), vec2( 11., 40. ), 0.75, 0.5, 1., 1., fgcol);\t\n\t\t\n\t\tcol = mix( basecol, fgcol, onRect( uv, vec2(1.,1.), vec2(62.,62.) ) );\t\n\t}\n// doorway\n\telse if( material == MATERIAL_DOORWAY ) {\n\t\tfgcol = COL(44., 176., 175.)*(0.95+0.15*sin(-0.25+ 4.*((-0.9-uvs.y)/(1.3-0.8*uvs.x)) ) );\n\t\tvec2 uvhx = vec2( 32.-abs(uv.x-32.), uv.y );\n\t\tfgcol = addBevel( uvhx, vec2(-1.,1.), vec2(28.,66.), 2., 0.4, -1., -1., fgcol);\n\t\tfgcol = addBevel( uvhx, vec2( 6.,6.), vec2(23.,57.), 2.25, 0.5, -1., -1., fgcol);\t\n\t\tfgcol = mix( addKnob( vec2( mod( uvhx.x, 22. ), mod( uvhx.y, 28. )), vec2(3.5), 1.65, 0.5, fgcol ), fgcol, onRect( uvhx,  vec2( 6.,6.), vec2(24.,57.)) ) ;\n\t\tfgcol = mix( fgcol, vec3(0.), onRect( uv, vec2( 29., 1.), vec2( 35., 63.) ) );\n\t\tcol = mix( basecol, fgcol, onRect( uv, vec2(1.,1.), vec2(62.,62.) ) );\t\n\t}\n\t\n// prison door\t\n\tif( decorationHash > 0.93 && material < (NUM_MATERIALS+1) ) {\t\n\t\tvec4 prisoncoords = vec4(12.,14.,52.,62.);\n\t// shadow\n\t\tcol *= 1.-0.5*onRect( uv,  vec2( 11., 13. ), vec2( 53., 63. ) );\n\t// hinge\n\t\tcol = mix( col, COL(72.,72.,72.), stepeq(uv.x, 53.)*step( mod(uv.y+2.,25.), 5.)*step(13.,uv.y) );\n\t\tcol = mix( col, COL(100.,100.,100.), stepeq(uv.x, 53.)*step( mod(uv.y+1.,25.), 3.)*step(13.,uv.y) );\n\t\t\n\t\tvec3 pcol = vec3(0.)+COL(100.,100.,100.)*step( mod(uv.x-4., 7.), 0. ); \n\t\tpcol += COL(55.,55.,55.)*step( mod(uv.x-5., 7.), 0. ); \n\t\tpcol = addBevel(uv, vec2(0.,17.), vec2(63.,70.), 3., 0.8, 0., -1., pcol);\n\t\tpcol = addBevel(uv, vec2(0.,45.), vec2(22.,70.), 3., 0.8, 0., -1., pcol);\n\t\t\n\t\tfgcol = COL(72.,72.,72.);\n\t\tfgcol = addBevel(uv, prisoncoords.xy, prisoncoords.zw+vec2(1.,1.), 1., 0.5, -1., 1., fgcol );\n\t\tfgcol = addBevel(uv, prisoncoords.xy+vec2(3.,3.), prisoncoords.zw-vec2(2.,1.), 1., 0.5, 1., -1., fgcol );\n\t\tfgcol = mix( fgcol, pcol, onRect( uv, prisoncoords.xy+vec2(3.,3.), prisoncoords.zw-vec2(3.,2.) ) );\n\t\tfgcol = mix( fgcol, COL(72.,72.,72.), onRect( uv, vec2(15.,32.5), vec2(21.,44.) ) );\n\t\t\n\t\tfgcol = mix( fgcol, mix( COL(0.,0.,0.), COL(43.,43.,43.), (uv.y-37.) ), stepeq(uv.x, 15.)*step(37.,uv.y)*step(uv.y,38.) );\n\t\tfgcol = mix( fgcol, mix( COL(0.,0.,0.), COL(43.,43.,43.), (uv.y-37.)/3. ), stepeq(uv.x, 17.)*step(37.,uv.y)*step(uv.y,40.) );\n\t\tfgcol = mix( fgcol, COL(43.,43.,43.), stepeq(uv.x, 18.)*step(37.,uv.y)*step(uv.y,41.) );\n\t\tfgcol = mix( fgcol, mix( COL(0.,0.,0.), COL(100.,100.,100.), (uv.y-37.)/3. ), stepeq(uv.x, 18.)*step(36.,uv.y)*step(uv.y,40.) );\n\t\tfgcol = mix( fgcol, COL(43.,43.,43.), stepeq(uv.x, 19.)*step(37.,uv.y)*step(uv.y,40.) );\n\n\t\tfgcol = mix( fgcol, mix( COL(84.,84.,84.), COL(108.,108.,108.), (uv.x-15.)/2. ), stepeq(uv.y, 32.)*step(15.,uv.x)*step(uv.x,17.) );\n\t\tfgcol = mix( fgcol, COL(81.,81.,81.), stepeq(uv.y, 32.)*step(20.,uv.x)*step(uv.x,21.) );\n\n\t\tcol = mix( col, fgcol, onRect( uv, prisoncoords.xy, prisoncoords.zw ) );\n\t}\n// flag\n\telse if( decorationHash > 0.63 && material < (NUM_MATERIALS+1) ) {\t\t\n\t\tvec2 uvc = uv-vec2(32.,30.);\n\t\n\t// shadow\t\n\t\tvec4 shadowcoords = vec4( 14., 7., \n\t\t\t\t\t\t\t\t  54., max( 56. + sin( uv.x*0.32-1. ),56.) ); \n\t\tcol *= 1.-0.3*onRect( uv,  vec2( 6., 6. ), vec2( 61., 7. ) );\n\t\tcol *= 1.-0.3*clamp( 0.25*(56.-uv.x), 0., 1.)*onRect( uv, shadowcoords.xy, shadowcoords.zw );\n\n\t// rod\n\t\tcol = mix( col, COL(250.,167.,98.), onLineSegmentX( vec2( abs(uv.x-32.), uv.y ), 26., 4., 6.5 ) );\n\t\tcol = mix( col, COL(251.,242.,53.), onLineSegmentY( uv, 5., 4., 60. ) );\n\t\tcol = mix( col, COL(155.,76.,17.), onLineSegmentY( uv, 6., 4., 60. ) );\n\t\tcol = mix( col, COL(202.,96.,25.), onLineSegmentY( vec2( abs(uv.x-32.), uv.y ), 6., 26., 28. ) );\n\t\tcol = mix( col, COL(251.,242.,53.), onLineSegmentX( vec2( abs(uv.x-32.), uv.y ), 25., 3., 7. ) );\n\t\tcol = mix( col, COL(252.,252.,217.), onLineSegmentX( vec2( abs(uv.x-32.), uv.y ), 25., 4.3, 5.5 ) );\n\t\tcol = mix( col, COL(252.,252.,217.), onLineSegmentX( vec2( abs(uv.x-32.), uv.y ), 26., 5.3, 5.5 ) );\n\t\tcol = mix( col, COL(0.,0.,0.), onLineSegmentY( vec2( abs(uv.x-32.), uv.y ), 6., 18.3, 19.5 ) );\n\n\t// flag\t\n\t\tvec4 flagcoords = vec4( 13., min( 9.5 - pow(5.5* (uvs.x-0.5), 2.), 9. ), \n\t\t\t\t\t\t    51., max( 55. + sin( uv.x*0.4+2.7 ),55.) ); \n\t\n\t\tfgcol = COL(249.,41.,27.);\n\t\t\n\t\tfgcol = mix( fgcol, COL(255.,255.,255.), onBand( min(abs(uvc.x), abs(uvc.y)), 2., 4. ) );\n\t\tfgcol = mix( fgcol, COL(72.,72.,72.), onLine( min(abs(uvc.x), abs(uvc.y)), 3. ) );\t\t\n\t\t\n\t\tfgcol = mix( fgcol, COL(255.,255.,255.), onCircle( uv, vec2(32.,30.), 12.5 ) );\t\n\t\tfgcol = mix( fgcol, COL(0.,0.,0.), onCircleLine( uv, vec2(32.,30.), 11. ) );\t\n\t\tfgcol = mix( fgcol, COL(0.,0.,0.), onCircleLine( uv, vec2(32.,30.), 9. ) );\n\t\t\n\t\tvec2 uvr = vec2( (uvc.x-uvc.y)*0.7071, (uvc.y+uvc.x)*0.7071)*sign( uvc.x+0.5 );\n\t\tfgcol = mix( fgcol, COL(72.,72.,72.), onRect( uvr, vec2(-1.,-1.), vec2(1.,4.) ) );\n\t\tfgcol = mix( fgcol, COL(72.,72.,72.), onRect( uvr, vec2(-4.2, 4.2), vec2(1.,6.15) ) );\n\t\tfgcol = mix( fgcol, COL(72.,72.,72.), onRect( uvr, vec2(-1.,-1.), vec2(4.,1.) ) );\n\t\tfgcol = mix( fgcol, COL(72.,72.,72.), onRect( uvr, vec2( 4.2,-1.), vec2(6.15,4.2) ) );\n\t\n\t\tfgcol *= (0.8+0.2*sin( uv.x*0.4+2.7 ));\n\t\tfgcol *= (0.8+0.2*clamp( 0.5*(uv.y-7.), 0., 1.));\n\t\n\t// mix flag on background\n\t\tcol = mix( col, fgcol, onRect( uv, flagcoords.xy, flagcoords.zw ) );\n\t}\n\t\n// fake 8-bit color palette and dithering\t\n\tcol = floor( (col+0.5*mod(uv.x+uv.y,2.)/32.)*32.)/32.;\n}\nbool getObjectColor( const int object, in vec2 uv, inout vec3 icol ) {\n\tuv = floor( mod(uv, vec2(64.)) );\n\tvec2 uvs = uv / 64.;\n\tvec3 col = vec3(20./255.);\n\tfloat d;\n\t\n// only a lamp for now\n\t\n\t// lamp top\n\td = distance( uv*vec2(1.,2.), vec2(28.1, 5.8)*vec2(1.,2.) );\n\tcol = mix( col, mix( COL(41.,250.,46.), COL(13.,99.,12.), clamp( d/8.-0.2, 0., 1.) ), \n\t\t\t  onCircle(uv, vec2(31.,13.6), 11.7 )*step( uv.y, 6. )); \n\tcol = mix( col, COL(9.,75.,6.), onCircleLine( uv, vec2(31.,14.), 11.6 ) *\n\t\t\t  step( length(uv-vec2(31.,13.6)), 11.7 )*step( uv.y, 6. ) );\n\tcol = mix( col, COL(100.,100.,100.), onLine( abs(uv.x-31.), 1. )*step( uv.y, 1. ) );\n\tcol = mix( col, COL(140.,140.,140.), onLine( abs(uv.x-31.), 0.25 )*step( uv.y, 1. )*step( 1., uv.y ) );\n\t\n\t// lamp bottom\n\td = distance( uv*vec2(1.,2.), vec2(30.5, 6.5)*vec2(1.,2.) );\n\tcol = mix( col, mix( COL(41.,250.,46.), COL(13.,99.,12.), clamp( abs(uv.x-31.)/4.-1.25, 0., 1. )), step( abs(uv.x-31.), 9. )*stepeq( uv.y, 7.) );\n\tcol = mix( col, mix( COL(41.,250.,46.), COL(16.,123.,17.), clamp( abs(uv.x-31.)/4.-1.25, 0., 1. )), step( abs(uv.x-31.), 9. )*stepeq( uv.y, 8.) );\n\tcol = mix( col, mix( COL(133.,250.,130.), COL(22.,150.,23.), clamp( abs(uv.x-31.)/4.-0.75, 0., 1. )), step( abs(uv.x-31.), 7. )*stepeq( uv.y, 9.) );\n\n\tcol = mix( col, mix( COL(255.,251.,187.), col, clamp( d/4.5-0.6, 0., 1.) ), \n\t\t\t  onCircle(uv, vec2(31.,1.), 10.2 )*step( uv.y, 8. )*step( 7., uv.y )); \n\tcol = mix( col, mix( COL(255.,255.,255.), col, clamp( d/4.-0.7, 0., 1.) ), \n\t\t\t  onCircle(uv, vec2(31.,1.), 7.2 )*step( uv.y, 8. )*step( 7., uv.y )); \n\t\t\n\t// floor\n\td = distance( vec2(mod(uv.x, 32.),uv.y)*vec2(1.5,30./3.), vec2(16., 61.5)*vec2(1.5,30./3.) );\n\tcol = mix( col, mix( COL(168.,168.,168.), COL(124.,124.,124.), clamp(d/15.-0.5, 0., 1.) ), step(d,24.5)); \n\tcol = mix( col, mix( COL(124.,124.,124.), COL(140.,140.,140.), clamp((uv.y-59.)/1., 0., 1.)), step(59.,uv.y)*step(uv.x, 57.)*step(7.,uv.x)); \n\tcol = mix( col, mix( COL(168.,168.,168.), COL(124.,124.,124.), clamp(abs(32.-uv.x)/10.-2., 0., 1.)), step(uv.y, 62.)*step(62.,uv.y)*step(uv.x, 61.)*step(3.,uv.x)); \n\tcol = mix( col, mix( COL(152.,152.,152.), COL(124.,124.,124.), clamp(abs(32.-uv.x)/10.-2.25, 0., 1.)), step(uv.y, 61.)*step(61.,uv.y)*step(uv.x, 59.)*step(5.,uv.x)); \n\n\tcol = floor( (col)*32.)/32.;\n\tif( any(notEqual(col, vec3(floor((20./255.)*32.)/32.))) ) {\n\t\ticol = col;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n//----------------------------------------------------------------------\n// Proocedural MAP functions\n\nbool isWall( const vec2 vos ) {\n\treturn vos.y<0.4*ROOM_SIZE || vos.y>2.75*ROOM_SIZE || any( equal( mod( vos, vec2( ROOM_SIZE ) ), vec2(0.,0.) ) );\n}\nbool isDoor( const vec2 vos ) {\n\treturn isWall(vos) && ((hash(vos)>0.75 &&  any( equal( mod( vos, vec2( ROOM_SIZE*0.5 ) ), vec2(2.) ) )) \n\t\t    || any( equal( mod( vos, vec2( ROOM_SIZE ) ), vec2(ROOM_SIZE*0.5) ) )); \n}\nbool isObject( const vec2 vos ) {\n\treturn hash( vos*10. ) > 0.95;\n}\nbool map( const vec2 vos ) {\n\treturn isObject( vos ) || isWall( vos );\n}\n\n//----------------------------------------------------------------------\n// Render MAP functions\n\nbool intersectSprite( const vec3 ro, const vec3 rd, const vec3 vos, const vec3 nor, out vec2 uv ) {\n\tfloat dist, u;\n\tvec2 a = vos.xz + nor.zx*vec2(-0.5,0.5) + vec2(0.5, 0.5);\n\tvec2 b = vos.xz - nor.zx*vec2(-0.5,0.5) + vec2(0.5, 0.5);\n\tif( intersectSegment( ro, rd, a, b, dist, u) ) {\n\t\tuv.x = u; uv.y = 1.-(ro+dist*rd).y;\n\t\tif( sign(nor.x)<0. ) uv.x = 1.-uv.x;\n\t\treturn uv.y>0.&&uv.y<1.;\n\t}\n\treturn false;\n}\nint getMaterialId( const vec2 vos ) {\n\treturn int( mod( 521.21 * hash( floor((vos-vec2(0.5))/ROOM_SIZE )  ), float(NUM_MATERIALS)) );\n}\nbool getColorForPosition( const vec3 ro, const vec3 rd, const vec3 vos, const vec3 pos, const vec3 nor, inout vec3 col ) {\t\n\tvec2 uv;\n\n\tif( isWall( vos.xz ) ) {\n\t\tif( isDoor( vos.xz ) ) {\n\t\t\tif( intersectSprite( ro, rd, vos+nor*0.03, nor, uv ) ) {\n\t\t\t\t// open the door\n\t\t\t\tuv.x -= clamp( 2.-0.75*distance( ro.xz, vos.xz+vec2(0.5) ), 0., 1.);\n\t\t\t\tif( uv.x > 0. ) {\n\t\t\t\t\tgetMaterialColor( MATERIAL_DOOR, uv*64., 0., col );\n\t\t\t\t\treturn true;\n\t\t\t\t}\t\n\t\t\t}\t\n\t\t\treturn false;\n\t\t}\n\t\t// a wall is hit\n\t\tif( pos.y <= 1. && pos.y >= 0. ) {\n\t\t\tvec2 mpos = vec2( dot(vec3(-nor.z,0.0,nor.x),pos), -pos.y );\n    \t\tfloat sha = 0.6 + 0.4*abs(nor.z);\t\t\n\t\t\tgetMaterialColor( isDoor( vos.xz+nor.xz )?MATERIAL_DOORWAY:getMaterialId(vos.xz), mpos*64., hash( vos.xz ), col );\n\t\t\tcol *= sha;\n\t\t\treturn true;\n\t\t}\n\t\treturn true;\n\t}\n\tif( isObject( vos.xz ) && !isWall( vos.xz+vec2(1.,0.) ) && !isWall( vos.xz+vec2(-1.,0.) )\n\t    && !isWall( vos.xz+vec2(0.,-1.) ) && !isWall( vos.xz+vec2(0.,1.) ) &&\n\t    intersectSprite( ro, rd, vos, rdcenter, uv ) ) {\n\t\treturn getObjectColor( 0, uv*64., col );\n\t}\n\treturn false;\n}\n\nbool castRay( const vec3 ro, const vec3 rd, inout vec3 col ) {\n\tvec3 pos = floor(ro);\n\tvec3 ri = 1.0/rd;\n\tvec3 rs = sign(rd);\n\tvec3 dis = (pos-ro + 0.5 + rs*0.5) * ri;\n\t\n\tfloat res = 0.0;\n\tvec3 mm = vec3(0.0);\n\tbool hit = false;\n\t\n\tfor( int i=0; i<MAXSTEPS; i++ )\t{\n\t\tif( hit ) continue;\n\t\t\n\t\tmm = step(dis.xyz, dis.zyx);\n\t\tdis += mm * rs * ri;\n        pos += mm * rs;\n\t\t\n\t\tif( map(pos.xz) ) { \n\t\t\tvec3 mini = (pos-ro + 0.5 - 0.5*vec3(rs))*ri;\n\t\t\tfloat t = max ( mini.x, mini.z );\t\t\t\n\t\t\thit = getColorForPosition( ro, rd, pos, ro+rd*t, -mm*sign(rd), col );\n\t\t}\n\t}\n\treturn hit;\n}\n\n//----------------------------------------------------------------------\n// Some really ugly code\n\n#define CCOS(a) cos(clamp(a,0.,1.)*1.57079632679)\n#define CSIN(a) sin(clamp(a,0.,1.)*1.57079632679)\nvec3 path( const float t ) {\n\tfloat tmod = mod( t/SECONDS_IN_ROOM, 8. );\n\tfloat tfloor = floor( tmod );\n\t\n\tvec3 pos = vec3( 4.*ROOM_SIZE*floor(t/(SECONDS_IN_ROOM*8.))+0.5, 0.5, 0.5*ROOM_SIZE+0.5 );\t\n\treturn pos + ROOM_SIZE*vec3(\n\t\tclamp(tmod,0.,1.)+clamp(tmod-4.,0.,1.)+0.5*(2.+CSIN(tmod-1.)-CCOS(tmod-3.)+CSIN(tmod-5.)-CCOS(tmod-7.)), 0.,\n\t\tclamp(tmod-2.,0.,1.)-clamp(tmod-6.,0.,1.)+0.5*(-CCOS(tmod-1.)+CSIN(tmod-3.)+CCOS(tmod-5.)-CSIN(tmod-7.)) );\n}\n\n\n//----------------------------------------------------------------------\n// Main\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0*q;\n    p.x *= iResolution.x/ iResolution.y;\n\t\n\tvec3 ro = path( time );\n\tvec3 ta = path( time+0.1 );\n\t\n    rdcenter = rotate( normalize( ta - ro), 0.3*cos(time*0.75) );\n    vec3 uu = normalize(cross( vec3(0.,1.,0.), rdcenter ));\n    vec3 vv = normalize(cross(rdcenter,uu));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 2.5*rdcenter );\n\t\n\tvec3 col = rd.y>0.?vec3(56./255.):vec3(112./255.);\n\tcastRay( ro, rd, col );\n\t\t\n\tfragColor = vec4( col, 1.0 );\n}",
    "tags": [
      "procedural",
      "voxel",
      "textures",
      "wolfenstein"
    ],
    "author": "reinder",
    "views": 0,
    "likes": 274,
    "published": 3
  },
  {
    "id": "ll2GD3",
    "title": "Palettes",
    "description": "Cosine based palettes (faster than linear interpolation or triangle waves). \nMore info: [url]http://iquilezles.org/articles/palettes[/url]",
    "code": "// The MIT License\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org/\n// Copyright \u00a9 2015 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A simple anf really efficient way to create color variation.\n//\n// Short video about this method to make palettes:\n//\n//   https://www.youtube.com/shorts/TH3OTy5fTog\n//\n// and a longer article here:\n//\n//   https://iquilezles.org/articles/palettes for more information\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy;\n    \n    // animate\n    p.x += 0.01*iTime;\n    \n    // compute colors\n    vec3                col = pal( p.x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n    if( p.y>(1.0/7.0) ) col = pal( p.x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20) );\n    if( p.y>(2.0/7.0) ) col = pal( p.x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.3,0.20,0.20) );\n    if( p.y>(3.0/7.0) ) col = pal( p.x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30) );\n    if( p.y>(4.0/7.0) ) col = pal( p.x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,0.7,0.4),vec3(0.0,0.15,0.20) );\n    if( p.y>(5.0/7.0) ) col = pal( p.x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(2.0,1.0,0.0),vec3(0.5,0.20,0.25) );\n    if( p.y>(6.0/7.0) ) col = pal( p.x, vec3(0.8,0.5,0.4),vec3(0.2,0.4,0.2),vec3(2.0,1.0,1.0),vec3(0.0,0.25,0.25) );\n    \n\n    // band\n    float f = fract(p.y*7.0);\n    // borders\n    col *= smoothstep( 0.49, 0.47, abs(f-0.5) );\n    // shadowing\n    col *= 0.5 + 0.5*sqrt(4.0*f*(1.0-f));\n\n\tfragColor = vec4( col, 1.0 );\n}",
    "tags": [
      "2d",
      "color",
      "palettes"
    ],
    "author": "iq",
    "views": 0,
    "likes": 631,
    "published": 3
  },
  {
    "id": "ftSSRR",
    "title": "Pinku",
    "description": "FBM",
    "code": "float colormap_red(float x) {\n    if (x < 0.0) {\n        return 54.0 / 255.0;\n    } else if (x < 20049.0 / 82979.0) {\n        return (829.79 * x + 54.51) / 255.0;\n    } else {\n        return 1.0;\n    }\n}\n\nfloat colormap_green(float x) {\n    if (x < 20049.0 / 82979.0) {\n        return 0.0;\n    } else if (x < 327013.0 / 810990.0) {\n        return (8546482679670.0 / 10875673217.0 * x - 2064961390770.0 / 10875673217.0) / 255.0;\n    } else if (x <= 1.0) {\n        return (103806720.0 / 483977.0 * x + 19607415.0 / 483977.0) / 255.0;\n    } else {\n        return 1.0;\n    }\n}\n\nfloat colormap_blue(float x) {\n    if (x < 0.0) {\n        return 54.0 / 255.0;\n    } else if (x < 7249.0 / 82979.0) {\n        return (829.79 * x + 54.51) / 255.0;\n    } else if (x < 20049.0 / 82979.0) {\n        return 127.0 / 255.0;\n    } else if (x < 327013.0 / 810990.0) {\n        return (792.02249341361393720147485376583 * x - 64.364790735602331034989206222672) / 255.0;\n    } else {\n        return 1.0;\n    }\n}\n\nvec4 colormap(float x) {\n    return vec4(colormap_red(x), colormap_green(x), colormap_blue(x), 1.0);\n}\n\n\nfloat rand(vec2 n) { \n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n    vec2 ip = floor(p);\n    vec2 u = fract(p);\n    u = u*u*(3.0-2.0*u);\n\n    float res = mix(\n        mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n        mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n    return res*res;\n}\n\nconst mat2 mtx = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n\n    f += 0.500000*noise( p + iTime  ); p = mtx*p*2.02;\n    f += 0.031250*noise( p ); p = mtx*p*2.01;\n    f += 0.250000*noise( p ); p = mtx*p*2.03;\n    f += 0.125000*noise( p ); p = mtx*p*2.01;\n    f += 0.062500*noise( p ); p = mtx*p*2.04;\n    f += 0.015625*noise( p + sin(iTime) );\n\n    return f/0.96875;\n}\n\nfloat pattern( in vec2 p )\n{\n\treturn fbm( p + fbm( p + fbm( p ) ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x;\n\tfloat shade = pattern(uv);\n    fragColor = vec4(colormap(shade).rgb, shade);\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"My Shader 0\",\n\t\"description\": \"Lorem ipsum dolor\",\n\t\"model\": \"person\"\n}\n*/",
    "tags": [
      "cineshader"
    ],
    "author": "adamgoodapp",
    "views": 0,
    "likes": 129,
    "published": 3
  },
  {
    "id": "mtyGWy",
    "title": "Shader Art Coding Introduction",
    "description": "[url]https://youtu.be/f4s1h2YETNY[/url]",
    "code": "/* This animation is the material of my first youtube tutorial about creative \n   coding, which is a video in which I try to introduce programmers to GLSL \n   and to the wonderful world of shaders, while also trying to share my recent \n   passion for this community.\n                                       Video URL: https://youtu.be/f4s1h2YETNY\n*/\n\n//https://iquilezles.org/articles/palettes/\nvec3 palette( float t ) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263,0.416,0.557);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n//https://www.shadertoy.com/view/mtyGWy\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n    \n    for (float i = 0.0; i < 4.0; i++) {\n        uv = fract(uv * 1.5) - 0.5;\n\n        float d = length(uv) * exp(-length(uv0));\n\n        vec3 col = palette(length(uv0) + i*.4 + iTime*.4);\n\n        d = sin(d*8. + iTime)/8.;\n        d = abs(d);\n\n        d = pow(0.01 / d, 1.2);\n\n        finalColor += col * d;\n    }\n        \n    fragColor = vec4(finalColor, 1.0);\n}",
    "tags": [
      "fractal",
      "sdf",
      "tutorial",
      "intro",
      "repetition",
      "code",
      "youtube",
      "tuto",
      "creative"
    ],
    "author": "kishimisu",
    "views": 0,
    "likes": 1259,
    "published": 3
  },
  {
    "id": "4tjGRh",
    "title": "Planet Shadertoy",
    "description": "A seamless space-to-surface flight. This is a tribute to all the great shaders on Shadertoy! Use chrome without angle (or a Mac) and run this shader on med, or high settings (line 4 or 5) to get the full shader and the detail I was aiming for.",
    "code": "// Planet Shadertoy. Created by Reinder Nijhoff 2015\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n// @reindernijhoff\n//\n// https://www.shadertoy.com/view/4tjGRh\n//\n// It uses code from the following shaders:\n//\n// Wet stone by TDM\n// Atmospheric Scattering by GLtracy\n// Seascape by TDM\n// Elevated and Terrain Tubes by IQ\n// LLamels by Eiffie\n// Lens flare by Musk\n// \n\n//#define HIGH_QUALITY\n//#define MED_QUALITY\n//#define LOW_QUALITY\n#define VERY_LOW_QUALITY\n\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = (PI / 180.0);\nconst float MAX = 10000.0;\n\nconst float EARTH_RADIUS = 1000.;\nconst float EARTH_ATMOSPHERE = 5.;\nconst float EARTH_CLOUDS = 1.;\n\nconst float RING_INNER_RADIUS = 1500.;\nconst float RING_OUTER_RADIUS = 2300.;\nconst float RING_HEIGHT = 2.;\n\n#ifdef HIGH_QUALITY\n    const int   SEA_NUM_STEPS = 7;\n    const int\tTERRAIN_NUM_STEPS = 140;\n    const int   ASTEROID_NUM_STEPS = 11;\n\tconst int\tASTEROID_NUM_BOOL_SUB = 7;\n    const int   RING_VOXEL_STEPS = 25;\n    const float ASTEROID_MAX_DISTANCE = 1.1; \n\tconst int   FBM_STEPS = 4;\n    const int   ATMOSPHERE_NUM_OUT_SCATTER = 5;\n    const int   ATMOSPHERE_NUM_IN_SCATTER = 7;\n\n    #define DISPLAY_LLAMEL\n    #define DISPLAY_CLOUDS\n    #define DISPLAY_CLOUDS_DETAIL\n    #define DISPLAY_TERRAIN_DETAIL\n#endif\n\n#ifdef MED_QUALITY\n    const int   SEA_NUM_STEPS = 6;\n    const int\tTERRAIN_NUM_STEPS = 100;\n    const int   ASTEROID_NUM_STEPS = 10;\n\tconst int\tASTEROID_NUM_BOOL_SUB = 6;\n    const int   RING_VOXEL_STEPS = 24;\n    const float ASTEROID_MAX_DISTANCE = 1.; \n\tconst int   FBM_STEPS = 4;\n    const int   ATMOSPHERE_NUM_OUT_SCATTER = 4;\n    const int   ATMOSPHERE_NUM_IN_SCATTER = 6;\n    #define DISPLAY_CLOUDS\n    #define DISPLAY_TERRAIN_DETAIL\n    #define DISPLAY_CLOUDS_DETAIL\n#endif\n\n#ifdef LOW_QUALITY\n    const int   SEA_NUM_STEPS = 5;\n    const int\tTERRAIN_NUM_STEPS = 75;\n    const int   ASTEROID_NUM_STEPS = 9;\n\tconst int\tASTEROID_NUM_BOOL_SUB = 5;\n    const int   RING_VOXEL_STEPS = 20;\n    const float ASTEROID_MAX_DISTANCE = .85; \n\tconst int   FBM_STEPS = 3;\n    const int   ATMOSPHERE_NUM_OUT_SCATTER = 3;\n    const int   ATMOSPHERE_NUM_IN_SCATTER = 5;\n#endif\n\n#ifdef VERY_LOW_QUALITY\n    const int   SEA_NUM_STEPS = 4;\n    const int\tTERRAIN_NUM_STEPS = 60;\n    const int   ASTEROID_NUM_STEPS = 7;\n\tconst int\tASTEROID_NUM_BOOL_SUB = 4;\n    const int   RING_VOXEL_STEPS = 16;\n    const float ASTEROID_MAX_DISTANCE = .67; \n\tconst int   FBM_STEPS = 3;\n    const int   ATMOSPHERE_NUM_OUT_SCATTER = 2;\n    const int   ATMOSPHERE_NUM_IN_SCATTER = 4;\n\t#define HIDE_TERRAIN\n#endif\n\nconst vec3  SUN_DIRECTION = vec3( .940721,  .28221626, .18814417 );\nconst vec3  SUN_COLOR = vec3(.3, .21, .165);\n\nfloat time;\n\n//-----------------------------------------------------\n// Noise functions\n//-----------------------------------------------------\n\nfloat hash( const in float n ) {\n    return fract(sin(n)*43758.5453123);\n}\nfloat hash( const in vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\nfloat hash( const in vec3 p ) {\n\tfloat h = dot(p,vec3(127.1,311.7,758.5453123));\t\n    return fract(sin(h)*43758.5453123);\n}\nvec3 hash31( const in float p) {\n\tvec3 h = vec3(1275.231,4461.7,7182.423) * p;\t\n    return fract(sin(h)*43758.543123);\n}\nvec3 hash33( const in vec3 p) {\n    return vec3( hash(p), hash(p.zyx), hash(p.yxz) );\n}\n\nfloat noise( const in  float p ) {    \n    float i = floor( p );\n    float f = fract( p );\t\n\tfloat u = f*f*(3.0-2.0*f);\n    return -1.0+2.0* mix( hash( i + 0. ), hash( i + 1. ), u);\n}\n\nfloat noise( const in  vec2 p ) {    \n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\nfloat noise( const in  vec3 x ) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\nfloat tri( const in vec2 p ) {\n    return 0.5*(cos(6.2831*p.x) + cos(6.2831*p.y));\n   \n}\n\nconst mat2 m2 = mat2( 0.80, -0.60, 0.60, 0.80 );\n\nfloat fbm( in vec2 p ) {\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m2*p*2.02;\n    f += 0.2500*noise( p ); p = m2*p*2.03;\n    f += 0.1250*noise( p ); \n    \n#ifndef LOW_QUALITY\n#ifndef VERY_LOW_QUALITY\n    p = m2*p*2.01;\n    f += 0.0625*noise( p );\n#endif\n#endif\n    return f/0.9375;\n}\n\nfloat fbm( const in vec3 p, const in float a, const in float f) {\n    float ret = 0.0;    \n    float amp = 1.0;\n    float frq = 1.0;\n    for(int i = 0; i < FBM_STEPS; i++) {\n        float n = pow(noise(p * frq),2.0);\n        ret += n * amp;\n        frq *= f;\n        amp *= a * (pow(n,0.2));\n    }\n    return ret;\n}\n\n//-----------------------------------------------------\n// Lightning functions\n//-----------------------------------------------------\n\nfloat diffuse( const in vec3 n, const in vec3 l) { \n    return clamp(dot(n,l),0.,1.);\n}\n\nfloat specular( const in vec3 n, const in vec3 l, const in vec3 e, const in float s) {    \n    float nrm = (s + 8.0) / (3.1415 * 8.0);\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\n}\n\nfloat fresnel( const in vec3 n, const in vec3 e, float s ) {\n    return pow(clamp(1.-dot(n,e), 0., 1.),s);\n}\n\n//-----------------------------------------------------\n// Math functions\n//-----------------------------------------------------\n\nvec2 rotate(float angle, vec2 v) {\n    return vec2(cos(angle) * v.x + sin(angle) * v.y, cos(angle) * v.y - sin(angle) * v.x);\n}\n\nfloat boolSub(float a,float b) { \n    return max(a,-b); \n}\nfloat sphere(vec3 p,float r) {\n\treturn length(p)-r;\n}\n\n//-----------------------------------------------------\n// Intersection functions (by iq)\n//-----------------------------------------------------\n\nvec3 nSphere( in vec3 pos, in vec4 sph ) {\n    return (pos-sph.xyz)/sph.w;\n}\n\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sph ) {\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n\nfloat iCSphereF( vec3 p, vec3 dir, float r ) {\n\tfloat b = dot( p, dir );\n\tfloat c = dot( p, p ) - r * r;\n\tfloat d = b * b - c;\n\tif ( d < 0.0 ) return -MAX;\n\treturn -b + sqrt( d );\n}\n\nvec2 iCSphere2( vec3 p, vec3 dir, float r ) {\n\tfloat b = dot( p, dir );\n\tfloat c = dot( p, p ) - r * r;\n\tfloat d = b * b - c;\n\tif ( d < 0.0 ) return vec2( MAX, -MAX );\n\td = sqrt( d );\n\treturn vec2( -b - d, -b + d );\n}\n\nvec3 nPlane( in vec3 ro, in vec4 obj ) {\n    return obj.xyz;\n}\n\nfloat iPlane( in vec3 ro, in vec3 rd, in vec4 pla ) {\n    return (-pla.w - dot(pla.xyz,ro)) / dot( pla.xyz, rd );\n}\n\n//-----------------------------------------------------\n// Wet stone by TDM\n// \n// https://www.shadertoy.com/view/ldSSzV\n//-----------------------------------------------------\n\nconst float ASTEROID_TRESHOLD \t= 0.001;\nconst float ASTEROID_EPSILON \t= 1e-6;\nconst float ASTEROID_DISPLACEMENT = 0.1;\nconst float ASTEROID_RADIUS = 0.13;\n\nconst vec3  RING_COLOR_1 = vec3(0.42,0.3,0.2);\nconst vec3  RING_COLOR_2 = vec3(0.41,0.51,0.52);\n\nfloat asteroidRock( const in vec3 p, const in vec3 id ) {  \n    float d = sphere(p,ASTEROID_RADIUS);    \n    for(int i = 0; i < ASTEROID_NUM_BOOL_SUB; i++) {\n        float ii = float(i)+id.x;\n        float r = (ASTEROID_RADIUS*2.5) + ASTEROID_RADIUS*hash(ii);\n        vec3 v = normalize(hash31(ii) * 2.0 - 1.0);\n    \td = boolSub(d,sphere(p+v*r,r * 0.8));       \n    }\n    return d;\n}\n\nfloat asteroidMap( const in vec3 p, const in vec3 id) {\n    float d = asteroidRock(p, id) + noise(p*4.0) * ASTEROID_DISPLACEMENT;\n    return d;\n}\n\nfloat asteroidMapDetailed( const in vec3 p, const in vec3 id) {\n    float d = asteroidRock(p, id) + fbm(p*4.0,0.4,2.96) * ASTEROID_DISPLACEMENT;\n    return d;\n}\n\nvoid asteroidTransForm(inout vec3 ro, const in vec3 id ) {\n    float xyangle = (id.x-.5)*time*2.;\n    ro.xy = rotate( xyangle, ro.xy );\n    \n    float yzangle = (id.y-.5)*time*2.;\n    ro.yz = rotate( yzangle, ro.yz );\n}\n\nvoid asteroidUnTransForm(inout vec3 ro, const in vec3 id ) {\n    float yzangle = (id.y-.5)*time*2.;\n    ro.yz = rotate( -yzangle, ro.yz );\n\n    float xyangle = (id.x-.5)*time*2.;\n    ro.xy = rotate( -xyangle, ro.xy );  \n}\n\nvec3 asteroidGetNormal(vec3 p, vec3 id) {\n    asteroidTransForm( p, id );\n    \n    vec3 n;\n    n.x = asteroidMapDetailed(vec3(p.x+ASTEROID_EPSILON,p.y,p.z), id);\n    n.y = asteroidMapDetailed(vec3(p.x,p.y+ASTEROID_EPSILON,p.z), id);\n    n.z = asteroidMapDetailed(vec3(p.x,p.y,p.z+ASTEROID_EPSILON), id);\n    n = normalize(n-asteroidMapDetailed(p, id));\n    \n    asteroidUnTransForm( n, id );\n    return n;\n}\n\nvec2 asteroidSpheretracing(vec3 ori, vec3 dir, vec3 id) {\n    asteroidTransForm( ori, id );\n    asteroidTransForm( dir, id );\n    \n    vec2 td = vec2(0,1);\n    for(int i = 0; i < ASTEROID_NUM_STEPS && abs(td.y) > ASTEROID_TRESHOLD; i++) {\n        td.y = asteroidMap(ori + dir * td.x, id);\n        td.x += td.y;\n    }\n    return td;\n}\n\nvec3 asteroidGetStoneColor(vec3 p, float c, vec3 l, vec3 n, vec3 e) {\n\treturn mix( diffuse(n,l)*RING_COLOR_1*SUN_COLOR, SUN_COLOR*specular(n,l,e,3.0), .5*fresnel(n,e,5.));    \n}\n\n//-----------------------------------------------------\n// Ring (by me ;))\n//-----------------------------------------------------\n\nconst float RING_DETAIL_DISTANCE = 40.;\nconst float RING_VOXEL_STEP_SIZE = .03;\n\nvec3 ringShadowColor( const in vec3 ro ) {\n    if( iSphere( ro, SUN_DIRECTION, vec4( 0., 0., 0., EARTH_RADIUS ) ) > 0. ) {\n        return vec3(0.);\n    }\n    return vec3(1.);\n}\n\nbool ringMap( const in vec3 ro ) {\n    return ro.z < RING_HEIGHT/RING_VOXEL_STEP_SIZE && hash(ro)<.5;\n}\n\nvec4 renderRingNear( const in vec3 ro, const in vec3 rd ) { \n// find startpoint \n    float d1 = iPlane( ro, rd, vec4( 0., 0., 1., RING_HEIGHT ) );\n    float d2 = iPlane( ro, rd, vec4( 0., 0., 1., -RING_HEIGHT ) );\n    \n    float d = min( max(d1,0.), max(d2,0.) );\n   \n    if( (d1 < 0. && d2 < 0.) || d > ASTEROID_MAX_DISTANCE ) {\n        return vec4( 0. );\n    } else {\n        vec3 ros = ro + rd*d;\n\n        // avoid precision problems..\n        vec2 mroxy = mod(ros.xy, vec2(10.));\n        vec2 roxy = ros.xy - mroxy;\n        ros.xy -= roxy;\n        ros /= RING_VOXEL_STEP_SIZE;\n        //ros.xy -= vec2(.013,.112)*time*.5;\n\n        vec3 pos = floor(ros);\n        vec3 ri = 1.0/rd;\n        vec3 rs = sign(rd);\n        vec3 dis = (pos-ros + 0.5 + rs*0.5) * ri;\n\n        float alpha = 0., dint;\n        vec3 offset = vec3(0), id, asteroidro;\n        vec2 asteroid = vec2(0);\n\n        for( int i=0; i<RING_VOXEL_STEPS; i++ ) {\n            if( ringMap(pos) ) {\n                id = hash33(pos);\n                offset = id*(1.-2.*ASTEROID_RADIUS)+ASTEROID_RADIUS;\n                dint = iSphere( ros, rd, vec4(pos+offset, ASTEROID_RADIUS) );\n\n                if( dint > 0. ) {\n                    asteroidro = ros+rd*dint-(pos+offset);\n                    asteroid = asteroidSpheretracing( asteroidro, rd, id );\n\n                    if( asteroid.y < .1 ) {\n                        alpha = 1.;\n                        break;\t    \n                    }\n                }\n\n            }\n            vec3 mm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);\n            dis += mm * rs * ri;\n            pos += mm * rs;\n        }\n\n        if( alpha > 0. ) {       \n            vec3 intersection = ros + rd*(asteroid.x+dint);\n            vec3 n = asteroidGetNormal( asteroidro + rd*asteroid.x, id );\n\n            vec3 col = asteroidGetStoneColor(intersection, .1, SUN_DIRECTION, n, rd);\n\n            intersection *= RING_VOXEL_STEP_SIZE;\n            intersection.xy += roxy;\n          //  col *= ringShadowColor( intersection );\n\n            return vec4( col, 1.-smoothstep(0.4*ASTEROID_MAX_DISTANCE, 0.5* ASTEROID_MAX_DISTANCE, distance( intersection, ro ) ) );\n        } else {\n            return vec4(0.);\n        }\n    }\n}\n\n//-----------------------------------------------------\n// Ring (by me ;))\n//-----------------------------------------------------\n\nfloat renderRingFarShadow( const in vec3 ro, const in vec3 rd ) {\n    // intersect plane\n    float d = iPlane( ro, rd, vec4( 0., 0., 1., 0.) );\n    \n    if( d > 0. ) {\n\t    vec3 intersection = ro + rd*d;\n        float l = length(intersection.xy);\n        \n        if( l > RING_INNER_RADIUS && l < RING_OUTER_RADIUS ) {\n            return .5 + .5 * (.2+.8*noise( l*.07 )) * (.5+.5*noise(intersection.xy));\n        } else {\n            return 0.;\n        }\n    } else {\n\t    return 0.;\n    }\n}\n\nvec4 renderRingFar( const in vec3 ro, const in vec3 rd, inout float maxd ) {\n    // intersect plane\n    float d = iPlane( ro, rd, vec4( 0., 0., 1., 0.) );\n    \n    if( d > 0. && d < maxd ) {\n        maxd = d;\n\t    vec3 intersection = ro + rd*d;\n        float l = length(intersection.xy);\n        \n        if( l > RING_INNER_RADIUS && l < RING_OUTER_RADIUS ) {\n            float dens = .5 + .5 * (.2+.8*noise( l*.07 )) * (.5+.5*noise(intersection.xy));\n            vec3 col = mix( RING_COLOR_1, RING_COLOR_2, abs( noise(l*0.2) ) ) * abs(dens) * 1.5;\n            \n            col *= ringShadowColor( intersection );\n    \t\tcol *= .8+.3*diffuse( vec3(0,0,1), SUN_DIRECTION );\n\t\t\tcol *= SUN_COLOR;\n            return vec4( col, dens );\n        } else {\n            return vec4(0.);\n        }\n    } else {\n\t    return vec4(0.);\n    }\n}\n\nvec4 renderRing( const in vec3 ro, const in vec3 rd, inout float maxd ) {\n    vec4 far = renderRingFar( ro, rd, maxd );\n    float l = length( ro.xy );\n\n    if( abs(ro.z) < RING_HEIGHT+RING_DETAIL_DISTANCE \n        && l < RING_OUTER_RADIUS+RING_DETAIL_DISTANCE \n        && l > RING_INNER_RADIUS-RING_DETAIL_DISTANCE ) {\n     \t\n\t    float d = iPlane( ro, rd, vec4( 0., 0., 1., 0.) );\n        float detail = mix( .5 * noise( fract(ro.xy+rd.xy*d) * 92.1)+.25, 1., smoothstep( 0.,RING_DETAIL_DISTANCE, d) );\n        far.xyz *= detail;    \n    }\n    \n\t// are asteroids neaded ?\n    if( abs(ro.z) < RING_HEIGHT+ASTEROID_MAX_DISTANCE \n        && l < RING_OUTER_RADIUS+ASTEROID_MAX_DISTANCE \n        && l > RING_INNER_RADIUS-ASTEROID_MAX_DISTANCE ) {\n        \n        vec4 near = renderRingNear( ro, rd );\n        far = mix( far, near, near.w );\n        maxd=0.;\n    }\n            \n    return far;\n}\n\n//-----------------------------------------------------\n// Stars (by me ;))\n//-----------------------------------------------------\n\nvec4 renderStars( const in vec3 rd ) {\n\tvec3 rds = rd;\n\tvec3 col = vec3(0);\n    float v = 1.0/( 2. * ( 1. + rds.z ) );\n    \n    vec2 xy = vec2(rds.y * v, rds.x * v);\n    float s = noise(rds*134.);\n    \n    s += noise(rds*470.);\n    s = pow(s,19.0) * 0.00001;\n    if (s > 0.5) {\n        vec3 backStars = vec3(s)*.5 * vec3(0.95,0.8,0.9); \n        col += backStars;\n    }\n\treturn   vec4( col, 1 ); \n} \n\n//-----------------------------------------------------\n// Atmospheric Scattering by GLtracy\n// \n// https://www.shadertoy.com/view/lslXDr\n//-----------------------------------------------------\n\nconst float ATMOSPHERE_K_R = 0.166;\nconst float ATMOSPHERE_K_M = 0.0025;\nconst float ATMOSPHERE_E = 12.3;\nconst vec3  ATMOSPHERE_C_R = vec3( 0.3, 0.7, 1.0 );\nconst float ATMOSPHERE_G_M = -0.85;\n\nconst float ATMOSPHERE_SCALE_H = 4.0 / ( EARTH_ATMOSPHERE );\nconst float ATMOSPHERE_SCALE_L = 1.0 / ( EARTH_ATMOSPHERE );\n\nconst float ATMOSPHERE_FNUM_OUT_SCATTER = float(ATMOSPHERE_NUM_OUT_SCATTER);\nconst float ATMOSPHERE_FNUM_IN_SCATTER = float(ATMOSPHERE_NUM_IN_SCATTER);\n\nconst int   ATMOSPHERE_NUM_OUT_SCATTER_LOW = 2;\nconst int   ATMOSPHERE_NUM_IN_SCATTER_LOW = 4;\nconst float ATMOSPHERE_FNUM_OUT_SCATTER_LOW = float(ATMOSPHERE_NUM_OUT_SCATTER_LOW);\nconst float ATMOSPHERE_FNUM_IN_SCATTER_LOW = float(ATMOSPHERE_NUM_IN_SCATTER_LOW);\n\nfloat atmosphericPhaseMie( float g, float c, float cc ) {\n\tfloat gg = g * g;\n\tfloat a = ( 1.0 - gg ) * ( 1.0 + cc );\n\tfloat b = 1.0 + gg - 2.0 * g * c;\n    \n\tb *= sqrt( b );\n\tb *= 2.0 + gg;\t\n\t\n\treturn 1.5 * a / b;\n}\n\nfloat atmosphericPhaseReyleigh( float cc ) {\n\treturn 0.75 * ( 1.0 + cc );\n}\n\nfloat atmosphericDensity( vec3 p ){\n\treturn exp( -( length( p ) - EARTH_RADIUS ) * ATMOSPHERE_SCALE_H );\n}\n\nfloat atmosphericOptic( vec3 p, vec3 q ) {\n\tvec3 step = ( q - p ) / ATMOSPHERE_FNUM_OUT_SCATTER;\n\tvec3 v = p + step * 0.5;\n\t\n\tfloat sum = 0.0;\n\tfor ( int i = 0; i < ATMOSPHERE_NUM_OUT_SCATTER; i++ ) {\n\t\tsum += atmosphericDensity( v );\n\t\tv += step;\n\t}\n\tsum *= length( step ) * ATMOSPHERE_SCALE_L;\n\t\n\treturn sum;\n}\n\nvec4 atmosphericInScatter( vec3 o, vec3 dir, vec2 e, vec3 l ) {\n\tfloat len = ( e.y - e.x ) / ATMOSPHERE_FNUM_IN_SCATTER;\n\tvec3 step = dir * len;\n\tvec3 p = o + dir * e.x;\n\tvec3 v = p + dir * ( len * 0.5 );\n\n    float sumdensity = 0.;\n\tvec3 sum = vec3( 0.0 );\n\n    for ( int i = 0; i < ATMOSPHERE_NUM_IN_SCATTER; i++ ) {\n        vec3 u = v + l * iCSphereF( v, l, EARTH_RADIUS + EARTH_ATMOSPHERE );\n\t\tfloat n = ( atmosphericOptic( p, v ) + atmosphericOptic( v, u ) ) * ( PI * 4.0 );\n\t\tfloat dens = atmosphericDensity( v );\n  \n\t    float m = MAX;\n\t\tsum += dens * exp( -n * ( ATMOSPHERE_K_R * ATMOSPHERE_C_R + ATMOSPHERE_K_M ) ) \n    \t\t* (1. - renderRingFarShadow( u, SUN_DIRECTION ) );\n \t\tsumdensity += dens;\n        \n\t\tv += step;\n\t}\n\tsum *= len * ATMOSPHERE_SCALE_L;\n\t\n\tfloat c  = dot( dir, -l );\n\tfloat cc = c * c;\n\t\n\treturn vec4( sum * ( ATMOSPHERE_K_R * ATMOSPHERE_C_R * atmosphericPhaseReyleigh( cc ) + \n                         ATMOSPHERE_K_M * atmosphericPhaseMie( ATMOSPHERE_G_M, c, cc ) ) * ATMOSPHERE_E, \n                \t     clamp(sumdensity * len * ATMOSPHERE_SCALE_L,0.,1.));\n}\n\nfloat atmosphericOpticLow( vec3 p, vec3 q ) {\n\tvec3 step = ( q - p ) / ATMOSPHERE_FNUM_OUT_SCATTER_LOW;\n\tvec3 v = p + step * 0.5;\n\t\n\tfloat sum = 0.0;\n\tfor ( int i = 0; i < ATMOSPHERE_NUM_OUT_SCATTER_LOW; i++ ) {\n\t\tsum += atmosphericDensity( v );\n\t\tv += step;\n\t}\n\tsum *= length( step ) * ATMOSPHERE_SCALE_L;\n\t\n\treturn sum;\n}\n\nvec3 atmosphericInScatterLow( vec3 o, vec3 dir, vec2 e, vec3 l ) {\n\tfloat len = ( e.y - e.x ) / ATMOSPHERE_FNUM_IN_SCATTER_LOW;\n\tvec3 step = dir * len;\n\tvec3 p = o + dir * e.x;\n\tvec3 v = p + dir * ( len * 0.5 );\n\n\tvec3 sum = vec3( 0.0 );\n\n    for ( int i = 0; i < ATMOSPHERE_NUM_IN_SCATTER_LOW; i++ ) {\n\t\tvec3 u = v + l * iCSphereF( v, l, EARTH_RADIUS + EARTH_ATMOSPHERE );\n\t\tfloat n = ( atmosphericOpticLow( p, v ) + atmosphericOpticLow( v, u ) ) * ( PI * 4.0 );\n\t    float m = MAX;\n\t\tsum += atmosphericDensity( v ) * exp( -n * ( ATMOSPHERE_K_R * ATMOSPHERE_C_R + ATMOSPHERE_K_M ) );\n\t\tv += step;\n\t}\n\tsum *= len * ATMOSPHERE_SCALE_L;\n\t\n\tfloat c  = dot( dir, -l );\n\tfloat cc = c * c;\n\t\n\treturn sum * ( ATMOSPHERE_K_R * ATMOSPHERE_C_R * atmosphericPhaseReyleigh( cc ) + \n                   ATMOSPHERE_K_M * atmosphericPhaseMie( ATMOSPHERE_G_M, c, cc ) ) * ATMOSPHERE_E;\n}\n\nvec4 renderAtmospheric( const in vec3 ro, const in vec3 rd, inout float d ) {    \n    // inside or outside atmosphere?\n    vec2 e = iCSphere2( ro, rd, EARTH_RADIUS + EARTH_ATMOSPHERE );\n\tvec2 f = iCSphere2( ro, rd, EARTH_RADIUS );\n        \n    if( length(ro) <= EARTH_RADIUS + EARTH_ATMOSPHERE ) {\n        if( d < e.y ) {\n            e.y = d;\n        }\n\t\td = e.y;\n\t    e.x = 0.;\n        \n\t    if ( iSphere( ro, rd, vec4(0,0,0,EARTH_RADIUS)) > 0. ) {\n\t        d = iSphere( ro, rd, vec4(0,0,0,EARTH_RADIUS));\n\t\t}\n    } else {\n    \tif(  iSphere( ro, rd, vec4(0,0,0,EARTH_RADIUS + EARTH_ATMOSPHERE )) < 0. ) return vec4(0.);\n        \n        if ( e.x > e.y ) {\n        \td = MAX;\n\t\t\treturn vec4(0.);\n\t\t}\n\t\td = e.y = min( e.y, f.x );\n    }\n\treturn atmosphericInScatter( ro, rd, e, SUN_DIRECTION );\n}\n\nvec3 renderAtmosphericLow( const in vec3 ro, const in vec3 rd ) {    \n    vec2 e = iCSphere2( ro, rd, EARTH_RADIUS + EARTH_ATMOSPHERE );\n    e.x = 0.;\n    return atmosphericInScatterLow( ro, rd, e, SUN_DIRECTION );\n}\n\n//-----------------------------------------------------\n// Seascape by TDM\n// \n// https://www.shadertoy.com/view/Ms2SD1\n//-----------------------------------------------------\n\nconst int   SEA_ITER_GEOMETRY = 3;\nconst int   SEA_ITER_FRAGMENT = 5;\n\nconst float SEA_EPSILON\t= 1e-3;\n#define       SEA_EPSILON_NRM\t(0.1 / iResolution.x)\nconst float SEA_HEIGHT = 0.6;\nconst float SEA_CHOPPY = 4.0;\nconst float SEA_SPEED = 0.8;\nconst float SEA_FREQ = 0.16;\nconst vec3  SEA_BASE = vec3(0.1,0.19,0.22);\nconst vec3  SEA_WATER_COLOR = vec3(0.8,0.9,0.6);\nfloat       SEA_TIME;\nconst mat2  sea_octave_m = mat2(1.6,1.2,-1.2,1.6);\n\nfloat seaOctave( in vec2 uv, const in float choppy) {\n    uv += noise(uv);        \n    vec2 wv = 1.0-abs(sin(uv));\n    vec2 swv = abs(cos(uv));    \n    wv = mix(wv,swv,wv);\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\n}\n\nfloat seaMap(const in vec3 p) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    \n    float d, h = 0.0;    \n    for(int i = 0; i < SEA_ITER_GEOMETRY; i++) {        \n    \td = seaOctave((uv+SEA_TIME)*freq,choppy);\n    \td += seaOctave((uv-SEA_TIME)*freq,choppy);\n        h += d * amp;        \n    \tuv *= sea_octave_m; freq *= 1.9; amp *= 0.22;\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\nfloat seaMapHigh(const in vec3 p) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    \n    float d, h = 0.0;    \n    for(int i = 0; i < SEA_ITER_FRAGMENT; i++) {        \n    \td = seaOctave((uv+SEA_TIME)*freq,choppy);\n    \td += seaOctave((uv-SEA_TIME)*freq,choppy);\n        h += d * amp;        \n    \tuv *= sea_octave_m; freq *= 1.9; amp *= 0.22;\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\nvec3 seaGetColor( const in vec3 n, vec3 eye, const in vec3 l, const in float att, \n                  const in vec3 sunc, const in vec3 upc, const in vec3 reflected) {  \n    vec3 refracted = SEA_BASE * upc + diffuse(n,l) * SEA_WATER_COLOR * 0.12 * sunc; \n    vec3 color = mix(refracted,reflected,fresnel(n, -eye, 3.)*.65 );\n    \n    color += upc*SEA_WATER_COLOR * (att * 0.18);\n    color += sunc * vec3(specular(n,l,eye,60.0));\n    \n    return color;\n}\n\nvec3 seaGetNormal(const in vec3 p, const in float eps) {\n    vec3 n;\n    n.y = seaMapHigh(p);    \n    n.x = seaMapHigh(vec3(p.x+eps,p.y,p.z)) - n.y;\n    n.z = seaMapHigh(vec3(p.x,p.y,p.z+eps)) - n.y;\n    n.y = eps;\n    return normalize(n);\n}\n\nfloat seaHeightMapTracing(const in vec3 ori, const in vec3 dir, out vec3 p) {  \n    float tm = 0.0;\n    float tx = 1000.0;    \n    float hx = seaMap(ori + dir * tx);\n    if(hx > 0.0) return tx;   \n    float hm = seaMap(ori + dir * tm);    \n    float tmid = 0.0;\n    for(int i = 0; i < SEA_NUM_STEPS; i++) {\n        tmid = mix(tm,tx, hm/(hm-hx));                   \n        p = ori + dir * tmid;                   \n    \tfloat hmid = seaMap(p);\n\t\tif(hmid < 0.0) {\n        \ttx = tmid;\n            hx = hmid;\n        } else {\n            tm = tmid;\n            hm = hmid;\n        }\n    }\n    return tmid;\n}\n\nvec3 seaTransform( in vec3 x ) {\n    x.yz = rotate( 0.8, x.yz );\n    return x;\n}\n\nvec3 seaUntransform( in vec3 x ) {\n    x.yz = rotate( -0.8, x.yz );\n    return x;\n}\n\nvoid renderSea( const in vec3 ro, const in vec3 rd, inout vec3 n, inout float att ) {    \n    vec3 p,\n    rom = seaTransform(ro),\n    rdm = seaTransform(rd);\n    \n    rom.y -= EARTH_RADIUS;\n    rom *= 1000.;\n    rom.xz += vec2(3.1,.2)*time;\n\n    SEA_TIME = time * SEA_SPEED;\n    \n    seaHeightMapTracing(rom,rdm,p);\n    float squareddist = dot(p - rom, p-rom );\n    n = seaGetNormal(p, squareddist * SEA_EPSILON_NRM );\n    \n    n = seaUntransform(n);\n    \n    att = clamp(SEA_HEIGHT+p.y, 0.,1.);\n}\n\n//-----------------------------------------------------\n// Terrain based on Elevated and Terrain Tubes by IQ\n//\n// https://www.shadertoy.com/view/MdX3Rr\n// https://www.shadertoy.com/view/4sjXzG\n//-----------------------------------------------------\n\n#ifndef HIDE_TERRAIN\n\nconst mat2 terrainM2 = mat2(1.6,-1.2,1.2,1.6);\n\nfloat terrainLow( vec2 p ) {\n    p *= 0.0013;\n\n    float s = 1.0;\n\tfloat t = 0.0;\n\tfor( int i=0; i<2; i++ ) {\n        t += s*tri( p );\n\t\ts *= 0.5 + 0.1*t;\n        p = 0.97*terrainM2*p + (t-0.5)*0.12;\n\t}\n\treturn t*33.0;\n}\n\nfloat terrainMed( vec2 p ) {\n    p *= 0.0013;\n\n    float s = 1.0;\n\tfloat t = 0.0;\n\tfor( int i=0; i<6; i++ ) {\n        t += s*tri( p );\n\t\ts *= 0.5 + 0.1*t;\n        p = 0.97*terrainM2*p + (t-0.5)*0.12;\n\t}\n            \n    return t*33.0;\n}\n\nfloat terrainHigh( vec2 p ) {\n    vec2 q = p;\n    p *= 0.0013;\n\n    float s = 1.0;\n\tfloat t = 0.0;\n\tfor( int i=0; i<7; i++ ) {\n        t += s*tri( p );\n\t\ts *= 0.5 + 0.1*t;\n        p = 0.97*terrainM2*p + (t-0.5)*0.12;\n\t}\n    \n    t += t*0.015*fbm( q );\n\treturn t*33.0;\n}\n\nfloat terrainMap( const in vec3 pos ) {\n\treturn pos.y - terrainMed(pos.xz);  \n}\n\nfloat terrainMapH( const in vec3 pos ) {\n    float y = terrainHigh(pos.xz);\n    float h = pos.y - y;\n    return h;\n}\n\nfloat terrainIntersect( in vec3 ro, in vec3 rd, in float tmin, in float tmax ) {\n    float t = tmin;\n\tfor( int i=0; i<TERRAIN_NUM_STEPS; i++ ) {\n        vec3 pos = ro + t*rd;\n        float res = terrainMap( pos );\n        if( res<(0.001*t) || t>tmax  ) break;\n        t += res*.9;\n\t}\n\n\treturn t;\n}\n\nfloat terrainCalcShadow(in vec3 ro, in vec3 rd ) {\n\tvec2  eps = vec2(150.0,0.0);\n    float h1 = terrainMed( ro.xz );\n    float h2 = terrainLow( ro.xz );\n    \n    float d1 = 10.0;\n    float d2 = 80.0;\n    float d3 = 200.0;\n    float s1 = clamp( 1.0*(h1 + rd.y*d1 - terrainMed(ro.xz + d1*rd.xz)), 0.0, 1.0 );\n    float s2 = clamp( 0.5*(h1 + rd.y*d2 - terrainMed(ro.xz + d2*rd.xz)), 0.0, 1.0 );\n    float s3 = clamp( 0.2*(h2 + rd.y*d3 - terrainLow(ro.xz + d3*rd.xz)), 0.0, 1.0 );\n\n    return min(min(s1,s2),s3);\n}\nvec3 terrainCalcNormalHigh( in vec3 pos, float t ) {\n    vec2 e = vec2(1.0,-1.0)*0.001*t;\n\n    return normalize( e.xyy*terrainMapH( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*terrainMapH( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*terrainMapH( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*terrainMapH( pos + e.xxx ) );\n}\n\nvec3 terrainCalcNormalMed( in vec3 pos, float t ) {\n\tfloat e = 0.005*t;\n    vec2  eps = vec2(e,0.0);\n    float h = terrainMed( pos.xz );\n    return normalize(vec3( terrainMed(pos.xz-eps.xy)-h, e, terrainMed(pos.xz-eps.yx)-h ));\n}\n\nvec3 terrainTransform( in vec3 x ) {\n    x.zy = rotate( -.83, x.zy );\n    return x;\n}\n\nvec3 terrainUntransform( in vec3 x ) {\n    x.zy = rotate( .83, x.zy );\n    return x;\n}\n\n\nfloat llamelTime;\nconst float llamelScale = 5.;\n\nvec3 llamelPosition() {\n    llamelTime = time*2.5;\n    vec2 pos = vec2( -400., 135.-llamelTime*0.075* llamelScale);\n    return vec3( pos.x, terrainMed( pos ), pos.y );\n}\n\nvec3 terrainShade( const in vec3 col, const in vec3 pos, const in vec3 rd, const in vec3 n, const in float spec, \n                   const in vec3 sunc, const in vec3 upc, const in vec3 reflc ) {\n\tvec3 sunDirection =  terrainTransform(SUN_DIRECTION);\n    float dif = diffuse( n, sunDirection );\n    float bac = diffuse( n, vec3(-sunDirection.x, sunDirection.y, -sunDirection.z) );\n    float sha = terrainCalcShadow( pos, sunDirection );\n    float amb = clamp( n.y,0.0,1.0);\n        \n    vec3 lin  = vec3(0.0);\n    lin += 2.*dif*sunc*vec3( sha, sha*sha*0.1+0.9*sha, sha*sha*0.2+0.8*sha );\n    lin += 0.2*amb*upc;\n    lin += 0.08*bac*clamp(vec3(1.)-sunc, vec3(0.), vec3(1.));\n    return mix( col*lin*3., reflc, spec*fresnel(n,-terrainTransform(rd),5.0) );\n}\n\nvec3 terrainGetColor( const in vec3 pos, const in vec3 rd, const in float t, const in vec3 sunc, const in vec3 upc, const in vec3 reflc ) {\n    vec3 nor = terrainCalcNormalHigh( pos, t );\n    vec3 sor = terrainCalcNormalMed( pos, t );\n        \n    float spec = 0.005;\n\n#ifdef DISPLAY_TERRAIN_DETAIL\n    float no = noise(5.*fbm(1.11*pos.xz));\n#else\n    const float no = 0.;\n#endif\n    float r = .5+.5*fbm(.95*pos.xz);\n\tvec3 col = (r*0.25+0.75)*0.9*mix( vec3(0.08,0.07,0.07), vec3(0.10,0.09,0.08), noise(0.4267*vec2(pos.x*2.,pos.y*9.8))+.01*no );\n    col = mix( col, 0.20*vec3(0.45,.30,0.15)*(0.50+0.50*r),smoothstep(0.825,0.925,nor.y+.025*no) );\n\tcol = mix( col, 0.15*vec3(0.30,.30,0.10)*(0.25+0.75*r),smoothstep(0.95,1.0,nor.y+.025*no) );\n    col *= .88+.12*no;\n        \n    float s = nor.y + 0.03*pos.y + 0.35*fbm(0.05*pos.xz) - .35;\n    float sf = fwidth(s) * 1.5;\n    s = smoothstep(0.84-sf, 0.84+sf, s );\n    col = mix( col, 0.29*vec3(0.62,0.65,0.7), s);\n    nor = mix( nor, sor, 0.7*smoothstep(0.9, 0.95, s ) );\n    spec = mix( spec, 0.45, smoothstep(0.9, 0.95, s ) );\n\n   \tcol = terrainShade( col, pos, rd, nor, spec, sunc, upc, reflc );\n\n#ifdef DISPLAY_LLAMEL\n    col *= clamp( distance(pos.xz, llamelPosition().xz )*0.4, 0.4, 1.);\n#endif\n    \n    return col;\n}\n\nvec3 terrainTransformRo( const in vec3 ro ) {\n    vec3 rom = terrainTransform(ro);\n    rom.y -= EARTH_RADIUS - 100.;\n    rom.xz *= 5.;\n    rom.xz += vec2(-170.,50.)+vec2(-4.,.4)*time;    \n    rom.y += (terrainLow( rom.xz ) - 86.)*clamp( 1.-1.*(length(ro)-EARTH_RADIUS), 0., 1.);\n    return rom;\n}\n\nvec4 renderTerrain( const in vec3 ro, const in vec3 rd, inout vec3 intersection, inout vec3 n ) {    \n    vec3 p,\n    rom = terrainTransformRo(ro),\n    rdm = terrainTransform(rd);\n        \n    float tmin = 10.0;\n    float tmax = 3200.0;\n    \n    float res = terrainIntersect( rom, rdm, tmin, tmax );\n    \n    if( res > tmax ) {\n        res = -1.;\n    } else {\n        vec3 pos =  rom+rdm*res;\n        n = terrainCalcNormalMed( pos, res );\n        n = terrainUntransform( n );\n        \n        intersection = ro+rd*res/100.;\n    }\n    return vec4(res, rom+rdm*res);\n}\n\n#endif\n\n//-----------------------------------------------------\n// LLamels by Eiffie\n//\n// https://www.shadertoy.com/view/ltsGz4\n//-----------------------------------------------------\n#ifdef DISPLAY_LLAMEL\nfloat llamelMapSMin(const in float a,const in float b,const in float k){\n    float h=clamp(0.5+0.5*(b-a)/k,0.0,1.0);return b+h*(a-b-k+k*h);\n}\n\nfloat llamelMapLeg(vec3 p, vec3 j0, vec3 j3, vec3 l, vec4 r, vec3 rt){//z joint with tapered legs\n\tfloat lx2z=l.x/(l.x+l.z),h=l.y*lx2z;\n\tvec3 u=(j3-j0)*lx2z,q=u*(0.5+0.5*(l.x*l.x-h*h)/dot(u,u));\n\tq+=sqrt(max(0.0,l.x*l.x-dot(q,q)))*normalize(cross(u,rt));\n\tvec3 j1=j0+q,j2=j3-q*(1.0-lx2z)/lx2z;\n\tu=p-j0;q=j1-j0;\n\th=clamp(dot(u,q)/dot(q,q),0.0,1.0);\n\tfloat d=length(u-q*h)-r.x-(r.y-r.x)*h;\n\tu=p-j1;q=j2-j1;\n\th=clamp(dot(u,q)/dot(q,q),0.0,1.0);\n\td=min(d,length(u-q*h)-r.y-(r.z-r.y)*h);\n\tu=p-j2;q=j3-j2;\n\th=clamp(dot(u,q)/dot(q,q),0.0,1.0);\n\treturn min(d,length(u-q*h)-r.z-(r.w-r.z)*h);\n}\n\nfloat llamelMap(in vec3 p) {\n\tconst vec3 rt=vec3(0.0,0.0,1.0);\t\n\tp.y += 0.25*llamelScale;\n    p.xz -= 0.5*llamelScale;\n    p.xz = vec2(-p.z, p.x);\n    vec3 pori = p;\n        \n    p /= llamelScale;\n    \n\tvec2 c=floor(p.xz);\n\tp.xz=fract(p.xz)-vec2(0.5);\n    p.y -= p.x*.04*llamelScale;\n\tfloat sa=sin(c.x*2.0+c.y*4.5+llamelTime*0.05)*0.15;\n\n    float b=0.83-abs(p.z);\n\tfloat a=c.x+117.0*c.y+sign(p.x)*1.57+sign(p.z)*1.57+llamelTime,ca=cos(a);\n\tvec3 j0=vec3(sign(p.x)*0.125,ca*0.01,sign(p.z)*0.05),j3=vec3(j0.x+sin(a)*0.1,max(-0.25+ca*0.1,-0.25),j0.z);\n\tfloat dL=llamelMapLeg(p,j0,j3,vec3(0.08,0.075,0.12),vec4(0.03,0.02,0.015,0.01),rt*sign(p.x));\n\tp.y-=0.03;\n\tfloat dB=(length(p.xyz*vec3(1.0,1.75,1.75))-0.14)*0.75;\n\ta=c.x+117.0*c.y+llamelTime;ca=cos(a);sa*=0.4;\n\tj0=vec3(0.125,0.03+abs(ca)*0.03,ca*0.01),j3=vec3(0.3,0.07+ca*sa,sa);\n\tfloat dH=llamelMapLeg(p,j0,j3,vec3(0.075,0.075,0.06),vec4(0.03,0.035,0.03,0.01),rt);\n\tdB=llamelMapSMin(min(dL,dH),dB,clamp(0.04+p.y,0.0,1.0));\n\ta=max(abs(p.z),p.y)+0.05;\n\treturn max(min(dB,min(a,b)),length(pori.xz-vec2(0.5)*llamelScale)-.5*llamelScale);\n}\n\nvec3 llamelGetNormal( in vec3 ro ) {\n    vec2 e = vec2(1.0,-1.0)*0.001;\n\n    return normalize( e.xyy*llamelMap( ro + e.xyy ) + \n\t\t\t\t\t  e.yyx*llamelMap( ro + e.yyx ) + \n\t\t\t\t\t  e.yxy*llamelMap( ro + e.yxy ) + \n\t\t\t\t\t  e.xxx*llamelMap( ro + e.xxx ) );\n}\n\nvec4 renderLlamel( in vec3 ro, const in vec3 rd, const in vec3 sunc, const in vec3 upc, const in vec3 reflc ) {\n    ro -= llamelPosition();\n\tfloat t=.1*hash(rd.xy),d,dm=10.0,tm;\n\tfor(int i=0;i<36;i++){\n\t\tt+=d=llamelMap(ro+rd*t);\n\t\tif(d<dm){dm=d;tm=t;}\n\t\tif(t>1000.0 || d<0.00001)break;\n\t}\n\tdm=max(0.0,dm);\n    if( dm < .02 ) {\n        vec3 col = vec3(0.45,.30,0.15)*.2;\n        vec3 pos = ro + rd*tm;\n        vec3 nor = llamelGetNormal( pos );\n        col = terrainShade( col, pos, rd, nor, .01, sunc, upc, reflc );        \n        return vec4(col, clamp( 1.-(dm-0.01)/0.01,0., 1.) );\n    }\n    \n    return vec4(0.);\n}\n#endif\n\n//-----------------------------------------------------\n// Clouds (by me ;))\n//-----------------------------------------------------\n\nvec4 renderClouds( const in vec3 ro, const in vec3 rd, const in float d, const in vec3 n, const in float land, \n                   const in vec3 sunColor, const in vec3 upColor, inout float shadow ) {\n\tvec3 intersection = ro+rd*d;\n    vec3 cint = intersection*0.009;\n    float rot = -.2*length(cint.xy) + .6*fbm( cint*.4,0.5,2.96 ) + .05*land;\n\n    cint.xy = rotate( rot, cint.xy );\n\n    vec3 cdetail = mod(intersection*3.23,vec3(50.));\n    cdetail.xy = rotate( .25*rot, cdetail.xy );\n\n    float clouds = 1.3*(fbm( cint*(1.+.02*noise(intersection)),0.5,2.96)+.4*land-.3);\n\n#ifdef DISPLAY_CLOUDS_DETAIL\n    if( d < 200. ) {\n        clouds += .3*(fbm(cdetail,0.5,2.96)-.5)*(1.-smoothstep(0.,200.,d));\n    }\n#endif\n\n    shadow = clamp(1.-clouds, 0., 1.);\n\n    clouds = clamp(clouds, 0., 1.);\n    clouds *= clouds;\n    clouds *= smoothstep(0.,0.4,d);\n\n    vec3 clbasecolor = vec3(1.);\n    vec3 clcol = .1*clbasecolor*sunColor * vec3(specular(n,SUN_DIRECTION,rd,36.0));\n    clcol += .3*clbasecolor*sunColor;\n    clcol += clbasecolor*(diffuse(n,SUN_DIRECTION)*sunColor+upColor);  \n    \n    return vec4( clcol, clouds );\n}\n\n//-----------------------------------------------------\n// Planet (by me ;))\n//-----------------------------------------------------\n\nvec4 renderPlanet( const in vec3 ro, const in vec3 rd, const in vec3 up, inout float maxd ) {\n    float d = iSphere( ro, rd, vec4( 0., 0., 0., EARTH_RADIUS ) );\n\n    vec3 intersection = ro + rd*d;\n    vec3 n = nSphere( intersection, vec4( 0., 0., 0., EARTH_RADIUS ) );\n    vec4 res;\n\n#ifndef HIDE_TERRAIN\n    bool renderTerrainDetail = length(ro) < EARTH_RADIUS+EARTH_ATMOSPHERE && \n        \t\t\t\t\t   dot( terrainUntransform( vec3(0.,1.,0.) ), normalize(ro) ) > .9996;\n#endif\n    bool renderSeaDetail     = d < 1. && dot( seaUntransform( vec3(0.,1.,0.) ), normalize(ro) ) > .9999; \n    float mixDetailColor = 0.;\n        \n\tif( d < 0. || d > maxd) {\n#ifndef HIDE_TERRAIN\n        if( renderTerrainDetail ) {\n       \t\tintersection = ro;\n            n = normalize( ro );\n        } else { \t       \n\t        return vec4(0);\n        }\n#else \n      \treturn vec4(0.);\n#endif\n\t}\n    if( d > 0. ) {\n\t    maxd = d;\n    }\n    float att = 0.;\n    \n    if( dot(n,SUN_DIRECTION) < -0.1 ) return vec4( 0., 0., 0., 1. );\n    \n    float dm = MAX, e = 0.;\n    vec3 col, detailCol, nDetail;\n    \n    // normal and intersection \n#ifndef HIDE_TERRAIN\n    if( renderTerrainDetail ) {   \n        res = renderTerrain( ro, rd, intersection, nDetail );\n        if( res.x < 0. && d < 0. ) {\n\t        return vec4(0);\n        }\n        if( res.x >= 0. ) {\n            maxd = pow(res.x/4000.,4.)*50.;\n            e = -10.;\n        }\n        mixDetailColor = 1.-smoothstep(.75, 1., (length(ro)-EARTH_RADIUS) / EARTH_ATMOSPHERE);\n        n = normalize( mix( n, nDetail, mixDetailColor ) );\n    } else \n#endif        \n    if( renderSeaDetail ) {    \n        float attsea, mf = smoothstep(.5,1.,d);\n\n        renderSea( ro, rd, nDetail, attsea );\n\n        n = normalize(mix( nDetail, n, mf ));\n        att = mix( attsea, att, mf );\n    } else {\n        e = fbm( .003*intersection+vec3(1.),0.4,2.96) + smoothstep(.85,.95, abs(intersection.z/EARTH_RADIUS));\n#ifndef HIDE_TERRAIN\n        if( d < 1500. ) {\n            e += (-.03+.06* fbm( intersection*0.1,0.4,2.96))*(1.-d/1500.);\n        }\n#endif  \n    }\n    \n    vec3 sunColor = .25*renderAtmosphericLow( intersection, SUN_DIRECTION).xyz;  \n    vec3 upColor = 2.*renderAtmosphericLow( intersection, n).xyz;  \n    vec3 reflColor = renderAtmosphericLow( intersection, reflect(rd,n)).xyz; \n                 \n    // color  \n#ifndef HIDE_TERRAIN\n    if(renderTerrainDetail ) {\n        detailCol = col =  terrainGetColor(res.yzw, rd, res.x, sunColor, upColor, reflColor);\n\t\td = 0.;\n    }   \n#endif\n     \n    if( mixDetailColor < 1. ) {\n        if( e < .45 ) {\n            // sea\n            col = seaGetColor(n,rd,SUN_DIRECTION, att, sunColor, upColor, reflColor);    \n        } else {\n            // planet (land) far\n            float land1 = max(0.1, fbm( intersection*0.0013,0.4,2.96) );\n            float land2 = max(0.1, fbm( intersection*0.0063,0.4,2.96) );\n            float iceFactor = abs(pow(intersection.z/EARTH_RADIUS,13.0))*e;\n\n            vec3 landColor1 = vec3(0.43,0.65,0.1) * land1;\n            vec3 landColor2 = RING_COLOR_1 * land2;\n            vec3 mixedLand = (landColor1 + landColor2)* 0.5;\n            vec3 finalLand = mix(mixedLand, vec3(7.0, 7.0, 7.0) * land1 * 1.5, max(iceFactor+.02*land2-.02, 0.));\n\n            col = (diffuse(n,SUN_DIRECTION)*sunColor+upColor)*finalLand*.75;\n#ifdef HIGH_QUALITY\n            col *= (.5+.5*fbm( intersection*0.23,0.4,2.96) );\n#endif\n        }\n    }\n    \n    if( mixDetailColor > 0. ) {\n        col = mix( col, detailCol, mixDetailColor );\n    }\n        \n#ifdef DISPLAY_LLAMEL\n    if(renderTerrainDetail ) {\n        vec3 rom = terrainTransformRo(ro),\n        rdm = terrainTransform(rd);\n        d = iSphere( rom, rdm, vec4( llamelPosition(), llamelScale*3. ) );\n        if( d > 0. ) {\n            vec4 llamel = renderLlamel( rom+rdm*d, rdm, sunColor, upColor, reflColor );\n            col = mix(col, llamel.rgb, llamel.a);\n        }\n    }\n#endif\n    \n    d = iSphere( ro, rd, vec4( 0., 0., 0., EARTH_RADIUS+EARTH_CLOUDS ) );\n    if( d > 0. ) { \n        float shadow;\n\t\tvec4 clouds = renderClouds( ro, rd, d, n, e, sunColor, upColor, shadow);\n        col *= shadow; \n        col = mix( col, clouds.rgb, clouds.w );\n    }\n    \n    float m = MAX;\n    col *= (1. - renderRingFarShadow( ro+rd*d, SUN_DIRECTION ) );\n\n \treturn vec4( col, 1. ); \n}\n\n//-----------------------------------------------------\n// Lens flare by musk\n//\n// https://www.shadertoy.com/view/4sX3Rs\n//-----------------------------------------------------\n\nvec3 lensFlare( const in vec2 uv, const in vec2 pos) {\n\tvec2 main = uv-pos;\n\tvec2 uvd = uv*(length(uv));\n\t\n\tfloat f0 = 1.5/(length(uv-pos)*16.0+1.0);\n\t\n\tfloat f1 = max(0.01-pow(length(uv+1.2*pos),1.9),.0)*7.0;\n\n\tfloat f2 = max(1.0/(1.0+32.0*pow(length(uvd+0.8*pos),2.0)),.0)*00.25;\n\tfloat f22 = max(1.0/(1.0+32.0*pow(length(uvd+0.85*pos),2.0)),.0)*00.23;\n\tfloat f23 = max(1.0/(1.0+32.0*pow(length(uvd+0.9*pos),2.0)),.0)*00.21;\n\t\n\tvec2 uvx = mix(uv,uvd,-0.5);\n\t\n\tfloat f4 = max(0.01-pow(length(uvx+0.4*pos),2.4),.0)*6.0;\n\tfloat f42 = max(0.01-pow(length(uvx+0.45*pos),2.4),.0)*5.0;\n\tfloat f43 = max(0.01-pow(length(uvx+0.5*pos),2.4),.0)*3.0;\n\t\n\tvec3 c = vec3(.0);\n\t\n\tc.r+=f2+f4; c.g+=f22+f42; c.b+=f23+f43;\n\tc = c*.5 - vec3(length(uvd)*.05);\n\tc+=vec3(f0);\n\t\n\treturn c;\n}\n\n//-----------------------------------------------------\n// cameraPath\n//-----------------------------------------------------\n\nvec3 pro, pta, pup;\nfloat dro, dta, dup;\n\nvoid camint( inout vec3 ret, const in float t, const in float duration, const in vec3 dest, inout vec3 prev, inout float prevt ) {\n    if( t >= prevt && t <= prevt+duration ) {\n    \tret = mix( prev, dest, smoothstep(prevt, prevt+duration, t) );\n    }\n    prev = dest;\n    prevt += duration;\n}\n\nvoid cameraPath( in float t, out vec3 ro, out vec3 ta, out vec3 up ) {\n#ifndef HIDE_TERRAIN\n    time = t = mod( t, 92. );\n#else\n    time = t = mod( t, 66. );\n#endif\n    dro = dta = dup = 0.;\n\n    pro = ro = vec3(900. ,7000. ,1500. );\n    pta = ta = vec3(    0. ,    0. ,   0. );\n    pup = up = vec3(    0. ,    0.4,   1. ); \n   \n    camint( ro, t, 5., vec3(-4300. ,-1000. , 500. ), pro, dro );\n    camint( ta, t, 5., vec3(    0. ,    0. ,   0. ), pta, dta );\n    camint( up, t, 7., vec3(    0. ,    0.1,   1. ), pup, dup ); \n \n    camint( ro, t, 3., vec3(-1355. , 1795. , 1.2 ), pro, dro );\n    camint( ta, t, 1., vec3(    0. , 300. ,-600. ), pta, dta );\n    camint( up, t, 6., vec3(    0. ,  0.1,    1. ), pup, dup );\n\n    camint( ro, t, 10., vec3(-1355. , 1795. , 1.2 ), pro, dro );\n    camint( ta, t, 14., vec3(    0. , 100. ,   600. ), pta, dta );\n    camint( up, t, 13., vec3(    0. ,  0.3,    1. ), pup, dup );\n    \n    vec3 roe = seaUntransform( vec3( 0., EARTH_RADIUS+0.004, 0. ) );\n    vec3 upe = seaUntransform( vec3( 0., 1., 0. ) );\n    \n    camint( ro, t, 7.,roe, pro, dro );\n    camint( ta, t, 7., vec3( EARTH_RADIUS + 0., EARTH_RADIUS - 500., 500. ), pta, dta );\n    camint( up, t, 6., upe, pup, dup );\n        \n    camint( ro, t, 17.,roe, pro, dro );\n    camint( ta, t, 17., vec3( EARTH_RADIUS + 500., EARTH_RADIUS + 1300., -100. ), pta, dta );\n    camint( up, t, 18., vec3(.0,1.,1.), pup, dup );\n    \n    camint( ro, t, 11., vec3(  3102. ,  0. , 1450. ), pro, dro );\n    camint( ta, t, 4., vec3(    0. ,   -100. ,   0. ), pta, dta );\n    camint( up, t, 8., vec3(    0. ,    0.15,   1. ), pup, dup ); \n#ifndef HIDE_TERRAIN    \n    roe = terrainUntransform( vec3( 0., EARTH_RADIUS+0.004, 0. ) );\n    upe = terrainUntransform( vec3( 0., 1., 0. ) );\n    \n    camint( ro, t, 7., roe, pro, dro );\n    camint( ta, t, 12., vec3( -EARTH_RADIUS, EARTH_RADIUS+200., 100.), pta, dta );\n    camint( up, t, 2., upe, pup, dup );\n        \n    roe = terrainUntransform( vec3( 0., EARTH_RADIUS+0.001, 0. ) );\n    camint( ro, t, 17.,roe, pro, dro );\n    camint( ta, t, 18., roe + vec3( 5000., EARTH_RADIUS-100., -2000.), pta, dta );\n    camint( up, t, 18., vec3(.0,1.,1.), pup, dup );\n        \n    roe = terrainUntransform( vec3( 0., EARTH_RADIUS+1.8, 0. ) );\n    camint( ro, t, 4.,roe, pro, dro );\n    camint( ta, t, 4.5, roe + vec3( EARTH_RADIUS, EARTH_RADIUS+2000., -30.), pta, dta );\n    camint( up, t, 4., vec3(.0,1.,1.), pup, dup );\n#endif    \n    camint( ro, t, 10., vec3(900. ,7000. , 1500. ), pro, dro );\n    camint( ta, t, 2., vec3(    0. ,    0. ,   0. ), pta, dta );\n    camint( up, t, 10., vec3(    0. ,    0.4,   1. ), pup, dup ); \n    \n    up = normalize( up );\n}\n\n//-----------------------------------------------------\n// mainImage\n//-----------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 p = -1.0 + 2.0 * (fragCoord.xy) / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n    \n    vec3 col;\n    \n// black bands\n    vec2 bandy = vec2(.1,.9);\n    if( uv.y < bandy.x || uv.y > bandy.y ) {\n        col = vec3(0.);\n    } else {\n        // camera\n        vec3 ro, ta, up;\n        cameraPath( iTime*.7, ro, ta, up );\n\n        vec3 ww = normalize( ta - ro );\n        vec3 uu = normalize( cross(ww,up) );\n        vec3 vv = normalize( cross(uu,ww));\n        vec3 rd = normalize( -p.x*uu + p.y*vv + 2.2*ww );\n\n        float maxd = MAX;  \n        col = renderStars( rd ).xyz;\n\n        vec4 planet = renderPlanet( ro, rd, up, maxd );       \n        if( planet.w > 0. ) col.xyz = planet.xyz;\n\n        float atmosphered = maxd;\n        vec4 atmosphere = .85*renderAtmospheric( ro, rd, atmosphered );\n        col = col * (1.-atmosphere.w ) + atmosphere.xyz; \n\n        vec4 ring = renderRing( ro, rd, maxd );\n        if( ring.w > 0. && atmosphered < maxd ) {\n           ring.xyz = ring.xyz * (1.-atmosphere.w ) + atmosphere.xyz; \n        }\n        col = col * (1.-ring.w ) + ring.xyz;\n\n#ifdef DISPLAY_CLOUDS\n        float lro = length(ro);\n        if( lro < EARTH_RADIUS+EARTH_CLOUDS*1.25 ) {\n            vec3 sunColor = 2.*renderAtmosphericLow( ro, SUN_DIRECTION);  \n            vec3 upColor = 4.*renderAtmosphericLow( ro, vec3(-SUN_DIRECTION.x, SUN_DIRECTION.y, -SUN_DIRECTION.z));  \n\n            if( lro < EARTH_RADIUS+EARTH_CLOUDS ) {\n                // clouds\n                float d = iCSphereF( ro, rd, EARTH_RADIUS + EARTH_CLOUDS );\n                if( d < maxd ) {\n                    float shadow;\n                    vec4 clouds = renderClouds( ro, rd, d, normalize(ro), 0., sunColor, upColor, shadow );\n                    clouds.w *= 1.-smoothstep(0.8*EARTH_CLOUDS,EARTH_CLOUDS,lro-EARTH_RADIUS);\n                    col = mix(col, clouds.rgb, clouds.w * (1.-smoothstep( 10., 30., d)) );\n                }\n            }\n            float offset = lro-EARTH_RADIUS-EARTH_CLOUDS;\n            col = mix( col, .5*sunColor, .15*abs(noise(offset*100.))*clamp(1.-4.*abs(offset)/EARTH_CLOUDS, 0., 1.) );\n        }\n#endif \n\n        // post processing\n        col = pow( clamp(col,0.0,1.0), vec3(0.4545) );\n        col *= vec3(1.,0.99,0.95);   \n        col = clamp(1.06*col-0.03, 0., 1.);      \n\n        vec2 sunuv =  2.7*vec2( dot( SUN_DIRECTION, -uu ), dot( SUN_DIRECTION, vv ) );\n        float flare = dot( SUN_DIRECTION, normalize(ta-ro) );\n        col += vec3(1.4,1.2,1.0)*lensFlare(p, sunuv)*clamp( flare+.3, 0., 1.);\n\n        uv.y = (uv.y-bandy.x)*(1./(bandy.y-bandy.x));\n        col *= 0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.1 ); \n    }\n    fragColor = vec4( col ,1.0);\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd ) {\n    float maxd = MAX;  \n    time = iTime * .7;\n    \n    rd = rd.xzy;\n    ro = (ro.xzy * .1) + vec3(-1355. , 1795. , 1. );\n    \n    vec3 col = renderStars( rd ).xyz;\n\n    vec4 planet = renderPlanet( ro, rd, vec3(0,.1,1), maxd );       \n    if( planet.w > 0. ) col.xyz = planet.xyz;\n\n    float atmosphered = maxd;\n    vec4 atmosphere = .85*renderAtmospheric( ro, rd, atmosphered );\n    col = col * (1.-atmosphere.w ) + atmosphere.xyz; \n\n    vec4 ring = renderRing( ro, rd, maxd );\n    col = col * (1.-ring.w ) + ring.xyz;\n    \n    // post processing\n    col = pow( clamp(col,0.0,1.0), vec3(0.4545) );\n    col *= vec3(1.,0.99,0.95);   \n    col = clamp(1.06*col-0.03, 0., 1.);      \n    fragColor = vec4( col ,1.0);\n}",
    "tags": [
      "terrain",
      "sea",
      "space",
      "ocean",
      "planet",
      "shadertoy",
      "vr",
      "asteroids"
    ],
    "author": "reinder",
    "views": 0,
    "likes": 527,
    "published": 3
  },
  {
    "id": "Xd23Dh",
    "title": "Voronoise",
    "description": "Patterns such as cell-noise, perlin noise and voronoi can be seen as particular cases of a more general pattern, which I call \"voronoise\". More info [url= http://iquilezles.org/articles/voronoise]in this article[/url]. ",
    "code": "// The MIT License\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org/\n// Copyright \u00a9 2014 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// This is a procedural pattern that has 2 parameters, that generalizes cell-noise, \n// perlin-noise and voronoi, all of which can be written in terms of the former as:\n//\n// cellnoise(x) = pattern(0,0,x)\n// perlin(x) = pattern(0,1,x)\n// voronoi(x) = pattern(1,0,x)\n//\n// From this generalization of the three famouse patterns, a new one (which I call \n// \"Voronoise\") emerges naturally. It's like perlin noise a bit, but within a jittered \n// grid like voronoi):\n//\n// voronoise(x) = pattern(1,1,x)\n//\n// Not sure what one would use this generalization for, because it's slightly slower \n// than perlin or voronoise (and certainly much slower than cell noise), and in the \n// end as a shading TD you just want one or another depending of the type of visual \n// features you are looking for, I can't see a blending being needed in real life.  \n// But well, if only for the math fun it was worth trying. And they say a bit of \n// mathturbation can be healthy anyway!\n//\n// More info here: https://iquilezles.org/articles/voronoise\n\n// More Voronoi shaders:\n//\n// Exact edges:  https://www.shadertoy.com/view/ldl3W8\n// Hierarchical: https://www.shadertoy.com/view/Xll3zX\n// Smooth:       https://www.shadertoy.com/view/ldB3zc\n// Voronoise:    https://www.shadertoy.com/view/Xd23Dh\n\n// All noise functions here:\n//\n// https://www.shadertoy.com/playlist/fXlXzf&from=0&num=12\n\n\nvec3 hash3( vec2 p )\n{\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)), \n\t\t\t\t   dot(p,vec2(269.5,183.3)), \n\t\t\t\t   dot(p,vec2(419.2,371.9)) );\n\treturn fract(sin(q)*43758.5453);\n}\n\nfloat voronoise( in vec2 p, float u, float v )\n{\n\tfloat k = 1.0+63.0*pow(1.0-v,6.0);\n\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    \n\tvec2 a = vec2(0.0,0.0);\n    for( int y=-2; y<=2; y++ )\n    for( int x=-2; x<=2; x++ )\n    {\n        vec2  g = vec2( x, y );\n\t\tvec3  o = hash3( i + g )*vec3(u,u,1.0);\n\t\tvec2  d = g - f + o.xy;\n\t\tfloat w = pow( 1.0-smoothstep(0.0,1.414,length(d)), k );\n\t\ta += vec2(o.z*w,w);\n    }\n\t\n    return a.x/a.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord / iResolution.xx;\n\n    vec2 p = 0.5 - 0.5*cos( iTime+vec2(0.0,2.0) );\n    \n\tif( iMouse.w>0.001 ) p = vec2(0.0,1.0) + vec2(1.0,-1.0)*iMouse.xy/iResolution.xy;\n\t\n\tp = p*p*(3.0-2.0*p);\n\tp = p*p*(3.0-2.0*p);\n\tp = p*p*(3.0-2.0*p);\n\t\n\tfloat f = voronoise( 24.0*uv, p.x, p.y );\n\t\n\tfragColor = vec4( f, f, f, 1.0 );\n}",
    "tags": [
      "procedural",
      "2d",
      "voronoi",
      "noise",
      "perlin",
      "worley"
    ],
    "author": "iq",
    "views": 0,
    "likes": 400,
    "published": 3
  },
  {
    "id": "4tjSDt",
    "title": "Warp Speed 2",
    "description": "Warp Speed 2 \nFork of:- https://www.shadertoy.com/view/Msl3WH\nI had another look at an old shader.",
    "code": "// 'Warp Speed 2'\n// David Hoskins 2015.\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Fork of:-   https://www.shadertoy.com/view/Msl3WH\n//----------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat s = 0.0, v = 0.0;\n\tvec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.;\n    float time = (iTime-2.0)*58.0;\n\tvec3 col = vec3(0);\n    vec3 init = vec3(sin(time * .0032)*.3, .35 - cos(time * .005)*.3, time * 0.002);\n\tfor (int r = 0; r < 100; r++) \n\t{\n\t\tvec3 p = init + s * vec3(uv, 0.05);\n\t\tp.z = fract(p.z);\n        // Thanks to Kali's little chaotic loop...\n\t\tfor (int i=0; i < 10; i++)\tp = abs(p * 2.04) / dot(p, p) - .9;\n\t\tv += pow(dot(p, p), .7) * .06;\n\t\tcol +=  vec3(v * 0.2+.4, 12.-s*2., .1 + v * 1.) * v * 0.00003;\n\t\ts += .025;\n\t}\n\tfragColor = vec4(clamp(col, 0.0, 1.0), 1.0);\n}",
    "tags": [
      "3d",
      "effect",
      "warp",
      "starfield",
      "speed"
    ],
    "author": "Dave_Hoskins",
    "views": 0,
    "likes": 141,
    "published": 3
  },
  {
    "id": "4sX3Rn",
    "title": "Menger Sponge",
    "description": "Four iterations of the famous fractal structure. See [url]https://iquilezles.org/articles/menger[/url] for the full explanation of how this was done.",
    "code": "// The MIT License\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org/\n// Copyright \u00a9 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// https://iquilezles.org/articles/menger\n\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2\n#endif\n\n\nfloat maxcomp(in vec3 p ) { return max(p.x,max(p.y,p.z));}\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3  di = abs(p) - b;\n    float mc = maxcomp(di);\n    return min(mc,length(max(di,0.0)));\n}\n\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\treturn vec2( max( max( t1.x, t1.y ), t1.z ),\n\t             min( min( t2.x, t2.y ), t2.z ) );\n}\n\nconst mat3 ma = mat3( 0.60, 0.00,  0.80,\n                      0.00, 1.00,  0.00,\n                     -0.80, 0.00,  0.60 );\nvec4 map( in vec3 p )\n{\n    float d = sdBox(p,vec3(1.0));\n    vec4 res = vec4( d, 1.0, 0.0, 0.0 );\n\n    float ani = smoothstep( -0.2, 0.2, -cos(0.5*iTime) );\n\tfloat off = 1.5*sin( 0.01*iTime );\n\t\n    float s = 1.0;\n    for( int m=0; m<4; m++ )\n    {\n        p = mix( p, ma*(p+off), ani );\n\t   \n        vec3 a = mod( p*s, 2.0 )-1.0;\n        s *= 3.0;\n        vec3 r = abs(1.0 - 3.0*abs(a));\n        float da = max(r.x,r.y);\n        float db = max(r.y,r.z);\n        float dc = max(r.z,r.x);\n        float c = (min(da,min(db,dc))-1.0)/s;\n\n        if( c>d )\n        {\n          d = c;\n          res = vec4( d, min(res.y,0.2*da*db*dc), (1.0+float(m))/4.0, 0.0 );\n        }\n    }\n\n    return res;\n}\n\nvec4 intersect( in vec3 ro, in vec3 rd )\n{\n    vec2 bb = iBox( ro, rd, vec3(1.05) );\n    if( bb.y<bb.x ) return vec4(-1.0);\n    \n    float tmin = bb.x;\n    float tmax = bb.y;\n    \n    float t = tmin;\n    vec4 res = vec4(-1.0);\n    for( int i=0; i<64; i++ )\n    {\n        vec4 h = map(ro + rd*t);\n\t\tif( h.x<0.002 || t>tmax ) break;\n        res = vec4(t,h.yzw);\n        t += h.x;\n    }\n\tif( t>tmax ) res=vec4(-1.0);\n    return res;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    vec2 bb = iBox( ro, rd, vec3(1.05) );\n    float tmax = bb.y;\n    \n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<64; i++ )\n    {\n        float h = map(ro + rd*t).x;\n        res = min( res, k*h/t );\n        if( res<0.001 ) break;\n\t\tt += clamp( h, 0.005, 0.1 );\n        if( t>tmax ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n    vec3 eps = vec3(.001,0.0,0.0);\n    return normalize(vec3(\n    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n    map(pos+eps.yyx).x - map(pos-eps.yyx).x ));\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n    // background color\n    vec3 col = mix( vec3(0.3,0.2,0.1)*0.5, vec3(0.7, 0.9, 1.0), 0.5 + 0.5*rd.y );\n\t\n    vec4 tmat = intersect(ro,rd);\n    if( tmat.x>0.0 )\n    {\n        vec3  pos = ro + tmat.x*rd;\n        vec3  nor = calcNormal(pos);\n        \n        vec3 matcol = 0.5 + 0.5*cos(vec3(0.0,1.0,2.0)+2.0*tmat.z);\n        \n        float occ = tmat.y;\n\n        const vec3 light = normalize(vec3(1.0,0.9,0.3));\n        float dif = dot(nor,light);\n        float sha = 1.0;\n        if( dif>0.0 ) sha=softshadow( pos, light, 0.01, 64.0 );\n        dif = max(dif,0.0);\n        vec3  hal = normalize(light-rd);\n        float spe = dif*sha*pow(clamp(dot(hal,nor),0.0,1.0),16.0)*(0.04+0.96*pow(clamp(1.0-dot(hal,light),0.0,1.0),5.0));\n        \n\t\tfloat sky = 0.5 + 0.5*nor.y;\n        float bac = max(0.4 + 0.6*dot(nor,vec3(-light.x,light.y,-light.z)),0.0);\n\n        vec3 lin  = vec3(0.0);\n        lin += 1.00*dif*vec3(1.10,0.85,0.60)*sha;\n        lin += 0.50*sky*vec3(0.10,0.20,0.40)*occ;\n        lin += 0.10*bac*vec3(1.00,1.00,1.00)*(0.5+0.5*occ);\n        lin += 0.25*occ*vec3(0.15,0.17,0.20);\t \n        col = matcol*lin + spe*128.0;\n    }\n\n    col = 1.5*col/(1.0+col);\n    col = sqrt( col );\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera\n    vec3 ro = 1.1*vec3(2.5*sin(0.25*iTime),1.0+1.0*cos(iTime*.13),2.5*cos(0.25*iTime));\n\n#if AA>1\n    #define ZERO (min(iFrame,0))\n    vec3 col = vec3(0.0);\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n\n        vec3 ww = normalize(vec3(0.0) - ro);\n        vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n        vec3 vv = normalize(cross(ww,uu));\n        vec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww );\n\n        col += render( ro, rd );\n    }\n    col /= float(AA*AA);\n#else   \n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 ww = normalize(vec3(0.0) - ro);\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww );\n    vec3 col = render( ro, rd );\n#endif        \n    \n    fragColor = vec4(col,1.0);\n}\n\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    float time = iTime*0.25 + 0.01*iMouse.x;\n    float anim = 1.1 + 0.5*smoothstep( -0.3, 0.3, cos(0.1*iTime) );\n\n    vec3 col = render( fragRayOri + vec3(0.0,1.0,2.5), fragRayDir );\n    fragColor = vec4( col, 1.0 );\n}",
    "tags": [
      "3d",
      "raymarching",
      "fractal",
      "menger",
      "vr"
    ],
    "author": "iq",
    "views": 0,
    "likes": 160,
    "published": 3
  },
  {
    "id": "XlfGRj",
    "title": "Star Nest",
    "description": "3D kaliset fractal - volumetric rendering and some tricks. I put the params on top to play with. Mouse enabled to explore different regions. ",
    "code": "// Star Nest by Pablo Roman Andrioli\n// License: MIT\n\n#define iterations 17\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.010 \n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//get coords and direction\n\tvec2 uv=fragCoord.xy/iResolution.xy-.5;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec3 dir=vec3(uv*zoom,1.);\n\tfloat time=iTime*speed+.25;\n\n\t//mouse rotation\n\tfloat a1=.5+iMouse.x/iResolution.x*2.;\n\tfloat a2=.8+iMouse.y/iResolution.y*2.;\n\tmat2 rot1=mat2(cos(a1),sin(a1),-sin(a1),cos(a1));\n\tmat2 rot2=mat2(cos(a2),sin(a2),-sin(a2),cos(a2));\n\tdir.xz*=rot1;\n\tdir.xy*=rot2;\n\tvec3 from=vec3(1.,.5,0.5);\n\tfrom+=vec3(time*2.,time,-2.);\n\tfrom.xz*=rot1;\n\tfrom.xy*=rot2;\n\t\n\t//volumetric rendering\n\tfloat s=0.1,fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam; // the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta*=a*a; // add contrast\n\t\tif (r>6) fade*=1.-dm; // dark matter, don't render near\n\t\t//v+=vec3(dm,dm*.5,0.);\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n\tfragColor = vec4(v*.01,1.);\t\n\t\n}",
    "tags": [
      "fractal",
      "space",
      "stars"
    ],
    "author": "Kali",
    "views": 0,
    "likes": 1387,
    "published": 3
  },
  {
    "id": "4djSRW",
    "title": "Hash without Sine",
    "description": "A shader Hash function that is the same on all systems and doesn't rely on trig functions. New hash on the left, sine hash function on the right. It appears to be the same efficiency, but I suppose that depends on the hardware.",
    "code": "// Hash without Sine\n// MIT License...\n/* Copyright (c)2014 David Hoskins.\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*/\n\n\n\n// All hashes are in the 'COMMON' tab\n\n/*     *NOTE*\nThis was made because I noticed a the sin() hash function was inconsistent between\ndifferent GPUs on a landscape I was making - I spent ages tweaking a mountain range,\nonly to find it was different on a Mac and different again on a mobile.\nNightmare! Something was needed to fix this.\nI realised shaders are designed for shading, not putting a rocket on the moon,\nso I'm not surprised something like sin(50000.0) be a little inconsistent between manufacturers,\nthey all want to be the fastest so different approaches were used it seems.\nIf you're using P5, GLSLsandbox or any WebGL1 locked library, then this is for you.\nOtherwise just use an ancient integer hash! \ud83d\ude01\n*/\n\n// New one on the left, sine function on the right.\n// *NB: This is for integer scaled floats only! i.e. Standard noise functions.\n\n#define ITERATIONS 1\n\n\n//----------------------------------------------------------------------------------------\nfloat hashOld12(vec2 p)\n{\n    // Two typical hashes...\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n    \n    // This one is better, but it still stretches out quite quickly...\n    // But it's really quite bad on my Mac(!)\n    //return fract(sin(dot(p, vec2(1.0,113.0)))*43758.5453123);\n\n}\n\nvec3 hashOld33( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn fract(sin(p)*43758.5453123);\n}\n\n//----------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 position = fragCoord.xy;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n#if 1\n\tfloat a = 0.0, b = a;\n    for (int t = 0; t < ITERATIONS; t++)\n    {\n        float v = float(t+1)*.152;\n        vec2 pos = (position * v + iTime * 1500. + 50.0);\n        a += hash12(pos.xy);\n    \tb += hashOld12(pos);\n    }\n    vec3 col = vec3(mix(b, a, step(uv.x, .5))) / float(ITERATIONS);\n#else\n\tvec3 a = vec3(0.0), b = a;\n    for (int t = 0; t < ITERATIONS; t++)\n    {\n        float v = float(t+1)*.132;\n        vec3 pos = vec3(position, iTime*.3) + iTime * 500. + 50.0;\n        a += hash33(pos);\n        b += hashOld33(pos);\n    }\n    vec3 col = vec3(mix(b, a, step(uv.x, .5))) / float(ITERATIONS);\n#endif\n\n    col = mix(vec3(.4, 0.0, 0.0), col, smoothstep(.5, .495, uv.x) + smoothstep(.5, .505, uv.x));\n\tfragColor = vec4(col, 1.0);\n}",
    "tags": [
      "noise",
      "fbm",
      "perlin",
      "random",
      "hash",
      "rnd",
      "rand"
    ],
    "author": "Dave_Hoskins",
    "views": 0,
    "likes": 749,
    "published": 3
  },
  {
    "id": "lsSXzD",
    "title": "E1M1 - Hangar",
    "description": "The start area of Doom E1M1.\nHold down the mouse button and drag the mouse to move.\nWhere you click relative to the center of the screen sets the view direction.\n\nAlso, check out Reinder's excellent Doom2 shader: https://www.shadertoy.com/view/lsB3zD",
    "code": "// E1M1 - Hangar\n// by @P_Malin\n\n// Procedural version of Doom E1M1\n\n// The start area of Doom E1M1.\n// Click and drag the mouse to move.\n// Where you click relative to the center of the screen sets the view direction.\n\n// This is the single pass version. A multi-pass playable version is here: https://www.shadertoy.com/view/lldGDr\n\n// Also, check out Reinder's excellent Doom2 shader: https://www.shadertoy.com/view/lsB3zD\n\n// The sectors we draw by default\n#define ENABLE_NUKAGE_SECTORS\n#define ENABLE_START_SECTORS\n\n// Adding this compiles with \"Unknown Error\" on some machines. Uncomment if you are feeling lucky.\n//#define ENABLE_SECTOR_31\n\n// Some additional sectors, may need to comment out some of the default ones\n//#define ENABLE_EXTRA_NUKAGE_SECTORS\n//#define ENABLE_MISC_SECTORS\n\n#define ENABLE_SPRITES\n\n#define DEMO_CAMERA\n#define INTRO_EFFECT\n#define DRAW_SKY\n#define HEAD_BOB\n\n#define PIXELATE_IMAGE\n#define QUANTIZE_FINAL_IMAGE\n#define QUANTIZE_TEXTURES\n#define PIXELATE_TEXTURES\n\n//#define DISCARD_BACKGROUND\n\n//#define DRAW_COMPASS\n\n// Add walls to close entrances to sectors we are not rendering\n#ifndef ENABLE_EXTRA_NUKAGE_SECTORS\n\t#define CLOSE_NUKAGE_SECTOR\n#endif\n#ifndef ENABLE_SECTOR_31\n\t#define CLOSE_START_SECTOR\n#endif\n\n#define FAR_CLIP 10000.0\n\nconst vec2 vFakeResolution = vec2(320.0, 240.0);\n\nconst float kDepthFadeScale = (1.0 / 3500.0);\nconst float kExtraLight = 0.0;\n\n// Light level adjustment to East-West and North-South walls\nconst float kC = (1.0 / 16.0);\n\n\nstruct Ray\n{\n    vec3 vRayOrigin;\n    vec3 vRayDir;\n    vec2 vSpriteDir;\n};\n\nvec3 SampleTexture( const in float fTexture, const in vec2 vUV );\nvoid MapIntersect( out float fClosestT, out vec4 vHitInfo, Ray r );\nfloat hash(float p);\n\nvec3 GetCameraRayDir( const in vec2 vWindow, const in vec3 vCameraPos, const in vec3 vCameraTarget )\n{\n\tvec3 vForward = normalize(vCameraTarget - vCameraPos);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n\t\n    const float kFOV = 1.8;\n    \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * kFOV);\n\n\treturn vDir;\n}\n\nvec3 Quantize( const in vec3 col )\n{\n\treturn floor( col * 48.0 + 0.5 ) * (1.0 / 48.0);\n}\n\nfloat Cross2d( const in vec2 vA, const in vec2 vB )\n{   \n    //return cross( vec3(vA, 0.0), vec3(vB, 0.0) ).z;\n  \treturn vA.x * vB.y - vA.y * vB.x;\n\n    //return dot(vA * vB.yx, vec2(1.0, -1.0)); \n}\n\nvoid BeginSector( out vec4 vSectorState, const in vec2 vSectorHeights, Ray r )\n{\n    // store the infinite floor-ceiling plane intersect depth in vSectorState.xy\n    vSectorState.xy = (vSectorHeights - r.vRayOrigin.y) / r.vRayDir.y;   \n    vSectorState.zw = vec2(0.0,0.0);\n}\n\n// Intersect a sidedef that meets another sector with the same floor and ceiling height\nvoid Null( inout vec4 vSectorState, const in int iAx, const in int iAy, const in int iBx, const in int iBy, Ray r )\n{\n    vec2 vA = vec2(iAx, iAy);\n    vec2 vB = vec2(iBx, iBy);\n    \n    vec2 vD = vB - vA;\n    vec2 vOA = vA - r.vRayOrigin.xz;\n\tfloat fDenom = Cross2d( r.vRayDir.xz, vD );\n    float fRcpDenom = 1.0 / fDenom;\n    float fHitT = Cross2d( vOA, vD ) * fRcpDenom;\n    float fHitU = Cross2d( vOA, r.vRayDir.xz ) * fRcpDenom;\n\n   \tif((fHitT > 0.0) && (fHitU >= 0.0) && (fHitU < 1.0))\n    {\n        // If we crossed the sector edge further away than the floor-ceiling intersection\n        // then we increment the in-out test value\n        // This is like doing a ray-casting point in polygon test \n        // http://en.wikipedia.org/wiki/Point_in_polygon\n        // from the floor/ceiling intersection depth to far clip depth\n    \tvSectorState.zw += step(vSectorState.xy, vec2(fHitT,fHitT));\n    }\n}\n\nvoid Wall( inout float fClosestT, inout vec4 vHitInfo, inout vec4 vSectorState, const in int iAx, const in int iAy, const in int iBx, const in int iBy, const in int iLen, const in float fLightLevel, const in vec2 vSectorHeights, const in float fTexture, Ray r )\n{\n    vec2 vA = vec2(iAx, iAy);\n    vec2 vB = vec2(iBx, iBy);\n\tfloat fLen = float(iLen);\n    \n    vec2 vD = vB - vA;\n    vec2 vOA = vA - r.vRayOrigin.xz;\n\tfloat fDenom = Cross2d( r.vRayDir.xz, vD );\n    float fRcpDenom = 1.0 / fDenom;\n    float fHitT = Cross2d( vOA, vD ) * fRcpDenom;\n    float fHitU = Cross2d( vOA, r.vRayDir.xz ) * fRcpDenom;\n\n    if((fHitT > 0.0) && (fHitU >= 0.0) && (fHitU < 1.0))\n    {\n        // If we crossed the sector edge further away than the floor-ceiling intersection\n        // then we increment the in-out test value\n        // This is like doing a ray-casting point in polygon test \n        // http://en.wikipedia.org/wiki/Point_in_polygon\n        // from the floor/ceiling intersection depth to far clip depth\n        vSectorState.zw += step(vSectorState.xy, vec2(fHitT,fHitT));\n\n        if((fHitT < fClosestT) && (fDenom < 0.0))\n        {        \n            float fHitY = r.vRayDir.y * fHitT + r.vRayOrigin.y;\n            if( (fHitY > vSectorHeights.x) && (fHitY < vSectorHeights.y) )\n            {\n                fClosestT = fHitT;\n                vHitInfo = vec4(fHitU * fLen, fHitY, fLightLevel, fTexture);            \n            }\n        }\n    }\n}\n\nvoid Open( inout float fClosestT, inout vec4 vHitInfo, inout vec4 vSectorState, const in int iAx, const in int iAy, const in int iBx, const in int iBy, const in int iLen, const in float fLightLevel, const in vec2 vSectorHeights, const in int iLowerHeight, const in int iUpperHeight, const in float fLowerTexture, const in float fUpperTexture, Ray r )\n{ \n    vec2 vA = vec2(iAx, iAy);\n    vec2 vB = vec2(iBx, iBy);\n\tfloat fLen = float(iLen);\n    float fUpperHeight = float(iUpperHeight);\n    float fLowerHeight = float(iLowerHeight);\n\t\n    vec2 vD = vB - vA;\n    vec2 vOA = vA - r.vRayOrigin.xz;\n\tfloat fDenom = Cross2d( r.vRayDir.xz, vD );\n    float fRcpDenom = 1.0 / fDenom;\n    float fHitT = Cross2d( vOA, vD ) * fRcpDenom;\n    float fHitU = Cross2d( vOA, r.vRayDir.xz ) * fRcpDenom;\n\n    if((fHitT > 0.0) && (fHitU >= 0.0) && (fHitU < 1.0))\n    {\n        // If we crossed the sector edge further away than the floor-ceiling intersection\n        // then we increment the in-out test value\n        // This is like doing a ray-casting point in polygon test \n        // http://en.wikipedia.org/wiki/Point_in_polygon\n        // from the floor/ceiling intersection depth to far clip depth\n        vSectorState.zw += step(vSectorState.xy, vec2(fHitT,fHitT));\n        \n        if((fHitT < fClosestT) && (fDenom < 0.0))\n        {\n            float fHitY = r.vRayDir.y * fHitT + r.vRayOrigin.y;\n            if( (fHitY > vSectorHeights.x) && (fHitY < vSectorHeights.y) )\n            {\n                if(fHitY < fLowerHeight)\n                {\n                    fClosestT = fHitT;\n                    vHitInfo = vec4(fHitU * fLen, fHitY - fLowerHeight, fLightLevel, fLowerTexture);                   \n                }            \n                if(fHitY > fUpperHeight)\n                {\n                    fClosestT = fHitT;\n                    vHitInfo = vec4(fHitU * fLen, fHitY - fUpperHeight, fLightLevel, fUpperTexture);                   \n                }\n            }\n        }\n    }\n}\n\nvoid Upper( inout float fClosestT, inout vec4 vHitInfo, inout vec4 vSectorState, const in int iAx, const in int iAy, const in int iBx, const in int iBy, const in int iLen, const in float fLightLevel, const in vec2 vSectorHeights, const in int iUpperHeight, const in float fUpperTexture, Ray r )\n{ \n    vec2 vA = vec2(iAx, iAy);\n    vec2 vB = vec2(iBx, iBy);\n\tfloat fLen = float(iLen);\n    float fUpperHeight = float(iUpperHeight);\n    \n    vec2 vD = vB - vA;\n    vec2 vOA = vA - r.vRayOrigin.xz;\n\tfloat fDenom = Cross2d( r.vRayDir.xz, vD );\n    float fRcpDenom = 1.0 / fDenom;\n    float fHitT = Cross2d( vOA, vD ) * fRcpDenom;\n    float fHitU = Cross2d( vOA, r.vRayDir.xz ) * fRcpDenom;\n\n    if((fHitT > 0.0) && (fHitU >= 0.0) && (fHitU < 1.0))\n    {\n        // If we crossed the sector edge further away than the floor-ceiling intersection\n        // then we increment the in-out test value\n        // This is like doing a ray-casting point in polygon test \n        // http://en.wikipedia.org/wiki/Point_in_polygon\n        // from the floor/ceiling intersection depth to far clip depth\n        vSectorState.zw += step(vSectorState.xy, vec2(fHitT,fHitT));\n        \n        if((fHitT < fClosestT) && (fDenom < 0.0))\n        {\n            float fHitY = r.vRayDir.y * fHitT + r.vRayOrigin.y;\n            if( fHitY < vSectorHeights.y )\n            {           \n                if(fHitY > fUpperHeight)\n                {\n                    fClosestT = fHitT;\n                    vHitInfo = vec4(fHitU * fLen, fHitY - fUpperHeight, fLightLevel, fUpperTexture);                   \n                }\n            }\n        }\n    }\n}\n\n\nvoid Lower( inout float fClosestT, inout vec4 vHitInfo, inout vec4 vSectorState, const in int iAx, const in int iAy, const in int iBx, const in int iBy, const in int iLen, const in float fLightLevel, const in vec2 vSectorHeights, const in int iLowerHeight, const in float fLowerTexture, Ray r )\n{ \n    vec2 vA = vec2(iAx, iAy);\n    vec2 vB = vec2(iBx, iBy);\n\tfloat fLen = float(iLen);\n    float fLowerHeight = float(iLowerHeight);\n    \n    vec2 vD = vB - vA;\n    vec2 vOA = vA - r.vRayOrigin.xz;\n\tfloat fDenom = Cross2d( r.vRayDir.xz, vD );\n    float fRcpDenom = 1.0 / fDenom;\n    float fHitT = Cross2d( vOA, vD ) * fRcpDenom;\n    float fHitU = Cross2d( vOA, r.vRayDir.xz ) * fRcpDenom;\n\n    if((fHitT > 0.0) && (fHitU >= 0.0) && (fHitU < 1.0))\n    {\n        // If we crossed the sector edge further away than the floor-ceiling intersection\n        // then we increment the in-out test value\n        // This is like doing a ray-casting point in polygon test \n        // http://en.wikipedia.org/wiki/Point_in_polygon\n        // from the floor/ceiling intersection depth to far clip depth\n        vSectorState.zw += step(vSectorState.xy, vec2(fHitT,fHitT));\n        \n        if((fHitT < fClosestT) && (fDenom < 0.0))\n        {\n            float fHitY = r.vRayDir.y * fHitT + r.vRayOrigin.y;\n            if( fHitY > vSectorHeights.x )\n            {           \n                if(fHitY < fLowerHeight)\n                {\n                    fClosestT = fHitT;\n                    vHitInfo = vec4(fHitU * fLen, fHitY - fLowerHeight, fLightLevel, fLowerTexture);                   \n                }            \n            }\n        }\n    }\n}\n\nvoid EndSector( inout float fClosestT, inout vec4 vHitInfo, in vec4 vSectorState, const in float fLightLevel, const in vec2 vFloorCeilingTextures, Ray r )\n{\n    // Test the even-odd state of our sector floor/ceiling in-out values\n    vec2 vInOutTest = fract( vSectorState.zw * 0.5 ) * 2.0;\n\n    if( fClosestT > vSectorState.x )\n    {\n        if((vInOutTest.x > 0.5) && (vSectorState.x > 0.0))\n        {\n            vec3 vFloorPos = r.vRayOrigin + r.vRayDir * vSectorState.x;        \n            if( r.vRayOrigin.y > vFloorPos.y )\n            {\n                fClosestT = vSectorState.x;\n                vHitInfo = vec4( vFloorPos.xz, fLightLevel, vFloorCeilingTextures.x);\n            }\n        }\n    }\n\n    if( fClosestT > vSectorState.y )\n    {\n        if((vInOutTest.y > 0.5) && (vSectorState.y > 0.0))\n        {\n            vec3 vCeilingPos = r.vRayOrigin + r.vRayDir * vSectorState.y;        \n            if( r.vRayOrigin.y < vCeilingPos.y )\n            {\n                fClosestT = vSectorState.y;\n                vHitInfo = vec4( vCeilingPos.xz, fLightLevel, vFloorCeilingTextures.y);\n            }\n        }            \n    }\n}\n\n#ifdef ENABLE_SPRITES\n\nvoid Sprite( out float fClosestT, out vec4 vHitInfo, const in vec2 vSpriteDir, const in int iX, const in int iY, const in int iZ, vec2 vSize, float fLightLevel, float fTexture, Ray r )\n{\n\tvec3 vPos = vec3(iX, iY, iZ);\n\tfClosestT = FAR_CLIP;\n\tvHitInfo = vec4(0.0,0.0,0.0,0.0);\n\tvec2 vA = vPos.xz - vSpriteDir * 0.5 * vSize.x;\n\tvec2 vB = vPos.xz + vSpriteDir * 0.5 * vSize.x;\n    vec2 vD = vB - vA;\n    vec2 vOA = vA - r.vRayOrigin.xz;\n    float rcpdenom = 1.0 / Cross2d( r.vRayDir.xz, vD ); \n    float fHitT = Cross2d( vOA, vD ) * rcpdenom;\n\n    if(fHitT > 0.0)\n    {\n\t    float fHitU = Cross2d( vOA, r.vRayDir.xz ) * rcpdenom;\n        if((fHitU >= 0.0) && (fHitU < 1.0))\n        {\n            float fHitY = r.vRayDir.y * fHitT + r.vRayOrigin.y;\n            if( (fHitT < fClosestT) && (fHitY > vPos.y) && (fHitY < (vPos.y + vSize.y)) )\n            {\n                fClosestT = fHitT;\n                vHitInfo = vec4(fHitU * vSize.x, fHitY - vPos.y, fLightLevel, fTexture);            \n            }\n        }\n    }\n}\n\nbool MaskBarrel(vec2 vTexCoord)\n{\n\tvec2 vSize = vec2(23.0, 32.0);\n\t\n\tvTexCoord = floor(vTexCoord);\n\t\n\t// remove corner pixels\n\tvec2 vWrapCoord = fract((vTexCoord + vec2(2.0, 1.0) ) / vSize) * vSize;\n\t\n\treturn ( (vWrapCoord.x >= 4.0) || (vWrapCoord.y >= 2.0) );\n}\n\n\nvec4 CosApprox( vec4 x )\n{\n\tx = abs(fract(x * (0.5))*2.0 - 1.0);\n\tvec4 x2 = x*x;\n\treturn( ( x2 * 3.0) - ( 2.0 * x2*x) );\n}\n\nbool MaskCorpseSprite(vec2 vTexCoord)\n{\n\t//vTexCoord = floor(vTexCoord);\n    \n    vec2 vUV = vTexCoord.xy / vec2(57.0, 22.0);\n    vec2 vOffset = vUV;\n    vOffset = vOffset * 2.0 -vec2(1.0, 0.8);\n    float fDist = dot(vOffset, vOffset);\n    fDist += dot(CosApprox(vTexCoord.xyxy * vec4(0.55, 0.41, 0.25, 0.1)), vec4(0.2 * -vOffset.yyyy));\n\treturn fDist < 0.4;\n}\n\n#define TEX_BAR1A 32.0\n#define TEX_PLAYW 33.0\n\nvoid BarrelSprite(inout float fClosestT, inout vec4 vHitInfo, const in vec2 vSpriteDir, const in int iX, const in int iY, const in int iZ, const in float fLightLevel, Ray r )\n{\n\tfloat fSpriteT;\n\tvec4 vSpriteHitInfo;\t\t\n\tSprite( fSpriteT, vSpriteHitInfo, vSpriteDir, iX, iY, iZ, vec2(23.0, 32.0), fLightLevel, TEX_BAR1A, r);\n\t\n\tif(fSpriteT < fClosestT)\n\t{\n\t\tif(MaskBarrel(vSpriteHitInfo.xy))\n\t\t{\n\t\t\tfClosestT = fSpriteT;\n\t\t\tvHitInfo = vSpriteHitInfo;\n\t\t}\n\t}\n}\n\nvoid CorpseSprite(inout float fClosestT, inout vec4 vHitInfo, const in vec2 vSpriteDir, const in int iX, const in int iY, const in int iZ, const in float fLightLevel, Ray r )\n{\n\tfloat fSpriteT;\n\tvec4 vSpriteHitInfo;\t\t\n\tSprite( fSpriteT, vSpriteHitInfo, vSpriteDir, iX, iY, iZ, vec2(57.0, 22.0), fLightLevel, TEX_PLAYW, r );\n\n\tif(fSpriteT < fClosestT)\n\t{\n\t\tif(MaskCorpseSprite(vSpriteHitInfo.xy))\n\t\t{\n\t\t\tfClosestT = fSpriteT;\n\t\t\tvHitInfo = vSpriteHitInfo;\n\t\t}\n\t}\n}\n#endif\n\nvec3 DrawScene(vec3 vForwards, vec2 vUV, Ray r )\n{\n    \n    vec4 vHitInfo;\n    float fClosestT;\n\tfloat fNoFog = 0.0;\n\n\t\n    MapIntersect( fClosestT, vHitInfo, r );\n\n\n    #ifdef ENABLE_SPRITES\n\tvec2 vSpriteDir = -normalize(vec2(-vForwards.z, vForwards.x));\n    BarrelSprite(fClosestT, vHitInfo, vSpriteDir, 1088, 0, -2944, 0.565, r);\n    BarrelSprite(fClosestT, vHitInfo, vSpriteDir, 864, 0, -3328, 0.565, r);\n    BarrelSprite(fClosestT, vHitInfo, vSpriteDir, 1312, -16, -3264, 0.878, r);\n    CorpseSprite(fClosestT, vHitInfo, vSpriteDir, 1024, -16, -3264, 0.878, r);\n    #endif\t\n\t\n\tvHitInfo.z = clamp(vHitInfo.z + kExtraLight, 0.0, 1.0);\n\n    // sky\n    #ifdef DRAW_SKY\n    float fDoSky = step(0.9, vHitInfo.w) * step(vHitInfo.w, 1.1);\n    \n    fNoFog = max(fNoFog, fDoSky);\n    float fSkyU = (atan(vForwards.x, vForwards.z) * 512.0 / radians(180.0)) + vUV.x * 320.0;\n    float fSkyV = vUV.y * 240.0;\n    vHitInfo = mix(vHitInfo, vec4(fSkyU, fSkyV, 1.0, 1.0), fDoSky);\n    #endif\n    \n    // fade in effect\n\t#ifdef INTRO_EFFECT\n    float fEffectOffset = max(iTime - 1.0, 0.0) - hash(vUV.x);\n    vec2 vEffectUV = vUV;\n    vEffectUV.y += clamp(fEffectOffset, 0.0, 1.0);\n    \n    float fDoEffect = step(vEffectUV.y, 1.0);       \n    vHitInfo = mix(vHitInfo, vec4(vEffectUV * 128.0, 1.0, 3.0), fDoEffect);\n    fNoFog = max(fNoFog, fDoEffect);\n    #endif    \n\n\t#ifdef DISCARD_BACKGROUND    \n    if(vHitInfo.w == 0.0) discard;\n\t#endif\n    \n    float fLightLevel = clamp( vHitInfo.z, 0.0, 1.0 );\n    float fDepth = dot(r.vRayDir, vForwards) * fClosestT;\n    float fDepthFade = fDepth * kDepthFadeScale;\n    float fApplyFog = 1.0 - fNoFog;\n    fLightLevel = clamp( fLightLevel - fDepthFade * fApplyFog, 0.0, 1.0 );\n    \n    vec3 vResult = SampleTexture( vHitInfo.w, vHitInfo.xy ) * fLightLevel;\n    \n    vResult = clamp(vResult * 1.2, 0.0, 1.0);\n    \n    #ifdef QUANTIZE_FINAL_IMAGE\n    vResult = Quantize(vResult);\n    #endif    \n    \n    return vResult;\n}\n\nvoid DemoCamera( float time, inout vec3 vCameraPos, inout vec3 vCameraTarget )\n{\n    vCameraPos = vec3(1050, 30, -3616);\n    vCameraTarget = vec3(1050, 30, -3500);\n\n    #ifdef DEMO_CAMERA\n    float fCamTime = time - 5.0;\n    if(fCamTime > 0.0) fCamTime = mod(fCamTime, 33.0 - 5.0) + 5.0;\n    if(iTime==10.0) fCamTime = 0.0; // hack for shadertoy preview screen\n    vCameraTarget = mix( vCameraTarget, vec3(1834, 30, -3264), smoothstep(5.0, 10.0, fCamTime));\n    vCameraPos = mix( vCameraPos, vec3(1280, 30, -3350), smoothstep(8.0, 13.0, fCamTime));\n\n    vCameraTarget = mix( vCameraTarget, vec3(1280, 30, -2976), smoothstep(11.0, 16.0, fCamTime));\n    vCameraPos = mix( vCameraPos, vec3(1280, 30, -2976), smoothstep(13.0, 19.0, fCamTime));\n\n    vCameraTarget = mix( vCameraTarget, vec3(768, 30, -3050), smoothstep(16.0, 20.0, fCamTime));\n    vCameraPos = mix( vCameraPos, vec3(832, 30, -3020), smoothstep(19.0, 23.0, fCamTime));\n\n    vCameraTarget = mix( vCameraTarget, vec3(1256, 30, -3648), smoothstep(20.0, 25.0, fCamTime));\n    vCameraPos = mix( vCameraPos, vec3(768, 30, -3424), smoothstep(23.0, 28.0, fCamTime));\n\n    vCameraPos = mix( vCameraPos, vec3(1050, 30, -3616), smoothstep(25.0, 30.0, fCamTime));\n    vCameraTarget = mix( vCameraTarget, vec3(1050, 30, -3500), smoothstep(28.0, 33.0, fCamTime));\n    #endif    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 vOrigUV = fragCoord.xy / iResolution.xy;\n    \n    #ifdef PIXELATE_IMAGE\n    vec2 vUV = floor(vOrigUV * vFakeResolution + 0.5) * (1.0 / vFakeResolution);\n    #else\n    vec2 vUV = vOrigUV;\n    #endif\n    \n\tvec3 vCameraPos = vec3(0.0);\n\tvec3 vCameraTarget = vec3(0.0);\n        \n    vec2 vMouse = (iMouse.xy / iResolution.xy);\n\t\n\tconst vec2 vStart = vec2(1050, -3616);\n\n\tif(iMouse.z > 0.0)\n    {\n        vec2 vDir = normalize((abs(iMouse.zw) / iResolution.xy) - 0.5);\n        vec2 vOffset = (iMouse.xy - abs(iMouse.zw)) / iResolution.xy;\n\t\tvCameraPos.y = 30.0;\n    \tvCameraPos.xz = (vDir.yx * vec2(1.0, -1.0) * vOffset.x + vDir * vOffset.y) * 5000.0;\n        vCameraPos.xz += vStart;\n        vCameraTarget.xz = vCameraPos.xz + vDir * 10.0;\n\t    vCameraTarget.y = vCameraPos.y;\n    }\n    else\n    {\n\t\tDemoCamera( iTime, vCameraPos, vCameraTarget );\n    }\n    \n    #ifdef HEAD_BOB\n\tfloat fBob = sin(length(vCameraPos.xz - vStart) * 0.04) * 4.0; // head bob\n    vCameraPos.y += fBob;\n    vCameraTarget.y += fBob;\n    #endif\n\n    vec2 vWindowCoord =\t(vUV * 2.0 - 1.0) * vec2(iResolution.x / iResolution.y, 1.0);\n\t\n    Ray r;\n    \n    \n    r.vRayOrigin = vCameraPos;\n    r.vRayDir = GetCameraRayDir( vWindowCoord, vCameraPos, vCameraTarget );\n\n    vec3 vForwards = normalize(vCameraTarget - vCameraPos); \n    \n\tvec3 vResult = DrawScene(vForwards, vUV, r);\n    \n    #ifdef DRAW_COMPASS\n    // a hack - assume we have never clicked the mouse before if coordinate is zero\n    if((iMouse.x > 0.5) && (iMouse.y > 0.5))\n    {\n        if(iMouse.z <= 0.0)\n        {\n            vec2 vCompassUV = vOrigUV - 0.5;\n            vCompassUV.x *= iResolution.x / iResolution.y;\n            float fDistNS = ((abs(vCompassUV.x) * 10.0) + abs(vCompassUV.y) - 0.05);\n            float fDistEW = ((abs(vCompassUV.y) * 10.0) + abs(vCompassUV.x) - 0.025);\n            float fDistCircle = abs(0.045 - length(vCompassUV)) * 10.0;\n            float fDist = min(min(fDistNS, fDistEW), fDistCircle);\n            \n            float fAmount = clamp(fDist * 20.0, 0.0, 1.0);\n            float fCol = step(fract((floor(vCompassUV.x) + floor(vCompassUV.y)) * 0.5), 0.25);\n            vResult = mix(vec3(fCol * 0.75 + 0.25), vResult, fAmount);\n        }\n    }\n    #endif\n    \n\tfragColor = vec4(vResult, 1.0);\n}\n\n// Generated code follows\n// ----------------- 8< -------------------------- 8< -------------------------- 8< --------------\n\n// Textures\n#define TEX_X 0.0\n#define TEX_F_SKY1 1.0\n#define TEX_NUKAGE3 2.0\n#define TEX_FLOOR7_1 3.0\n#define TEX_FLAT5_5 4.0\n#define TEX_FLOOR4_8 5.0\n#define TEX_CEIL3_5 6.0\n#define TEX_TLITE6_4 7.0\n#define TEX_FLAT14 8.0\n#define TEX_FLOOR7_2 9.0\n#define TEX_STEP2 10.0\n#define TEX_TLITE6_1 11.0\n#define TEX_DOOR3 12.0\n#define TEX_LITE3 13.0\n#define TEX_STARTAN3 14.0\n#define TEX_BROWN1 15.0\n#define TEX_DOORSTOP 16.0\n#define TEX_COMPUTE2 17.0\n#define TEX_STEP6 18.0\n#define TEX_BROWN144 19.0\n#define TEX_SUPPORT2 20.0\n#define TEX_STARG3 21.0\n#define TEX_DOORTRAK 22.0\n#define TEX_SLADWALL 23.0\n#define TEX_TEKWALL4 24.0\n#define TEX_SW1COMP 25.0\n#define TEX_BIGDOOR2 26.0\n\n// Sectors\n\nvoid Sector0( inout float fT, inout vec4 vInf, Ray r )\n{\n    vec4 vSS;\n    const float fLt=1.000;\n    const vec2 vSH=vec2(-80.0, 216.0);\n\n    BeginSector( vSS, vSH, r );\n    Lower( fT, vInf, vSS, 1520, -3168, 1672, -3104, 164, fLt, vSH, -56, TEX_BROWN144, r );\n    Lower( fT, vInf, vSS, 1672, -3104, 1896, -3104, 224, fLt-kC, vSH, -56, TEX_BROWN144, r );\n    Lower( fT, vInf, vSS, 1896, -3104, 2040, -3144, 149, fLt, vSH, -56, TEX_BROWN144, r );\n    Lower( fT, vInf, vSS, 2040, -3144, 2128, -3272, 155, fLt, vSH, -56, TEX_BROWN144, r );\n    Lower( fT, vInf, vSS, 2128, -3272, 2064, -3408, 150, fLt, vSH, -56, TEX_BROWN144, r );\n    Lower( fT, vInf, vSS, 2064, -3408, 1784, -3448, 282, fLt, vSH, -56, TEX_BROWN144, r );\n    Lower( fT, vInf, vSS, 1784, -3448, 1544, -3384, 248, fLt, vSH, -56, TEX_BROWN144, r );\n    Lower( fT, vInf, vSS, 1544, -3384, 1520, -3168, 217, fLt, vSH, -56, TEX_BROWN144, r );\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_NUKAGE3, TEX_F_SKY1), r );\n}\n\nvoid Sector1( inout float fT, inout vec4 vInf, Ray r )\n{\n    vec4 vSS;\n    const float fLt=1.000;\n    const vec2 vSH=vec2(-56.0, 216.0);\n\t// merge walls from ultimate doom secret\n\n    BeginSector( vSS, vSH, r );\n    Open( fT, vInf, vSS, 1376, -3200, 1376, -3104, 96, fLt+kC, vSH, 8, 192, TEX_STARTAN3, TEX_STARTAN3, r );\n    Open( fT, vInf, vSS, 1376, -3360, 1376, -3264, 96, fLt+kC, vSH, 8, 192, TEX_STARTAN3, TEX_STARTAN3, r );\n    Wall( fT, vInf, vSS, 1376, -3264, 1376, -3200, 64, fLt+kC, vSH, TEX_STARTAN3, r);\n\tWall( fT, vInf, vSS, 1376, -3104, 1376, -2944, 160, fLt+kC, vSH, TEX_STARTAN3, r);\n    Wall( fT, vInf, vSS, 1376, -2944, 1472, -2880, 115, fLt, vSH, TEX_STARTAN3, r);\n    Wall( fT, vInf, vSS, 1856, -2880, 1920, -2920, 75, fLt, vSH, TEX_STARTAN3, r);\n    Null( vSS, 1520, -3168, 1672, -3104, r );\n    Null( vSS, 1672, -3104, 1896, -3104, r );\n    Null( vSS, 1896, -3104, 2040, -3144, r );\n    Null( vSS, 2040, -3144, 2128, -3272, r );\n    Null( vSS, 2128, -3272, 2064, -3408, r );\n    Null( vSS, 2064, -3408, 1784, -3448, r );\n    Null( vSS, 1784, -3448, 1544, -3384, r );\n    Null( vSS, 1544, -3384, 1520, -3168, r );\n    Wall( fT, vInf, vSS, 2736, -3360, 2736, -3648, 288, fLt+kC, vSH, TEX_STARTAN3, r);\n#ifdef CLOSE_NUKAGE_SECTOR\n    Wall( fT, vInf, vSS, 2736, -3648, 1376, -3648, 2736-1376, fLt, vSH, TEX_STARTAN3, r);\n#else\n\tNull( vSS, 2736, -3648, 2240, -3648, r );\n    Null( vSS, 2240, -3648, 1984, -3648, r );\n    Null( vSS, 1984, -3648, 1376, -3648, r );\n#endif \n    Wall( fT, vInf, vSS, 2240, -2920, 2272, -3008, 93, fLt, vSH, TEX_STARTAN3, r);\n    Wall( fT, vInf, vSS, 2272, -3008, 2432, -3112, 190, fLt, vSH, TEX_STARTAN3, r);\n    Wall( fT, vInf, vSS, 2432, -3112, 2736, -3112, 304, fLt-kC, vSH, TEX_STARTAN3, r);\n    Open( fT, vInf, vSS, 2736, -3112, 2736, -3360, 248, fLt+kC, vSH, 0, 136, TEX_STARTAN3, TEX_STARTAN3, r );\n    \n\t// Merge walls from Ultimate Doom secret\n\tWall( fT, vInf, vSS, 1376, -3648, 1376, -3360, 3648-3360, fLt+kC, vSH, TEX_STARTAN3, r);\n\t//Wall( fT, vInf, vSS, 1376, -3648, 1376, -3520, 128, fLt+kC, vSH, TEX_STARTAN3);\n    //Wall( fT, vInf, vSS, 1376, -3392, 1376, -3360, 32, fLt+kC, vSH, TEX_STARTAN3);\n    //Wall( fT, vInf, vSS, 1376, -3520, 1376, -3392, 128, fLt+kC, vSH, TEX_STARTAN3);\n    \n\t// Merge walls from Ultimate Doom secret\n\tWall( fT, vInf, vSS, 1472, -2880, 1856, -2880, 1856-1472, fLt-kC, vSH, TEX_STARTAN3, r);\n    //Wall( fT, vInf, vSS, 1472, -2880, 1664, -2880, 192, fLt-kC, vSH, TEX_STARTAN3);\n    //Wall( fT, vInf, vSS, 1664, -2880, 1856, -2880, 192, fLt-kC, vSH, TEX_STARTAN3);\n\t\n\t// Merge walls\n    Wall( fT, vInf, vSS, 1920, -2920, 2240, -2920, 2240-1920, fLt-kC, vSH, TEX_STARTAN3, r);\n    //Wall( fT, vInf, vSS, 1920, -2920, 2176, -2920, 256, fLt-kC, vSH, TEX_STARTAN3);\n    //Wall( fT, vInf, vSS, 2176, -2920, 2240, -2920, 64, fLt-kC, vSH, TEX_STARTAN3);\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_FLOOR7_1, TEX_F_SKY1), r );\n}\n\nvoid Sector3( inout float fT, inout vec4 vInf, Ray r )\n{\n    vec4 vSS;\n    const float fLt=1.000;\n    const vec2 vSH=vec2(8.0, 192.0);\n\n    BeginSector( vSS, vSH, r );\n    Null( vSS, 1344, -3264, 1344, -3360, r );\n    Null( vSS, 1376, -3360, 1376, -3264, r );\n    Wall( fT, vInf, vSS, 1344, -3264, 1376, -3264, 32, fLt-kC, vSH, TEX_DOORSTOP, r);\n    Wall( fT, vInf, vSS, 1376, -3360, 1344, -3360, 32, fLt-kC, vSH, TEX_DOORSTOP, r);\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_FLAT5_5, TEX_FLAT5_5), r );\n}\n\nvoid Sector5( inout float fT, inout vec4 vInf, Ray r)\n{\n    vec4 vSS;\n    const float fLt=1.000;\n    const vec2 vSH=vec2(8.0, 192.0);\n\n    BeginSector( vSS, vSH, r );\n    Null( vSS, 1344, -3104, 1344, -3200, r );\n    Null( vSS, 1376, -3200, 1376, -3104, r );\n    Wall( fT, vInf, vSS, 1376, -3200, 1344, -3200, 32, fLt-kC, vSH, TEX_DOORSTOP, r);\n    Wall( fT, vInf, vSS, 1344, -3104, 1376, -3104, 32, fLt-kC, vSH, TEX_DOORSTOP, r);\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_FLAT5_5, TEX_FLAT5_5), r );\n}\n\nvoid Sector11( inout float fT, inout vec4 vInf, Ray r )\n{\n    vec4 vSS;\n    const float fLt=1.000;\n    const vec2 vSH=vec2(-56.0, 24.0);\n\n    BeginSector( vSS, vSH, r );\n    Wall( fT, vInf, vSS, 1528, -3680, 1376, -3648, 155, fLt, vSH, TEX_BROWN144, r);\n    Wall( fT, vInf, vSS, 1672, -3744, 1528, -3680, 157, fLt, vSH, TEX_BROWN144, r);\n    Wall( fT, vInf, vSS, 1984, -3776, 1672, -3744, 313, fLt, vSH, TEX_BROWN144, r);\n    Null( vSS, 1984, -3648, 1376, -3648, r );\n    Null( vSS, 1984, -3648, 1984, -3776, r );\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_FLOOR7_1, TEX_F_SKY1), r );\n}\n\nvoid Sector12( inout float fT, inout vec4 vInf, Ray r )\n{\n    vec4 vSS;\n    const float fLt=1.000;\n    const vec2 vSH=vec2(-56.0, 64.0);\n\n    BeginSector( vSS, vSH, r );\n    Wall( fT, vInf, vSS, 2240, -3776, 2208, -3680, 101, fLt, vSH, TEX_BROWN1, r);\n    Wall( fT, vInf, vSS, 2208, -3680, 2176, -3680, 32, fLt-kC, vSH, TEX_BROWN1, r);\n    Wall( fT, vInf, vSS, 2016, -3680, 1984, -3776, 101, fLt, vSH, TEX_BROWN1, r);\n    Wall( fT, vInf, vSS, 2048, -3680, 2016, -3680, 32, fLt-kC, vSH, TEX_BROWN1, r);\n    Upper( fT, vInf, vSS, 2176, -3680, 2048, -3680, 128, fLt-kC, vSH, 16, TEX_BROWN1, r );\n    Null( vSS, 2240, -3648, 1984, -3648, r );\n    Null( vSS, 1984, -3648, 1984, -3776, r );\n    Null( vSS, 2240, -3776, 2240, -3648, r );\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_FLOOR7_1, TEX_F_SKY1), r );\n}\n\nvoid Sector24( inout float fT, inout vec4 vInf, Ray r )\n{\n    vec4 vSS;\n    const float fLt=0.565;\n    const vec2 vSH=vec2(0.0, 144.0);\n\n    BeginSector( vSS, vSH ,r);\n    Wall( fT, vInf, vSS, 1216, -2880, 1248, -2528, 353, fLt, vSH, TEX_STARTAN3,r);\n    Wall( fT, vInf, vSS, 1384, -2592, 1344, -2880, 290, fLt, vSH, TEX_STARTAN3,r);\n    Wall( fT, vInf, vSS, 1472, -2560, 1384, -2592, 93, fLt, vSH, TEX_STARTAN3,r);\n    Wall( fT, vInf, vSS, 1248, -2528, 1472, -2432, 243, fLt, vSH, TEX_STARTAN3,r);\n    Upper( fT, vInf, vSS, 1344, -2880, 1216, -2880, 128, fLt-kC, vSH, 72, TEX_STARTAN3 ,r);\n    Upper( fT, vInf, vSS, 1472, -2432, 1472, -2560, 128, fLt+kC, vSH, 88, TEX_STARTAN3 ,r);\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_FLOOR4_8, TEX_CEIL3_5) ,r);\n}\n\nvoid Sector25( inout float fT, inout vec4 vInf, Ray r )\n{\n    vec4 vSS;\n    const float fLt=1.000;\n    const vec2 vSH=vec2(0.0, 88.0);\n\n    BeginSector( vSS, vSH , r);\n    Null( vSS, 1472, -2432, 1472, -2560 , r);\n    Wall( fT, vInf, vSS, 1536, -2432, 1536, -2560, 128, fLt+kC, vSH, TEX_BIGDOOR2, r);\n    Wall( fT, vInf, vSS, 1536, -2560, 1472, -2560, 64, fLt-kC, vSH, TEX_STARTAN3, r);\n    Wall( fT, vInf, vSS, 1472, -2432, 1536, -2432, 64, fLt-kC, vSH, TEX_STARTAN3, r);\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_FLOOR4_8, TEX_TLITE6_4) , r);\n}\n\nvoid Sector27( inout float fT, inout vec4 vInf, Ray r )\n{\n    vec4 vSS;\n    const float fLt=0.878;\n    const vec2 vSH=vec2(-16.0, 200.0);\n\n    BeginSector( vSS, vSH ,r);\n    Wall( fT, vInf, vSS, 1216, -3392, 1216, -3360, 32, fLt+kC, vSH, TEX_BROWN1,r);\n    Wall( fT, vInf, vSS, 1216, -3360, 1184, -3360, 32, fLt-kC, vSH, TEX_BROWN1,r);\n    Wall( fT, vInf, vSS, 1184, -3104, 1216, -3104, 32, fLt-kC, vSH, TEX_BROWN1,r);\n    Wall( fT, vInf, vSS, 1216, -3104, 1216, -3072, 32, fLt+kC, vSH, TEX_BROWN1,r);\n    Open( fT, vInf, vSS, 1344, -3264, 1344, -3360, 96, fLt+kC, vSH, 8, 192, TEX_STARTAN3, TEX_STARTAN3 ,r);\n    Wall( fT, vInf, vSS, 1344, -3200, 1344, -3264, 64, fLt+kC, vSH, TEX_STARTAN3,r);\n    Open( fT, vInf, vSS, 1344, -3104, 1344, -3200, 96, fLt+kC, vSH, 8, 192, TEX_STARTAN3, TEX_STARTAN3 ,r);\n    Open( fT, vInf, vSS, 1344, -3360, 1216, -3392, 131, fLt, vSH, 0, 72, TEX_STEP6, TEX_STARTAN3 ,r);\n    Open( fT, vInf, vSS, 1216, -3072, 1344, -3104, 131, fLt, vSH, 0, 72, TEX_STEP6, TEX_STARTAN3 ,r);\n    Open( fT, vInf, vSS, 928, -3104, 1184, -3104, 256, fLt-kC, vSH, -8, 120, TEX_STEP6, TEX_STARTAN3 ,r);\n    Open( fT, vInf, vSS, 1184, -3360, 928, -3360, 256, fLt-kC, vSH, -8, 120, TEX_STEP6, TEX_STARTAN3 ,r);\n    Open( fT, vInf, vSS, 928, -3360, 928, -3104, 256, fLt+kC, vSH, -8, 120, TEX_STEP6, TEX_STARTAN3 ,r);\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_FLAT14, TEX_CEIL3_5) ,r);\n}\n\nvoid Sector28( inout float fT, inout vec4 vInf, Ray r )\n{\n    vec4 vSS;\n    const float fLt=0.753;\n    const vec2 vSH=vec2(-8.0, 120.0);\n\n    BeginSector( vSS, vSH , r);\n    Wall( fT, vInf, vSS, 928, -3392, 928, -3360, 32, fLt+kC, vSH, TEX_BROWN1, r);\n    Wall( fT, vInf, vSS, 928, -3360, 896, -3360, 32, fLt-kC, vSH, TEX_BROWN1, r);\n    Wall( fT, vInf, vSS, 1184, -3360, 1184, -3392, 32, fLt+kC, vSH, TEX_BROWN1, r);\n    Wall( fT, vInf, vSS, 896, -3104, 928, -3104, 32, fLt-kC, vSH, TEX_BROWN1, r);\n    Wall( fT, vInf, vSS, 928, -3104, 928, -3072, 32, fLt+kC, vSH, TEX_BROWN1, r);\n    Wall( fT, vInf, vSS, 1184, -3072, 1184, -3104, 32, fLt+kC, vSH, TEX_BROWN1, r);\n    Open( fT, vInf, vSS, 1184, -3392, 928, -3392, 256, fLt-kC, vSH, 0, 72, TEX_STEP6, TEX_COMPUTE2 , r);\n    Null( vSS, 928, -3104, 1184, -3104 , r);\n    Null( vSS, 1184, -3360, 928, -3360 , r);\n    Null( vSS, 928, -3360, 928, -3104 , r);\n    Open( fT, vInf, vSS, 896, -3360, 896, -3104, 256, fLt+kC, vSH, 0, 72, TEX_STEP6, TEX_COMPUTE2 , r);\n    Open( fT, vInf, vSS, 928, -3072, 1184, -3072, 256, fLt-kC, vSH, 0, 72, TEX_STEP6, TEX_COMPUTE2 , r);\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_FLAT14, TEX_CEIL3_5) , r);\n}\n\nvoid Sector29( inout float fT, inout vec4 vInf, Ray r )\n{\n    vec4 vSS;\n    const float fLt=0.565;\n    const vec2 vSH=vec2(0.0, 72.0);\n\n    BeginSector( vSS, vSH ,r);\n    Wall( fT, vInf, vSS, 1152, -3648, 1088, -3648, 64, fLt-kC, vSH, TEX_STARTAN3,r);\n    Wall( fT, vInf, vSS, 1024, -3648, 960, -3648, 64, fLt-kC, vSH, TEX_STARTAN3,r);\n    Wall( fT, vInf, vSS, 1280, -3552, 1152, -3648, 160, fLt, vSH, TEX_STARTAN3,r);\n    Wall( fT, vInf, vSS, 960, -3648, 832, -3552, 160, fLt, vSH, TEX_STARTAN3,r);\n    Wall( fT, vInf, vSS, 1344, -3552, 1280, -3552, 64, fLt-kC, vSH, TEX_STARTAN3,r);\n    Wall( fT, vInf, vSS, 832, -3552, 704, -3552, 128, fLt-kC, vSH, TEX_STARTAN3,r);\n    Wall( fT, vInf, vSS, 896, -3392, 928, -3392, 32, fLt-kC, vSH, TEX_BROWN1,r);\n    Wall( fT, vInf, vSS, 896, -3360, 896, -3392, 32, fLt+kC, vSH, TEX_BROWN1,r);\n    Wall( fT, vInf, vSS, 1184, -3392, 1216, -3392, 32, fLt-kC, vSH, TEX_BROWN1,r);\n    Wall( fT, vInf, vSS, 896, -3072, 896, -3104, 32, fLt+kC, vSH, TEX_BROWN1,r);\n    Wall( fT, vInf, vSS, 928, -3072, 896, -3072, 32, fLt-kC, vSH, TEX_BROWN1,r);\n    Wall( fT, vInf, vSS, 1216, -3072, 1184, -3072, 32, fLt-kC, vSH, TEX_BROWN1,r);\n    Wall( fT, vInf, vSS, 1344, -2880, 1344, -3104, 224, fLt+kC, vSH, TEX_STARTAN3,r);\n    Null( vSS, 1184, -3392, 928, -3392 ,r);\n    Null( vSS, 1344, -3360, 1216, -3392 ,r);\n    Null( vSS, 1216, -3072, 1344, -3104 ,r);\n    Wall( fT, vInf, vSS, 704, -2944, 832, -2944, 128, fLt-kC, vSH, TEX_STARTAN3,r);\n    Wall( fT, vInf, vSS, 832, -2944, 968, -2880, 150, fLt, vSH, TEX_STARTAN3,r);\n    Wall( fT, vInf, vSS, 968, -2880, 1216, -2880, 248, fLt-kC, vSH, TEX_STARTAN3,r);\n    Null( vSS, 1088, -3648, 1024, -3648 ,r);\n    Null( vSS, 896, -3360, 896, -3104 ,r);\n    Null( vSS, 928, -3072, 1184, -3072 ,r);\n#ifdef CLOSE_START_SECTOR\t\n    Wall( fT, vInf, vSS, 704, -3552, 704, -2944, 3552-2944, fLt+kC, vSH, TEX_STARTAN3,r);\n#else\n    Wall( fT, vInf, vSS, 704, -3552, 704, -3360, 192, fLt+kC, vSH, TEX_STARTAN3,r);\n    Wall( fT, vInf, vSS, 704, -3104, 704, -2944, 160, fLt+kC, vSH, TEX_STARTAN3,r);\n    Null( vSS, 704, -3104, 704, -3360,r );\n#endif\n    Null( vSS, 1344, -2880, 1216, -2880,r );\n    Wall( fT, vInf, vSS, 1344, -3360, 1344, -3392, 32, fLt+kC, vSH, TEX_STARTAN3,r);\n    \n\t// Merge walls from Ultimate Doom secret\n\tWall( fT, vInf, vSS, 1344, -3392, 1344, -3552, 3552 - 3392, fLt+kC, vSH, TEX_STARTAN3,r);\n\t//Wall( fT, vInf, vSS, 1344, -3520, 1344, -3552, 32, fLt+kC, vSH, TEX_STARTAN3);\n    //Wall( fT, vInf, vSS, 1344, -3392, 1344, -3520, 128, fLt+kC, vSH, TEX_STARTAN3);\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_FLOOR4_8, TEX_CEIL3_5),r );\n}\n\nvoid Sector30( inout float fT, inout vec4 vInf, Ray r )\n{\n    vec4 vSS;\n    float fLt=(hash(floor(iTime * 10.0)) > 0.3) ? 0.565 : 1.0;\n    const vec2 vSH=vec2(0.0, 72.0);\n\n    BeginSector( vSS, vSH ,r);\n    Wall( fT, vInf, vSS, 1088, -3680, 1024, -3680, 64, fLt-kC, vSH, TEX_DOOR3,r);\n    Wall( fT, vInf, vSS, 1024, -3680, 1024, -3648, 32, fLt+kC, vSH, TEX_LITE3,r);\n    Wall( fT, vInf, vSS, 1088, -3648, 1088, -3680, 32, fLt+kC, vSH, TEX_LITE3,r);\n    Null( vSS, 1088, -3648, 1024, -3648 ,r);\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_FLOOR4_8, TEX_CEIL3_5) ,r);\n}\n\nvoid Sector31( inout float fT, inout vec4 vInf, Ray r )\n{\n    vec4 vSS;\n    const float fLt=0.502;\n    const vec2 vSH=vec2(-8.0, 120.0);\n\n    BeginSector( vSS, vSH , r);\n    Open( fT, vInf, vSS, 704, -3104, 704, -3360, 256, fLt+kC, vSH, 0, 72, TEX_STEP6, TEX_STARTAN3 , r);\n    Wall( fT, vInf, vSS, 512, -3328, 512, -3304, 24, fLt+kC, vSH, TEX_STARTAN3, r);\n    Wall( fT, vInf, vSS, 512, -3160, 512, -3136, 24, fLt+kC, vSH, TEX_STARTAN3, r);\n    Wall( fT, vInf, vSS, 512, -3136, 680, -3104, 171, fLt, vSH, TEX_STARTAN3, r);\n    Wall( fT, vInf, vSS, 680, -3104, 704, -3104, 24, fLt-kC, vSH, TEX_SUPPORT2, r);\n    Wall( fT, vInf, vSS, 704, -3360, 680, -3360, 24, fLt-kC, vSH, TEX_SUPPORT2, r);\n    Wall( fT, vInf, vSS, 680, -3360, 512, -3328, 171, fLt, vSH, TEX_STARTAN3, r);\n    Null( vSS, 496, -3160, 496, -3304 , r);\n    Wall( fT, vInf, vSS, 512, -3304, 496, -3304, 16, fLt-kC, vSH, TEX_DOORTRAK, r);\n    Wall( fT, vInf, vSS, 496, -3160, 512, -3160, 16, fLt-kC, vSH, TEX_DOORTRAK, r);\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_FLOOR4_8, TEX_CEIL3_5) , r);\n}\n\nvoid Sector32( inout float fT, inout vec4 vInf, Ray r )\n{\n    vec4 vSS;\n    const float fLt=0.502;\n    const vec2 vSH=vec2(-8.0, 224.0);\n\n    BeginSector( vSS, vSH , r);\n    Upper( fT, vInf, vSS, 496, -3160, 496, -3304, 144, fLt+kC, vSH, 120, TEX_STARG3 , r);\n    Wall( fT, vInf, vSS, 496, -3304, 496, -3328, 24, fLt+kC, vSH, TEX_STARG3, r);\n    Wall( fT, vInf, vSS, 496, -3328, 448, -3456, 136, fLt, vSH, TEX_STARG3, r);\n    Wall( fT, vInf, vSS, 448, -3456, 128, -3456, 320, fLt-kC, vSH, TEX_STARG3, r);\n    Wall( fT, vInf, vSS, 128, -3008, 448, -3008, 320, fLt-kC, vSH, TEX_STARG3, r);\n    Wall( fT, vInf, vSS, 496, -3136, 496, -3160, 24, fLt+kC, vSH, TEX_STARG3, r);\n    Wall( fT, vInf, vSS, 448, -3008, 496, -3136, 136, fLt, vSH, TEX_STARG3, r);\n    Lower( fT, vInf, vSS, 128, -3264, 160, -3264, 32, fLt-kC, vSH, 88, TEX_SLADWALL , r);\n    Lower( fT, vInf, vSS, 160, -3264, 192, -3264, 32, fLt-kC, vSH, 72, TEX_SLADWALL , r);\n    Lower( fT, vInf, vSS, 192, -3264, 224, -3264, 32, fLt-kC, vSH, 56, TEX_SLADWALL , r);\n    Lower( fT, vInf, vSS, 224, -3264, 256, -3264, 32, fLt-kC, vSH, 40, TEX_SLADWALL , r);\n    Lower( fT, vInf, vSS, 256, -3264, 288, -3264, 32, fLt-kC, vSH, 24, TEX_SLADWALL , r);\n    Lower( fT, vInf, vSS, 288, -3264, 320, -3264, 32, fLt-kC, vSH, 8, TEX_SLADWALL , r);\n    Lower( fT, vInf, vSS, 320, -3264, 320, -3200, 64, fLt+kC, vSH, 8, TEX_STEP6 , r);\n    Lower( fT, vInf, vSS, 320, -3200, 288, -3200, 32, fLt-kC, vSH, 8, TEX_SLADWALL , r);\n    Lower( fT, vInf, vSS, 288, -3200, 256, -3200, 32, fLt-kC, vSH, 24, TEX_SLADWALL , r);\n    Lower( fT, vInf, vSS, 256, -3200, 224, -3200, 32, fLt-kC, vSH, 40, TEX_SLADWALL , r);\n    Lower( fT, vInf, vSS, 224, -3200, 192, -3200, 32, fLt-kC, vSH, 56, TEX_SLADWALL , r);\n    Lower( fT, vInf, vSS, 192, -3200, 160, -3200, 32, fLt-kC, vSH, 72, TEX_SLADWALL , r);\n    Lower( fT, vInf, vSS, 160, -3200, 128, -3200, 32, fLt-kC, vSH, 88, TEX_SLADWALL , r);\n    Open( fT, vInf, vSS, 128, -3200, 64, -3072, 143, fLt, vSH, 104, 192, TEX_STARG3, TEX_STARG3 , r);\n    Wall( fT, vInf, vSS, 64, -3072, 128, -3008, 90, fLt, vSH, TEX_STARG3, r);\n    Wall( fT, vInf, vSS, 128, -3456, 64, -3392, 90, fLt, vSH, TEX_STARG3, r);\n    Open( fT, vInf, vSS, 64, -3392, 128, -3264, 143, fLt, vSH, 104, 192, TEX_STARG3, TEX_STARG3 , r);\n    Open( fT, vInf, vSS, 256, -3136, 320, -3136, 64, fLt-kC, vSH, 40, 184, TEX_TEKWALL4, TEX_TEKWALL4 , r);\n    Open( fT, vInf, vSS, 320, -3136, 320, -3072, 64, fLt+kC, vSH, 40, 184, TEX_TEKWALL4, TEX_TEKWALL4 , r);\n    Open( fT, vInf, vSS, 320, -3072, 256, -3072, 64, fLt-kC, vSH, 40, 184, TEX_SW1COMP, TEX_TEKWALL4 , r);\n    Open( fT, vInf, vSS, 256, -3072, 256, -3136, 64, fLt+kC, vSH, 40, 184, TEX_TEKWALL4, TEX_TEKWALL4 , r);\n    Open( fT, vInf, vSS, 256, -3392, 320, -3392, 64, fLt-kC, vSH, 40, 184, TEX_TEKWALL4, TEX_TEKWALL4 , r);\n    Open( fT, vInf, vSS, 320, -3392, 320, -3328, 64, fLt+kC, vSH, 40, 184, TEX_TEKWALL4, TEX_TEKWALL4 , r);\n    Open( fT, vInf, vSS, 320, -3328, 256, -3328, 64, fLt-kC, vSH, 40, 184, TEX_TEKWALL4, TEX_TEKWALL4 , r);\n    Open( fT, vInf, vSS, 256, -3328, 256, -3392, 64, fLt+kC, vSH, 40, 184, TEX_TEKWALL4, TEX_TEKWALL4 , r);\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_FLOOR4_8, TEX_FLOOR7_2) , r);\n}\n\nvoid Sector35( inout float fT, inout vec4 vInf, Ray r )\n{\n    vec4 vSS;\n    const float fLt=1.000;\n    const vec2 vSH=vec2(40.0, 184.0);\n\n    BeginSector( vSS, vSH, r );\n    Null( vSS, 256, -3392, 320, -3392, r );\n    Null( vSS, 320, -3392, 320, -3328, r );\n    Null( vSS, 320, -3328, 256, -3328, r );\n    Null( vSS, 256, -3328, 256, -3392, r );\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_STEP2, TEX_TLITE6_1), r );\n}\n\nvoid Sector36( inout float fT, inout vec4 vInf, Ray r )\n{\n    vec4 vSS;\n    const float fLt=1.000;\n    const vec2 vSH=vec2(40.0, 184.0);\n\n    BeginSector( vSS, vSH, r );\n    Null( vSS, 256, -3136, 320, -3136, r );\n    Null( vSS, 320, -3136, 320, -3072, r );\n    Null( vSS, 320, -3072, 256, -3072, r );\n    Null( vSS, 256, -3072, 256, -3136, r );\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_STEP2, TEX_TLITE6_1), r );\n}\n\nvoid Sector63( inout float fT, inout vec4 vInf, Ray r )\n{\n    vec4 vSS;\n    const float fLt=1.000;\n    const vec2 vSH=vec2(-56.0, 24.0);\n\n    BeginSector( vSS, vSH, r );\n    Wall( fT, vInf, vSS, 2736, -3648, 2488, -3744, 265, fLt, vSH, TEX_BROWN144, r);\n    Wall( fT, vInf, vSS, 2488, -3744, 2240, -3776, 250, fLt, vSH, TEX_BROWN144, r);\n    Null( vSS, 2736, -3648, 2240, -3648, r );\n    Null( vSS, 2240, -3776, 2240, -3648, r );\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_FLOOR7_1, TEX_F_SKY1), r );\n}\n\nvoid MapIntersect( out float fClosestT, out vec4 vHitInfo, Ray r )\n{\n    vHitInfo = vec4(0.0);\n    fClosestT = 10000.0;\n\n#ifdef ENABLE_NUKAGE_SECTORS\n    Sector0( fClosestT, vHitInfo, r );\n    Sector1( fClosestT, vHitInfo, r );\n#endif\n#ifdef ENABLE_START_SECTORS\n    Sector3( fClosestT, vHitInfo, r );\n    Sector5( fClosestT, vHitInfo, r );\n#endif\n#ifdef ENABLE_EXTRA_NUKAGE_SECTORS\n    Sector11( fClosestT, vHitInfo, r );\n    Sector12( fClosestT, vHitInfo, r );\n#endif\n#ifdef ENABLE_START_SECTORS\n    Sector24( fClosestT, vHitInfo, r );\n#endif\n#ifdef ENABLE_MISC_SECTORS\t\n    Sector25( fClosestT, vHitInfo, r );\n#endif\n#ifdef ENABLE_START_SECTORS\n\tSector27( fClosestT, vHitInfo, r );\n    Sector28( fClosestT, vHitInfo, r );\n    Sector29( fClosestT, vHitInfo, r );\n    Sector30( fClosestT, vHitInfo, r );\n#endif\n#ifdef ENABLE_SECTOR_31\n    Sector31( fClosestT, vHitInfo, r );\n#endif\n#ifdef ENABLE_MISC_SECTORS\n    Sector32( fClosestT, vHitInfo, r );\n    Sector35( fClosestT, vHitInfo, r );\n    Sector36( fClosestT, vHitInfo, r );\n#endif\n#ifdef ENABLE_EXTRA_NUKAGE_SECTORS\n    Sector63( fClosestT, vHitInfo, r );\n#endif\n}\n\n\n\n// ----------------- 8< -------------------------- 8< -------------------------- 8< --------------\n// End of generated code\n\n//////////////////////////////////////////////////////////////\n// Texture Helpers\n//////////////////////////////////////////////////////////////\n\nfloat hash(float p)\n{\n\tvec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n\treturn fract(p2.x * p2.y * 95.4337);\n}\n\nfloat hash2D(vec2 p)\n{\n\treturn hash( dot( p, vec2(1.0, 41.0) ) );\t\n}\n\nfloat noise1D( float p )\n{\n\tfloat fl = floor(p);\n\t\n\tfloat h0 = hash( fl );\n\tfloat h1 = hash( fl + 1.0 );\n\t\n\tfloat fr = p - fl;\n\tfloat fr2 = fr * fr;\n\tfloat fr3 = fr2 * fr;\n\t\n\tfloat t1 = 3.0 * fr2 - 2.0 * fr3;\t\n\tfloat t0 = 1.0 - t1;\n\t\n\treturn h0 * t0\n\t\t + h1 * t1;\n}\n\nfloat noise2D( vec2 p, float r )\n{\n\tvec2 fl = floor(p);\n\n\tfloat h00 = hash2D( mod(fl + vec2(0.0, 0.0), r) );\n\tfloat h10 = hash2D( mod(fl + vec2(1.0, 0.0), r) );\n\tfloat h01 = hash2D( mod(fl + vec2(0.0, 1.0), r) );\n\tfloat h11 = hash2D( mod(fl + vec2(1.0, 1.0), r) );\n\t\n\tvec2 fr = p - fl;\n\t\n\tvec2 fr2 = fr * fr;\n\tvec2 fr3 = fr2 * fr;\n\t\n\tvec2 t1 = 3.0 * fr2 - 2.0 * fr3;\t\n\tvec2 t0 = 1.0 - t1;\n\t\n\treturn h00 * t0.x * t0.y\n\t\t + h10 * t1.x * t0.y\n\t\t + h01 * t0.x * t1.y\n\t\t + h11 * t1.x * t1.y;\n}\n\nfloat fbm( vec2 p, float per )\n{\n\tfloat val = 0.0;\n\tfloat tot = 0.0;\n\tfloat mag = 0.5;\n\n\tp += 0.5;\n\tp = p * (1.0 / 8.0);\n\tval += noise2D(p, 4.0) * mag; tot+=mag; p=p*2.0 + 1.234; mag*=per;\t\n\tval += noise2D(p, 8.0) * mag; tot+=mag; p=p*2.0 + 2.456; mag*=per;\n\tval += noise2D(p, 16.0) * mag; tot+=mag; p=p*2.0 + 3.678; mag*=per;\n\tval += noise2D(p, 32.0) * mag; tot+=mag;\n\n\treturn val * (1.0 / tot);\n}\n\nfloat Indent(vec2 vTexCoord, vec2 vHigh, vec2 vLow, float fHighIntensity, float fLowIntensity)\n{\n\tvec2 vMin = min(vLow, vHigh);\n\tvec2 vMax = max(vLow, vHigh);\n\tif((vTexCoord.x < vMin.x) || (vTexCoord.x > vMax.x) || (vTexCoord.y < vMin.y) || (vTexCoord.y > vMax.y))\n\t\treturn 1.0;\n\n\tif((vTexCoord.x == vHigh.x) || (vTexCoord.y == vHigh.y))\n\t{\n\t\treturn fHighIntensity;\n\t}\n\t\n\tif((vTexCoord.x == vLow.x) || (vTexCoord.y == vLow.y))\n\t{\n\t\treturn fLowIntensity;\n\t}\n\t\n\treturn 1.0;\n}\n\nvec4 SmoothBump(const in vec2 vTexCoord, const in vec2 vMin, const in vec2 vMax, const in vec2 vLightDir, const in float fSize)\n{\n\tvec2 vNearest = min( max(vTexCoord, vMin), vMax );\n\tvec2 vDelta = vNearest - vTexCoord;\n    float fDeltaLen = length(vDelta);\n\tfloat fDist = (fDeltaLen - fSize) / fSize;\n\tvec2 vDir = vDelta;\n    if(fDeltaLen > 0.0) vDir = vDir / fDeltaLen;\n\tfloat fShade = dot(vDir, vLightDir);\n\t//return clamp(1.0 - (fDist / fSize), 0.0, 1.0) * fShade;\n\tfShade *= clamp(1.0 - abs((fDist)), 0.0, 1.0);\n\treturn vec4( fShade, fDist, (vTexCoord - vMin + fSize) / (vMax - vMin + fSize * 2.0) );\n}\n\n\nfloat wrap( const in float x , const in float r )\n{\n\treturn fract( x * (1.0 / r) ) * r;\n}\n\nvec4 Hexagon( vec2 vUV )\n{\n\tvec2 vIndex;\n\t\n\tfloat fRow = floor(vUV.y);\n\t\n\tvec2 vLocalUV = vUV;\n\tfloat fRowEven = wrap(fRow, 2.0);\n\tif(fRowEven < 0.5)\n\t{\n\t\tvLocalUV.x += 0.5;\n\t}\n\t\n\tvIndex = floor(vLocalUV);\n\t\n\tvec2 vTileUV = fract(vLocalUV);\n\t{\n\t\tfloat m = 2.0 / 3.0;\n\t\tfloat c = 2.0 / 3.0;\n\t\tif((vTileUV.x *m + c) < vTileUV.y)\n\t\t{\n\t\t\tif(fRowEven < 0.5)\n\t\t\t{\n\t\t\t\tvIndex.x -= 1.0;\n\t\t\t}\n\t\t\tfRowEven = 1.0 - fRowEven;\t\t\t\t\n\t\t\tvIndex.y += 1.0;\n\t\t}\n\t}\n\t\n\t{\n\t\tfloat m = -2.0 / 3.0;\n\t\tfloat c = 4.0 / 3.0;\n\t\tif((vTileUV.x *m + c) < vTileUV.y)\n\t\t{\n\t\t\tif(fRowEven >= 0.5)\n\t\t\t{\n\t\t\t\tvIndex.x += 1.0;\n\t\t\t}\n\t\t\tfRowEven = 1.0 - fRowEven;\t\t\t\t\n\t\t\tvIndex.y += 1.0;\n\t\t}\n\t}\n\t\n\tvec2 vCenter = vIndex - vec2(0.0, -1.0 / 3.0);\n\tif(fRowEven > 0.5)\n\t{\n\t\tvCenter.x += 0.5;\n\t}\n\t\n\tvec2 vDelta = vUV - vCenter;\n\t\n\t//vDelta = abs(vDelta);\n\t\n\tfloat d1 = vDelta.x;\n\tfloat d2 = dot(vDelta, normalize(vec2(2.0/3.0, 1.0)));\n\tfloat d3 = dot(vDelta, normalize(vec2(-2.0/3.0, 1.0)));\n\t\n\td2 *= 0.9;\n\td3 *= 0.9;\n\t\n\tfloat fDist = max( abs(d1), abs(d2) );\n\tfDist = max( fDist, abs(d3) );\n\t\n\tfloat fTest = max(max(-d1, -d2), d3);\n\t\n\treturn vec4(vIndex, abs(fDist), fTest);\n}\n\n\n//////////////////////////\n// Textures\n//////////////////////////\n\nvec3 TexNukage3( vec2 vTexCoord, float fRandom)\n{\n\tfloat fBlend = 0.0;\n\tfBlend = smoothstep(0.8, 0.0, fRandom);\n\tfBlend = min(fBlend, smoothstep(1.0, 0.8, fRandom));\n\tfBlend *= 1.5;\n\tvec3 col = mix( vec3(11.0, 23.0, 7.0), vec3(46.0, 83, 39.0), fBlend) / 255.0;\n\t\n\treturn col;\n}\n\nvoid AddMountain( inout float fShade, const in vec2 vUV, const in float fRandom, const in float fHRandom, const in float fXPos, const in float fWidth, const in float fHeight, const in float fFog)\n{\n\tfloat fYPos = 1.0 - smoothstep( 0.0, 1.0, abs(fract(fXPos - vUV.x + vUV.y * 0.05 + 0.5) - 0.5) * fWidth );\n\tfYPos += fHRandom * 0.05 + fRandom * 0.05;\n\tfYPos *= fHeight;\n\tfloat fDist = fYPos - vUV.y;\n\tif(fDist > 0.0)\n\t{\n\t\tfShade = fRandom * ((1.0 - clamp(sqrt(fDist) * 2.0, 0.0, 1.0)) * 0.3 + 0.1);\n\t\tfShade = mix(fShade, 0.6 + 0.1 * fRandom, fFog);\n\t}\t\n}\n\nvec3 TexFSky1(vec2 vTexCoord, float fRandom, float fHRandom)\n{\n\tfloat fShade = 0.6 + 0.1 * fRandom;\n\t\n\tvec2 vUV = vTexCoord * (1.0 / vec2(256.0, 128.0));\n\tvUV.y = 1.0 - vUV.y;\n\t\n\tAddMountain( fShade, vUV, fRandom, fHRandom, 0.25, 1.0, 0.85, 0.5 );\n\tAddMountain( fShade, vUV, fRandom, fHRandom, 1.5, 4.0, 0.78, 0.2 );\n\tAddMountain( fShade, vUV, fRandom, fHRandom, 1.94, 2.51, 0.8, 0.0 );\n\n\t\n\treturn vec3(fShade);\n}\n\nvec3 TexFloor7_1( vec2 vTexCoord, float fRandom )\n{\n\tvec3 col = mix( vec3(51.0, 43.0, 19.0), vec3(79.0, 59, 35.0), fRandom * fRandom * 2.5) / 255.0;\n\t\n\treturn col;\n}\n\nvec3 TexFlat5_5( vec2 vTexCoord, float fRandom )\n{\n\tvec3 col = mix( vec3(63.0, 47.0, 23.0), vec3(147.0, 123.0, 99.0), fRandom) / 255.0;\n\t\n\tcol *= mod(vTexCoord.x, 2.0) * 0.15 + 0.85;\n\t\n\treturn col;\n}\n\nvec3 TexFloor4_8( vec2 vTexCoord, float fRandom )\n{\n\tvec3 col = mix( vec3(30.0, 30.0, 30.0), vec3(150.0, 150.0, 150.0), fRandom * fRandom) / 255.0;\n\n\tvec4 vHex = Hexagon( vTexCoord.yx / 32.0 );\n    \n    float fShadow = (clamp((0.5 - vHex.z) * 15.0, 0.0, 1.0) * 0.5 + 0.5);\n    float fHighlight = 1.0 + clamp(1.0 - (abs(0.45 - vHex.w)) * 32.0, 0.0, 1.0) * 0.5;\n    \n\tcol = col * (clamp((0.5 - vHex.z) * 2.0, 0.0, 1.0) * 0.25 + 0.75);\n    col = col * fHighlight;\n\tcol = col * fShadow;\n\t\n\treturn col;\n}\n\nvec3 TexCeil3_5( vec2 vTexCoord, float fRandom )\n{\n\tvec3 col = vec3(1.0);\n\t\n\tvec2 vTileCoord = vTexCoord;\n\tvTileCoord.x -= 17.0;\n\tif( (vTileCoord.x >= 0.0) && (vTileCoord.x < 32.0) ) \n\t\tvTileCoord.y -= 58.0;\n\telse \n\t\tvTileCoord.y -= 11.0;\n\tvTileCoord.x = mod(vTileCoord.x, 32.0);\n\tvTileCoord.y = mod(vTileCoord.y, 64.0);\n\t\t\n\tvec2 vBoxClosest = clamp(vTileCoord, vec2(4.0, 4.0), vec2(28.0, 60.0));\n\tvec2 vDelta = vTileCoord - vBoxClosest;\n\tfloat fDist2 = dot(vDelta, vDelta);\n\n\tconst float fLight1 = 59.0 / 255.0;\n\tconst float fMed1 = 55.0 / 255.0;\n\tconst float fDark1 = 47.0 / 255.0;\n\tconst float fDark2 = 39.0 / 255.0;\n\n\tfloat fShade = fMed1;\t\n\tfShade = mix( fShade, fLight1, smoothstep(0.6, 0.45, fRandom) );\n\tfShade = mix( fShade, fDark1, smoothstep(0.45, 0.35, fRandom) );\n\t\n\tfShade = mix( fShade, fDark1, step(1.5, fDist2) );\n\tfShade = mix( fShade, fDark2, step(13.5, fDist2) );\n\t\t\n\tcol *= fShade;\n\t\n\tif((vTileCoord.x < 12.0) || (vTileCoord.x > 20.0) || (vTileCoord.y < 12.0) || (vTileCoord.y > 52.0))\n\t{\n\t\tfloat fRRow = floor(mod(vTileCoord.y - 3.5, 7.5));\n\t\tfloat fRColumn = mod(vTileCoord.x - 15.0, 10.0);\n\t\tif((fRRow == 2.0) && (fRColumn == 0.0))\n\t\t{\n\t\t\tcol -= 0.05;\n\t\t}\n\t\tif((fRRow <= 2.0) && (fRColumn <= 2.0))\n\t\t{\n\t\t\tvec2 vOffset = vec2(fRRow - 1.0, fRColumn - 1.0);\n\t\t\tfloat fDist2 = dot(vOffset, vOffset) / 2.0;\n\t\t\tcol += clamp(1.0 - fDist2, 0.0, 1.0) * 0.05;\n\t\t}\n\t}\n\t\n\treturn col;\n}\n\nvec3 TexFlat14( vec2 vTexCoord, float fRandom )\n{\n\treturn mix( vec3(0.0, 0.0, 35.0 / 255.0), vec3(0.0, 0.0, 200.0 / 255.0), fRandom * fRandom);\n}\n\nvec3 TexDoor3(vec2 vTexCoord, float fRandom, float fHRandom)\n{\n\tfloat fVNoise = fHRandom + fRandom;\n\tfloat fStreak = clamp(abs(fract(fVNoise) - 0.5) * 3.0, 0.0, 1.0);\n\tfStreak = fStreak * fStreak;\n\t\n\tfloat fShade = 1.0;\n\t\n\tfShade = 1.0 - abs((vTexCoord.y / 72.0) - 0.5) * 2.0;\n\tfShade = fShade * fShade;\n\tfShade = fShade * 0.2 + 0.3;\n\t\n\tfShade = fShade * (fHRandom * 0.2 + 0.8);\n\t\n\tfShade *= Indent( vTexCoord, vec2(8.0, 8.0), vec2(64.0 - 8.0, 72.0 - 16.0), 0.8, 1.2);\n\tfShade *= Indent( vTexCoord, vec2(8.0, 72.0 - 15.0), vec2(64.0 - 8.0, 72.0 - 8.0), 0.8, 1.2);\n\t\n\tfShade *= Indent( vTexCoord, vec2(64.0 - 11.0, 46.0), vec2(46.0, 32.0), 0.8, 1.2);\n\tfShade *= Indent( vTexCoord, vec2(64.0 - 11.0, 56.0), vec2(46.0, 52.0), 0.8, 1.2);\n\t\n\tfShade += fRandom * 0.1;\n\n\tfloat fStreakTopAmount = smoothstep( 32.0, 0.0, vTexCoord.y );\n\tfloat fStreakBottomAmount = smoothstep( 72.0 -32.0, 72.0, vTexCoord.y );\n\t\n\tfShade *= 1.0 - fStreak * max(fStreakTopAmount, fStreakBottomAmount) * 0.2;\n\t\n\tif( (vTexCoord.x > 8.0) && (vTexCoord.x < 52.0) )\n\t{\n\t\tvec2 vRepeatCoord = mod( vTexCoord, vec2( 8.0, 48.0 ) );\n\t\tvRepeatCoord += vec2(4.0, -12.0);\n\t\tif( vRepeatCoord.x == 4.0 )\n\t\t{\n\t\t\tif(vRepeatCoord.y == 0.0)\n\t\t\t{\n\t\t\t\tfShade += 0.1;\n\t\t\t}\n\t\t\tif(vRepeatCoord.y > 0.0)\n\t\t\t{\n\t\t\t\tfShade *= clamp(vRepeatCoord.y / 16.0, 0.0, 1.0) * 0.3 + 0.7;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn vec3(fShade);\n}\n\nvec3 TexLite3( vec2 vTexCoord )\n{\n\tvec2 vLocalCoord = vTexCoord;\n\tvLocalCoord.y = mod(vLocalCoord.y, 8.0 );\n\t\n\tvec2 vClosest = min( max( vLocalCoord, vec2(4.0, 3.5) ), vec2(32.0 - 5.0, 3.5) );\n\tvec2 vDelta = vLocalCoord - vClosest;\n\tfloat fDist = max(abs(vDelta.x), abs(vDelta.y)) / 3.9;\n\t\n\treturn vec3(1.0 - fDist * 0.65);\n}\n\nvec3 TexStartan3( vec2 vTexCoord, float fRandom )\n{\n\tvec3 col = vec3(0.6);\n\t\n\tfloat fVNoise = noise1D(vTexCoord.x * 0.5) - ((vTexCoord.y) / 128.0) + fRandom;\n\tfloat fStreak = clamp(abs(fract(fVNoise) - 0.5) * 3.0, 0.0, 1.0);\n\tfStreak = fStreak * fStreak;\n\t\t\n\tfloat fBlend2 = smoothstep( 0.0, 32.0, abs(vTexCoord.x - 64.0) );\n\tfBlend2 *= fBlend2;\n\tfBlend2 *= fStreak * 0.5 + 0.5;\n\tcol = mix( col, vec3(119.0, 79.0, 43.0) / 255.0, fBlend2 * 0.5);\n\t\n\tfloat fBlend = smoothstep( 24.0, 56.0, abs(vTexCoord.x - 64.0) );\n\tfBlend *= fBlend;\n\tfBlend *= fStreak * 0.7 + 0.3;\n\tcol = mix( col, vec3(119.0, 79.0, 43.0) * 1.1 / 255.0, fBlend);\n\t\n\tcol *= fRandom * fRandom * 0.3 + 0.7;\n\n\tvec2 vCoord = vTexCoord;\n\tvCoord.x = mod(vCoord.x, 32.0);\n\t\n\tfloat fStreakHL = fStreak * 0.075 + 0.075;\n\t\n\tfloat fDistMin = 1.0;\n\tfloat fShade = 0.0;\n\t\n\tvec4 vBump = SmoothBump( vCoord, vec2(6.0, 8.0), vec2(32.0 - 5.0, 9.0), normalize(vec2(0.0, 1.0)), 3.0 );\n\tfShade += vBump.x * 0.1;\n\tfDistMin = min(fDistMin, vBump.y);\n\tfShade += ((vBump.w >= 0.0) && (vBump.w <= 1.0)) ? (1.0 - vBump.w) * fStreakHL : 0.0;\n\tvBump = SmoothBump( vCoord, vec2(6.0, 20.0), vec2(32.0 - 6.0, 40.0), normalize(vec2(0.0, 1.0)), 3.0 ); \n\tfShade += vBump.x * 0.1;\n\tfShade += ((vBump.w >= 0.0) && (vBump.w <= 1.0)) ? (1.0 - vBump.w) * fStreakHL : 0.0;\n\tfDistMin = min(fDistMin, vBump.y);\n\n\tvBump = SmoothBump( vCoord, vec2(6.0, 64.0), vec2(32.0 - 6.0, 65.0), normalize(vec2(0.0, 1.0)), 3.0 );\n\tfShade += vBump.x * 0.1;\n\tfShade += ((vBump.w >= 0.0) && (vBump.w <= 1.0)) ? (1.0 - vBump.w) * fStreakHL : 0.0;\n\tfDistMin = min(fDistMin, vBump.y);\n\tvBump = SmoothBump( vCoord, vec2(6.0, 76.0), vec2(32.0 - 6.0, 110.0), normalize(vec2(0.0, 1.0)), 3.0 ) ;\n\tfShade += vBump.x * 0.1;\n\tfShade += ((vBump.w >= 0.0) && (vBump.w <= 1.0)) ? (1.0 - vBump.w) * fStreakHL : 0.0;\n\tfDistMin = min(fDistMin, vBump.y);\n\n\tvBump = SmoothBump( vTexCoord, vec2(-16.0, 50.0), vec2(256.0, 52.0), normalize(vec2(0.0, 1.0)), 3.0 );\n\tfShade += vBump.x * 0.1;\n\tfShade += ((vBump.w >= 0.0) && (vBump.w <= 1.0)) ? (1.0 - vBump.w) * fStreakHL : 0.0;\n\tfDistMin = min(fDistMin, vBump.y);\n\tvBump = SmoothBump( vTexCoord, vec2(-16.0, 122.0), vec2(256.0, 200.0), normalize(vec2(0.0, 1.0)), 3.0 );\n\tfShade += vBump.x * 0.05;\n\tfDistMin = min(fDistMin, vBump.y);\n\n\tcol *= 1.0 + fShade * 3.0;\n\n\tcol *= clamp((1.0 - fDistMin) * 1.0, 0.0, 1.0) * 0.3 + 0.7;\n\n\treturn col;\n}\n\nvec3 TexBrown1( vec2 vTexCoord, float fRandom, float fHRandom )\n{\n\tvec3 col = mix( vec3(119.0, 95.0, 63.0), vec3(147.0, 123.0, 99.0), fRandom * fRandom) / 255.0;\n\n\tif(vTexCoord.x >= 64.0)\n\t{\n\t\tcol = col * vec3(1.0, 0.848, 0.646);\n\t\t\n\t\tcol = mix( col, vec3( 0.111, 0.414, 0.3), clamp((fRandom -0.5) * 2.0, 0.0, 1.0)); // green bits\n\t}\n\t\n\tfloat fVNoise = fHRandom + fRandom;\n\t\n\tfloat fStreak = clamp(abs(fract(fVNoise) - 0.5) * 3.0, 0.0, 1.0);\n\tfStreak = fStreak * fStreak;\n\n\tvec2 vRepeatCoord = vTexCoord;\n\tvRepeatCoord.x = mod(vRepeatCoord.x, 13.0);\n\t\n\tvec4 vBump = SmoothBump( vRepeatCoord, vec2( 5.0, 6.0 ), vec2( 5.0, 12.0), vec2(0.0, 1.0), 1.5);\n\tfloat fMask = clamp(1.0 - vBump.y, 0.0, 1.0);\n\t\n\tfloat fStreakAmount = 1.0;\n\tfStreakAmount *= smoothstep( 0.0, 8.0, vRepeatCoord.y );\n\tfloat fStreakWidth = smoothstep( 64.0, 12.0, vRepeatCoord.y );\n\tfloat fBase1Dist = smoothstep( 24.0, 75.0, vRepeatCoord.y ) * step(vRepeatCoord.y, 75.0);\n\tfloat fBase2Dist = smoothstep( 96.0, 127.0, vRepeatCoord.y );// * step(75.0, vRepeatCoord.y);\n\tfloat fBaseDist = max(fBase1Dist, fBase2Dist);\n\tfStreakWidth = max( fStreakWidth, fBaseDist);\n\tfloat fTop2Dist = smoothstep( 127.0, 75.0, vRepeatCoord.y ) * step(75.0, vRepeatCoord.y);\n\tfStreakWidth = max(fStreakWidth, fTop2Dist);\n\tfloat fStreakX = abs(vRepeatCoord.x - 5.0) / 8.0;\n\tfStreakAmount *= fStreakWidth;\n\tfStreakAmount *= smoothstep( fStreakWidth, 0.0, fStreakX);\n\tfStreakAmount = max(fStreakAmount, (fBaseDist - 0.75) * 4.0);\n\tfStreakAmount *= 1.0 - fMask; \n\tcol = mix(col, vec3(0.3, 0.2, 0.1), fStreakAmount * (fStreak * 0.5 + 0.5) );\n\t\n\tcol += ((vBump.w >= 0.0) && (vBump.w <= 1.0)) ? (vBump.w) * (1.0-vBump.y) * 0.05 : 0.0;\n\t\n\tif((vTexCoord.y == 17.0) || (vTexCoord.y == 73.0)) col *= 0.9;\n\tif((vTexCoord.y == 19.0) || (vTexCoord.y == 75.0)) col *= 1.2;\n\n\tcol *= 1.0 + clamp(vBump.x, -1.0, 0.0) * 0.6;\n\t\t\n\treturn col;\n}\n\nvec3 TexDoorstop( vec2 vTexCoord, float fRandom )\n{\n\tfloat fShade = 1.0 - abs(vTexCoord.x - 3.4) / 4.0;\n\t\n\tfShade = fShade * 0.2 + 0.2;\n\t\n\tfloat fSin = sin((vTexCoord.y - 16.0) * 3.14150 * 4.0 / 128.0) * 0.5 + 0.5;\n\tfShade *= 0.8 + fRandom * 1.2 * fSin;\n\t\n\treturn vec3(fShade);\n}\n\nvoid DrawScreen(inout vec3 col, const in vec2 vTexCoord, const in vec2 vPos, const in vec2 vSize, const in vec3 vCol)\n{\n\tvec2 vScreenCoord = vTexCoord - vPos;\n\tcol *= Indent( vScreenCoord, vSize, vec2(-1.0), 1.2, 0.5);\n\n\tif((vScreenCoord.x >= 0.0) && (vScreenCoord.y >= 0.0) && (vScreenCoord.x < vSize.x) && (vScreenCoord.y < vSize.y))\n\t{\n\t\tcol = vCol;\n\t}\n}\n\nvec3 TexCompute2( vec2 vTexCoord, float fRandom )\n{\n    fRandom = 1.0 - fRandom * fRandom;\n\tvec3 col = vec3(35.0 / 255.0);\n\t\n\tcol *= Indent( vTexCoord, vec2( -8.0, 0.0), vec2(300.0, 10.0), 1.3, 0.5);\n\tcol *= Indent( vTexCoord, vec2( -8.0, 11.0), vec2(300.0, 27.0), 1.3, 0.5);\n\tcol *= Indent( vTexCoord, vec2( -8.0, 28.0), vec2(300.0, 43.0), 1.3, 0.5);\n\t{\n\t\tvec2 vLocalCoord = vTexCoord;\n\t\tvLocalCoord.x = mod(vLocalCoord.x, 21.0);\n\t\tcol *= Indent( vLocalCoord, vec2( 0.0, 44.0), vec2(20.0, 55.0), 1.3, 0.5);\n\t}\n\n\tif(vTexCoord.y < 40.0)\n\t{\n\t\tvec2 vTileSize = vec2(48.0, 14.0);\n\t\tvec2 vIndex = floor(vTexCoord / vTileSize);\n\n\t\tfloat fIndex = vIndex.x + vIndex.y * 13.0;\n\t\tvec2 vMin = vIndex * vTileSize + vec2(hash(fIndex) * 32.0, 4.0);\n\t\tvec2 vSize = vec2(8.0 + hash(fIndex + 1.0) * 32.0, 4.0);\n\n\t\tvec3 vCol = vec3(0.0);\n\t\tfloat iIndex = floor(mod(fIndex, 5.0));\n\t\tif( iIndex < 0.5 ) \n\t\t{\n\t\t\tvCol = mix(vec3(0.0, 0.5, 0.0), vec3(0.0, 0.25, 0.0), fRandom);\n\t\t}\n\t\telse if(iIndex < 1.5)\n\t\t{\n\t\t\tvCol = mix(vec3(1.0, 0.6, 0.02), vec3(0.1), fRandom);\n\t\t}\n\t\telse if(iIndex < 2.5)\n\t\t{\n\t\t\tvCol = vec3(fRandom * 0.5);\n\t\t}\n\t\telse if(iIndex < 3.5)\n\t\t{\n\t\t\tvCol = vec3(fRandom * 0.25);\n\t\t}\n\t\telse if(iIndex < 4.5)\n\t\t{\n\t\t\tvCol = mix(vec3(0.0, 0.0, 0.5), vec3(0.1), fRandom);\n\t\t}\n\t\tDrawScreen(col, vTexCoord, vMin, vSize, vCol);\n\t}\n\n\treturn col;\n}\n\nvec3 TexStep6( vec2 vTexCoord, float fRandom, float fHRandom )\n{\n\tvec3 col = mix( vec3(87.0, 67.0, 51.0), vec3(119.0, 95.0, 75.0), fRandom) / 255.0;\n\n\tcol *= Indent( vTexCoord, vec2(-1.0, 3.0), vec2(32.0, 1.0), 1.3, 0.7);\n\tcol *= Indent( vTexCoord, vec2(-1.0, 8.0), vec2(32.0, 0.0), 1.3, 0.9);\n\n\tfloat fStreak = clamp((vTexCoord.y / 16.0) * 1.5 - fHRandom, 0.0, 1.0);\n\n\tcol *= fStreak * 0.3 + 0.7;\n\t\n\treturn col;\n}\n\nvec3 TexSupport2( vec2 vTexCoord, float fRandom )\n{\n\tvec3 col;\n\tfloat fShade = 0.5;\n\t\n\tfloat f1 = abs(fract((vTexCoord.y + 32.0) / 70.0) - 0.5) * 2.0;\n\tfloat f2 = abs(fract((vTexCoord.x + 16.0) / 16.0) - 0.5) * 2.0;\n\tfShade += f1 * 0.75 + f2 * 0.25;\n\tfShade = fShade * fShade;\n\n\tfShade = fShade * 0.2 + 0.05;\n\tfShade *= 1.0 + fRandom * 0.4;\n\n\tvec2 vLocalCoord = vTexCoord;\n\tif((vLocalCoord.y < 64.0) || (vLocalCoord.y > 75.0))\n\t{\n\t\tif(vLocalCoord.y > 64.0) vLocalCoord.y -= 8.0;\n\t\tvLocalCoord = mod( vLocalCoord, vec2(20.0, 16.0));\n\t\tfloat fIndent = Indent( vLocalCoord, vec2(8.0, 8.0), vec2(16.0, 15.0), 0.9, 1.1);\n\t\tfShade += fIndent - 1.0;\n\t}\n\t\n\tcol = vec3(fShade);\n\t\n\treturn col;\n}\n\nvec3 TexDoorTrak( vec2 vTexCoord, float fRandom )\n{\n\tfloat fShade = fRandom * 0.5;\n\tfShade *= mod(vTexCoord.x, 2.0) * 0.6 + 0.4;\n\treturn vec3(fShade);\n}\n\nvec3 TexBrown144( vec2 vTexCoord, float fRandom, float fHRandom )\n{\n\tvec3 col = mix( vec3(39.0, 39.0, 39.0), vec3(51.0, 43.0, 19.0), fRandom) / 255.0;\n\t\n\tfloat fBlend = fHRandom - 0.1;\n\tfBlend = clamp(fBlend, 0.0, 1.0);\n\tcol = mix( col, col * 2.0 * vec3(0.893, 0.725, 0.161), fBlend);\n\treturn col;\n}\n\n#ifdef ENABLE_SPRITES\n\nvec3 TexBar1A( vec2 vTexCoord, float fRandom, float fHRandom )\n{\n\tvec3 col = vec3(123.0, 127.0, 99.0) / 255.0;\n\t\n\tfloat fBrownStreakBlend = smoothstep( 2.0, 1.0, abs(vTexCoord.x - 3.5));\n\tcol = mix(col, vec3(0.724, 0.736, 0.438), fBrownStreakBlend);\n\t\n\tif( (vTexCoord.y == 1.0) && (vTexCoord.x > 3.0) && (vTexCoord.x < 18.0) )\n\t{\n\t\tcol = col * clamp(((vTexCoord.x / 18.0)), 0.0, 1.0);\t\t\n\t}\n\telse\n\t{\n\t\tcol = col * clamp((1.0 - (vTexCoord.x / 18.0)), 0.0, 1.0);\t\t\n\t}\n\t\n\tfloat fNukageBlend = 0.0;\n\tif( (vTexCoord.y == 1.0) && (vTexCoord.x > 8.0) && (vTexCoord.x < 14.0) )\n\t{\n\t\tfNukageBlend = 1.0;\n\t}\t\n\tif( (vTexCoord.y == 2.0) && (vTexCoord.x > 2.0) && (vTexCoord.x < 20.0) )\n\t{\n\t\tfNukageBlend = 1.0;\n\t}\t\n\tcol = mix(col, vec3(0.172, 0.560, 0.144) * fRandom, fNukageBlend);\n\t\n\t\n\tif(vTexCoord.x < 1.0)\n\t{\n\t\tcol += 0.1;\n\t}\n\t\n\tfloat fBlend = clamp(((vTexCoord.x - 20.0) / 3.0), 0.0, 1.0);\n\tcol += fBlend * 0.2;\n\t\n\tfloat fBumpY = 8.0;\n\tif(vTexCoord.y > 14.0) fBumpY += 9.0;\n\tif(vTexCoord.y > 23.0) fBumpY += 8.0;\n\n\tvec4 vBump = SmoothBump( vTexCoord, vec2(2.0, fBumpY), vec2(23.0 - 2.0, fBumpY), normalize(vec2(-0.2, 1.0)), 1.25 );\t\n\tcol += vBump.x * 0.2;\n\n\t// rim highlights\n\t{\n\t\tvec2 vOffset = (vTexCoord - vec2(17.0, 0.0)) / vec2(8.0, 2.0);\n\t\tcol += clamp(1.0 - dot(vOffset, vOffset), 0.0, 1.0) * 0.2;\n\t}\t\n\t{\n\t\tvec2 vOffset = (vTexCoord - vec2(20.0, 1.0)) / vec2(4.0, 1.0);\n\t\tcol += clamp(1.0 - dot(vOffset, vOffset), 0.0, 1.0) * 0.2;\n\t}\t\n\t{\n\t\tvec2 vOffset = (vTexCoord - vec2(3.0, 2.0)) / vec2(4.0, 2.0);\n\t\tcol += clamp(1.0 - dot(vOffset, vOffset), 0.0, 1.0) * 0.2;\n\t}\t\n\t\n\tcol *= 0.5 + fRandom * 0.5;\n\t\n\treturn col;\n}\n\nvec3 TexPlayW( vec2 vTexCoord, float fRandom, float fHRandom )\n{\n    vec3 col = mix(vec3(190.0, 10.0, 10.0), vec3(50, 16.0, 16.0 ), fRandom * vTexCoord.y/18.0) / 255.0;\n\treturn col;\n}\n\n#endif \n\nvec3 SampleTexture( const in float fTexture, const in vec2 _vUV )\n{\n    vec3 col = vec3(1.0, 0.0, 1.0);\n    vec2 vUV = _vUV;\n    \n    vec2 vSize = vec2(64.0);\n    float fPersistence = 0.8;\n\tfloat fNoise2Freq = 0.5;\n\n\tif(fTexture == TEX_NUKAGE3)\n\t{\n        float fTest = fract(floor(iTime * 6.0) * (1.0 / 3.0));\n        if( fTest < 0.3 )\n        {\n\t        vUV += 0.3 * vSize;\n        }\n        else if(fTest < 0.6)\n        {\n            vUV = vUV.yx - 0.3; \n        }\n        else\n        {\n            vUV = vUV + 0.45;\n        }\n\t}\n\t\n\t     if(fTexture == TEX_NUKAGE3) { fPersistence = 1.0; }\n\telse if(fTexture == TEX_F_SKY1) { vSize = vec2(256.0, 128.0); fNoise2Freq = 0.3; }\n    else if(fTexture == TEX_FLOOR7_1) { vSize = vec2(64.0, 32.0); fPersistence = 1.0; }\t\n    else if(fTexture == TEX_FLAT5_5) { fPersistence = 3.0; }\n    else if(fTexture == TEX_FLOOR4_8) { fPersistence = 0.3; }\n    else if(fTexture == TEX_CEIL3_5) { fPersistence = 0.9; }\t\n    else if(fTexture == TEX_FLAT14) { fPersistence = 2.0; }\n    else if(fTexture == TEX_DOOR3) { vSize = vec2(64.0, 72.0); }\t\n    else if(fTexture == TEX_LITE3) { vSize = vec2(32.0, 128.0); }\t\n    else if(fTexture == TEX_STARTAN3) { vSize = vec2(128.0); fPersistence = 1.0; }\t\n\telse if(fTexture == TEX_BROWN1) { vSize = vec2(128.0); fPersistence = 0.7; }\t\n    else if(fTexture == TEX_DOORSTOP) { vSize = vec2(8.0, 128.0); fPersistence = 0.7; }\n    else if(fTexture == TEX_COMPUTE2) { vSize = vec2(256.0, 56.0); fPersistence = 1.5; }\n    else if(fTexture == TEX_STEP6) { vSize = vec2(32.0, 16.0); fPersistence = 0.9; }\n    else if(fTexture == TEX_SUPPORT2) { vSize = vec2(64.0, 128.0); }\n    else if(fTexture == TEX_DOORTRAK) { vSize = vec2(8.0, 128.0); }\n#ifdef ENABLE_SPRITES\t\n\telse if(fTexture == TEX_BAR1A) { vSize = vec2(23.0, 32.0); }\n\telse if(fTexture == TEX_PLAYW) { vSize = vec2(57.0, 22.0); fPersistence = 1.0; }\n#endif\n\t\n#ifdef PREVIEW\n\t     if(fTexture == TEX_DOOR3) {\tvSize = vec2(128.0, 128.0); }\t\n\telse if(fTexture == TEX_COMPUTE2) { vSize = vec2(256.0, 64.0); }\n#ifdef ENABLE_SPRITES\t\n\telse if(fTexture == TEX_BAR1A) { vSize = vec2(32.0, 32.0); }\n\telse if(fTexture == TEX_PLAYW) { vSize = vec2(64.0, 32.0); }\t\n#endif\n#endif\n\t\n\t\n#ifdef PREVIEW\n    vec2 vTexCoord = floor(fract(vUV) * vSize);\n#else\n    vec2 vTexCoord = fract(vUV / vSize) * vSize;\n    #ifdef PIXELATE_TEXTURES\n    vTexCoord = floor(vTexCoord);\n    #endif\n    vTexCoord.y = vSize.y - vTexCoord.y - 1.0;\n#endif\n\tfloat fRandom = fbm( vTexCoord, fPersistence );\n\tfloat fHRandom = noise1D(vTexCoord.x * fNoise2Freq) - ((vTexCoord.y) / vSize.y);\n    \n\t     if(fTexture == TEX_NUKAGE3) \tcol = TexNukage3( vTexCoord, fRandom );\n\telse if(fTexture == TEX_F_SKY1) \tcol = TexFSky1( vTexCoord, fRandom, fHRandom );\n    else if(fTexture == TEX_FLOOR7_1) \tcol = TexFloor7_1( vTexCoord, fRandom );\n    else if(fTexture == TEX_FLAT5_5) \tcol = TexFlat5_5( vTexCoord, fRandom );\n    else if(fTexture == TEX_FLOOR4_8) \tcol = TexFloor4_8( vTexCoord, fRandom );\n    else if(fTexture == TEX_CEIL3_5) \tcol = TexCeil3_5( vTexCoord, fRandom );\n\telse if(fTexture == TEX_FLAT14) \tcol = TexFlat14( vTexCoord, fRandom );\n\telse if(fTexture == TEX_DOOR3) \t\tcol = TexDoor3( vTexCoord, fRandom, fHRandom );\n\telse if(fTexture == TEX_LITE3) \t\tcol = TexLite3( vTexCoord );\n    else if(fTexture == TEX_STARTAN3) \tcol = TexStartan3( vTexCoord, fRandom );\n    else if(fTexture == TEX_BROWN1) \tcol = TexBrown1( vTexCoord, fRandom, fHRandom );\n    else if(fTexture == TEX_DOORSTOP) \tcol = TexDoorstop( vTexCoord, fRandom );\n    else if(fTexture == TEX_COMPUTE2) \tcol = TexCompute2( vTexCoord, fRandom );\n    else if(fTexture == TEX_STEP6) \t\tcol = TexStep6( vTexCoord, fRandom, fHRandom );\n    else if(fTexture == TEX_SUPPORT2) \tcol = TexSupport2( vTexCoord, fRandom );\n\telse if(fTexture == TEX_DOORTRAK) \tcol = TexDoorTrak( vTexCoord, fRandom );\n\telse if(fTexture == TEX_BROWN144) \tcol = TexBrown144( vTexCoord, fRandom, fHRandom );\n#ifdef ENABLE_SPRITES\t\n\telse if(fTexture == TEX_BAR1A) \t\tcol = TexBar1A( vTexCoord, fRandom, fHRandom );\n\telse if(fTexture == TEX_PLAYW) \t\tcol = TexPlayW( vTexCoord, fRandom, fHRandom );\t\n#endif\n\t\n    #ifdef QUANTIZE_TEXTURES\n    col = Quantize(col);\n    #endif\n\n    return col;\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n\tconst vec2 vStart = vec2(1050, -3616);\n    \n    fragRayOri.z *= -1.0;\n    fragRayDir.z *= -1.0;\n    \n    fragRayOri *= 48.0;\n    \n    vec3 vCameraPos;\n    vec3 vCameraTarget;\n\tDemoCamera( iTime * 0.25, vCameraPos, vCameraTarget );\n    \n    if ( false )\n    {\n    \tfragRayOri += vCameraPos;\n    }\n    else\n    {\n    \tfragRayOri.xz += vStart;\n    \tfragRayOri.y += 48.0;        \n    }\n    \n    Ray r;\n    r.vRayOrigin = fragRayOri;\n    r.vRayDir = fragRayDir;\n    \n    vec3 vForwards = fragRayDir; \n    \n\tvec3 vResult = DrawScene(vForwards, fragCoord / iResolution.xy,r);\n    \n    fragColor = vec4( vResult, 1.0 );\n}",
    "tags": [
      "doom",
      "e1m1",
      "hangar"
    ],
    "author": "P_Malin",
    "views": 0,
    "likes": 207,
    "published": 3
  },
  {
    "id": "4tdSWr",
    "title": "2D Clouds",
    "description": "Used in 2 different demos:\nhttp://www.pouet.net/prod.php?which=66590\nand\nhttp://www.pouet.net/prod.php?which=68483",
    "code": "const float cloudscale = 1.1;\nconst float speed = 0.03;\nconst float clouddark = 0.5;\nconst float cloudlight = 0.3;\nconst float cloudcover = 0.2;\nconst float cloudalpha = 8.0;\nconst float skytint = 0.5;\nconst vec3 skycolour1 = vec3(0.2, 0.4, 0.6);\nconst vec3 skycolour2 = vec3(0.4, 0.7, 1.0);\n\nconst mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\nvec2 hash( vec2 p ) {\n\tp = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p ) {\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\tvec2 i = floor(p + (p.x+p.y)*K1);\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n    vec3 h = max(0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot(n, vec3(70.0));\t\n}\n\nfloat fbm(vec2 n) {\n\tfloat total = 0.0, amplitude = 0.1;\n\tfor (int i = 0; i < 7; i++) {\n\t\ttotal += noise(n) * amplitude;\n\t\tn = m * n;\n\t\tamplitude *= 0.4;\n\t}\n\treturn total;\n}\n\n// -----------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = fragCoord.xy / iResolution.xy;\n\tvec2 uv = p*vec2(iResolution.x/iResolution.y,1.0);    \n    float time = iTime * speed;\n    float q = fbm(uv * cloudscale * 0.5);\n    \n    //ridged noise shape\n\tfloat r = 0.0;\n\tuv *= cloudscale;\n    uv -= q - time;\n    float weight = 0.8;\n    for (int i=0; i<8; i++){\n\t\tr += abs(weight*noise( uv ));\n        uv = m*uv + time;\n\t\tweight *= 0.7;\n    }\n    \n    //noise shape\n\tfloat f = 0.0;\n    uv = p*vec2(iResolution.x/iResolution.y,1.0);\n\tuv *= cloudscale;\n    uv -= q - time;\n    weight = 0.7;\n    for (int i=0; i<8; i++){\n\t\tf += weight*noise( uv );\n        uv = m*uv + time;\n\t\tweight *= 0.6;\n    }\n    \n    f *= r + f;\n    \n    //noise colour\n    float c = 0.0;\n    time = iTime * speed * 2.0;\n    uv = p*vec2(iResolution.x/iResolution.y,1.0);\n\tuv *= cloudscale*2.0;\n    uv -= q - time;\n    weight = 0.4;\n    for (int i=0; i<7; i++){\n\t\tc += weight*noise( uv );\n        uv = m*uv + time;\n\t\tweight *= 0.6;\n    }\n    \n    //noise ridge colour\n    float c1 = 0.0;\n    time = iTime * speed * 3.0;\n    uv = p*vec2(iResolution.x/iResolution.y,1.0);\n\tuv *= cloudscale*3.0;\n    uv -= q - time;\n    weight = 0.4;\n    for (int i=0; i<7; i++){\n\t\tc1 += abs(weight*noise( uv ));\n        uv = m*uv + time;\n\t\tweight *= 0.6;\n    }\n\t\n    c += c1;\n    \n    vec3 skycolour = mix(skycolour2, skycolour1, p.y);\n    vec3 cloudcolour = vec3(1.1, 1.1, 0.9) * clamp((clouddark + cloudlight*c), 0.0, 1.0);\n   \n    f = cloudcover + cloudalpha*f*r;\n    \n    vec3 result = mix(skycolour, clamp(skytint * skycolour + cloudcolour, 0.0, 1.0), clamp(f + c, 0.0, 1.0));\n    \n\tfragColor = vec4( result, 1.0 );\n}",
    "tags": [
      "fractal",
      "noise",
      "clouds",
      "fbm"
    ],
    "author": "drift",
    "views": 0,
    "likes": 849,
    "published": 3
  },
  {
    "id": "XdBGzd",
    "title": "Sphere - projection",
    "description": "Analytic projection of a sphere to screen pixels. Spheres in world space become ellipses in clip space. The ellipses can be analytically determined from the camera and sphere geometry. This shader computes their center, axis and area in raster pixels.",
    "code": "// The MIT License\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org/\n// Copyright \u00a9 2014 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Analytic projection of a sphere to screen pixels. \n\n// Spheres in world space become ellipses when projected to the\n// camera view plane. In fact, these ellipses can be analytically\n// determined from the camera parameters and the sphere geometry,\n// such that their exact position, orientation and surface area\n// can be compunted. This means that, given a sphere and a camera\n// and buffer resolution, there is an analytical formula that \n// provides the amount of pixels covered by a sphere in the image.\n// This can be very useful for implementing LOD for objects based\n// on their size in screen (think of trees, vegetation, characters\n// or any other such complex object).\n\n// This shader implements this formula, and provides too the\n// center and axes of the ellipse.\n\n// More info: https://iquilezles.org/articles/sphereproj\n//\n// Sphere  projection: https://www.shadertoy.com/view/XdBGzd\n// Disk    projection: https://www.shadertoy.com/view/mltyDN\n// Ellipse projection: https://www.shadertoy.com/view/ctGyRR\n\n// ---------------------------------------------------------------------------------------------\n\nstruct ProjectionResult\n{\n    float area;      // probably all we care about is the area\n    vec2  center;    // but i'm outputing all the information \n    vec2  axisA;     // for debugging and illustration purposes\n    vec2  axisB;\n    // implicit ellipse f(x,y) = a\u00b7x\u00b2 + b\u00b7x\u00b7y + c\u00b7y\u00b2 + d\u00b7x + e\u00b7y + f = 0 */\n\tfloat a, b, c, d, e, f; \n};\n\nProjectionResult projectSphere( /* sphere        */ in vec4 sph, \n\t\t\t\t                /* camera matrix */ in mat4 cam,\n\t\t\t\t\t\t\t    /* projection    */ in float fle )\n{\n    // transform to camera space\t\n\tvec3  o = (cam*vec4(sph.xyz,1.0)).xyz;\n\t\n    float r2 = sph.w*sph.w;\n\tfloat z2 = o.z*o.z;\t\n\tfloat l2 = dot(o,o);\n\t\n\tfloat area = -3.141593*fle*fle*r2*sqrt(abs((l2-r2)/(r2-z2)))/(r2-z2);\n\t\n\t//return area;\n\t\n\t\n    //-- debug stuff ---\n\n\t\n\t// axis\n\tvec2 axa = fle*sqrt(-r2*(r2-l2)/((l2-z2)*(r2-z2)*(r2-z2)))*vec2( o.x,o.y);\n\tvec2 axb = fle*sqrt(-r2*(r2-l2)/((l2-z2)*(r2-z2)*(r2-l2)))*vec2(-o.y,o.x);\n\n    //area = length(axa)*length(axb)*3.141593;\t\n\t\n\t// center\n\tvec2  cen = fle*o.z*o.xy/(z2-r2);\n\n\treturn ProjectionResult( area, cen, axa, axb, \n                     /* a */ r2 - o.y*o.y - z2,\n                     /* b */ 2.0*o.x*o.y,\n                     /* c */ r2 - o.x*o.x - z2,\n                     /* d */ 2.0*o.x*o.z*fle,\n                     /* e */ 2.0*o.y*o.z*fle,\n                     /* f */ (r2-l2+z2)*fle*fle );\n\t\n}\n\n//-----------------------------------------------------------------\n// Digit drawing function by P_Malin (https://www.shadertoy.com/view/4sf3RN)\n\nfloat SampleDigit(const in float n, const in vec2 vUV)\n{\t\t\n\tif(vUV.x  < 0.0) return 0.0;\n\tif(vUV.y  < 0.0) return 0.0;\n\tif(vUV.x >= 1.0) return 0.0;\n\tif(vUV.y >= 1.0) return 0.0;\n\t\n\tfloat data = 0.0;\n\t\n\t     if(n < 0.5) data = 7.0 + 5.0*16.0 + 5.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n\telse if(n < 1.5) data = 2.0 + 2.0*16.0 + 2.0*256.0 + 2.0*4096.0 + 2.0*65536.0;\n\telse if(n < 2.5) data = 7.0 + 1.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n\telse if(n < 3.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n\telse if(n < 4.5) data = 4.0 + 7.0*16.0 + 5.0*256.0 + 1.0*4096.0 + 1.0*65536.0;\n\telse if(n < 5.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n\telse if(n < 6.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n\telse if(n < 7.5) data = 4.0 + 4.0*16.0 + 4.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n\telse if(n < 8.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n\telse if(n < 9.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n\t\n\tvec2 vPixel = floor(vUV * vec2(4.0, 5.0));\n\tfloat fIndex = vPixel.x + (vPixel.y * 4.0);\n\t\n\treturn mod(floor(data / pow(2.0, fIndex)), 2.0);\n}\n\nfloat PrintInt(const in vec2 uv, const in float value )\n{\n\tfloat res = 0.0;\n\tfloat maxDigits = 1.0+ceil(log2(value)/log2(10.0));\n\tfloat digitID = floor(uv.x);\n\tif( digitID>0.0 && digitID<maxDigits )\n\t{\n        float digitVa = mod( floor( value/pow(10.0,maxDigits-1.0-digitID) ), 10.0 );\n        res = SampleDigit( digitVa, vec2(fract(uv.x), uv.y) );\n\t}\n\n\treturn res;\t\n}\n\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n\nfloat ssSphere( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n    vec3 oc = sph.xyz - ro;\n    float b = dot( oc, rd );\n\t\n    float res = 1.0;\n    if( b>0.0 )\n    {\n        float h = dot(oc,oc) - b*b - sph.w*sph.w;\n        res = smoothstep( 0.0, 1.0, 12.0*h/b );\n    }\n    return res;\n}\n\nfloat sdSegment( vec2 p, vec2 a, vec2 b )\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\nfloat gridTextureGradBox( in vec2 p, in vec2 ddx, in vec2 ddy )\n{\n    const float N = 10.0;\n    vec2 w = max(abs(ddx), abs(ddy)) + 0.01;\n    vec2 a = p + 0.5*w;\n    vec2 b = p - 0.5*w;           \n    vec2 i = (floor(a)+min(fract(a)*N,1.0)-\n              floor(b)-min(fract(b)*N,1.0))/(N*w);\n    return (1.0-i.x)*(1.0-i.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n\t\n\tfloat fov = 1.0;\n\t\n\tfloat an = 12.0 + 0.5*iTime + 10.0*iMouse.x/iResolution.x;\n\tvec3 ro = vec3( 3.0*cos(an), 0.0, 3.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n\tvec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\tvec3 rd = normalize( p.x*uu + p.y*vv + fov*ww );\n\tmat4 cam = mat4( uu.x, uu.y, uu.z, 0.0,\n\t\t\t\t\t vv.x, vv.y, vv.z, 0.0,\n\t\t\t\t\t ww.x, ww.y, ww.z, 0.0,\n\t\t\t\t\t -dot(uu,ro), -dot(vv,ro), -dot(ww,ro), 1.0 );\n\n    const vec4 sph[3] = vec4[3]( vec4(-2.0, 1.0,0.0,1.1),\n\t                             vec4( 3.0, 1.5,1.0,1.2),\n\t                             vec4( 1.0,-1.0,1.0,1.3) );\n\n\tfloat tmin = 10000.0;\n\tvec3  nor = vec3(0.0);\n\tvec3  pos = vec3(0.0);\n\t\n\tvec3 sur = vec3(1.0);\n    \n    for( int i=0; i<3; i++ )\n    {\n        float h = iSphere( ro, rd, sph[i] );\n        if( h>0.0 && h<tmin ) \n        { \n            tmin = h; \n            pos = ro + h*rd;\n            nor = normalize(pos-sph[i].xyz); \n            sur = 0.5 + 0.5*cos(float(i)*2.0+vec3(0.0,2.0,4.0));              \n            sur *= 0.4;\n            //sur *= smoothstep(-0.6,-0.2,sin(20.0*(pos.x-sph[i].x)));\n        }\n\t}\n\n    float h = (-2.0-ro.y)/rd.y;\n\tif( h>0.0 && h<tmin ) \n\t{ \n\t\ttmin = h; \n\t\tpos = ro + h*rd;\n\t\tnor = vec3(0.0,1.0,0.0); \n        sur = vec3(1.0)*gridTextureGradBox( pos.xz, dFdx(pos.xz), dFdy(pos.xz) );\n\t}\n\n\tvec3 col = vec3(0.0);\n\n\tif( tmin<100.0 )\n\t{\n\t    pos = ro + tmin*rd;\n        col = vec3(1.0);\n\t\t\n\t\tvec3 lig = normalize( vec3(2.0,1.4,-1.0) );\n\t\tfloat sha = 1.0;\n        for( int i=0; i<3; i++ )\n        {\n\t\t    sha *= ssSphere( pos, lig, sph[i] );\n        }\n\n\t\tfloat ndl = clamp( dot(nor,lig), 0.0, 1.0 );\n\t\tcol = (0.5+0.5*nor.y)*vec3(0.2,0.3,0.4) + sha*vec3(1.0,0.9,0.8)*ndl + sha*vec3(1.5)*ndl*pow( clamp(dot(normalize(-rd+lig),nor),0.0,1.0), 16.0 );\n\t\tcol *= sur;\n\t\t\n        col *= exp( -0.25*(max(0.0,tmin-3.0)) );\n\n\t}\n\n\tcol = pow( col, vec3(0.45) );\n\t\n\t//-------------------------------------------------------\n    for( int i=0; i<3; i++ )\n\t{\n        ProjectionResult res = projectSphere( sph[i], cam, fov );\n        res.area *= iResolution.y*iResolution.y*0.25;\n        if( res.area>0.0 )\n        {\n        \tfloat showMaths = smoothstep( -0.5, 0.5, cos(0.5*6.2831*iTime) );\n            float f = res.a*p.x*p.x + res.b*p.x*p.y + res.c*p.y*p.y + res.d*p.x + res.e*p.y + res.f;\n            vec2  g = 2.0*vec2(res.a,res.c)*p.xy + res.b*p.yx + vec2(res.d,res.e);                   \n            float d = abs(f)/length(g);\n            col = mix( col, vec3(1.0,0.0,0.0), showMaths*(1.0-smoothstep(0.00,0.01, d)));\n            col = mix( col, vec3(1.0,1.0,0.0), showMaths*(1.0-smoothstep(0.00,0.01, sdSegment( p, res.center-res.axisA, res.center+res.axisA )) ));\n            col = mix( col, vec3(1.0,1.0,0.0), showMaths*(1.0-smoothstep(0.00,0.01, sdSegment( p, res.center-res.axisB, res.center+res.axisB )) ));\n            col = mix( col, vec3(1.0,0.0,0.0), showMaths*(1.0-smoothstep(0.03,0.04, length(p-res.center))));\n            vec2 pp  = res.center + 0.5*max( max( res.axisA, -res.axisA ), max( res.axisB, -res.axisB ) );\n            col = mix( col, vec3(1.0), PrintInt( ((p-pp)-vec2(0.0,0.0))/0.07, floor(res.area) ) );\n        }\n    }\n    //-------------------------------------------------------\n\t\n\tfragColor = vec4( col, 1.0 );\n}",
    "tags": [
      "3d",
      "sphere",
      "projection",
      "analytic"
    ],
    "author": "iq",
    "views": 0,
    "likes": 158,
    "published": 3
  },
  {
    "id": "XsBfRW",
    "title": "Pretty Hip",
    "description": "Definitely some squares. The math is almost certainly more complicated than it needs to be - I'm refusing to think too hard today.",
    "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.y/iResolution.x;\n    float value;\n\tvec2 uv = fragCoord.xy / iResolution.x;\n    uv -= vec2(0.5, 0.5*aspect);\n    float rot = radians(45.0); // radians(45.0*sin(iTime));\n    mat2 m = mat2(cos(rot), -sin(rot), sin(rot), cos(rot));\n   \tuv  = m * uv;\n    uv += vec2(0.5, 0.5*aspect);\n    uv.y+=0.5*(1.0-aspect);\n    vec2 pos = 10.0*uv;\n    vec2 rep = fract(pos);\n    float dist = 2.0*min(min(rep.x, 1.0-rep.x), min(rep.y, 1.0-rep.y));\n    float squareDist = length((floor(pos)+vec2(0.5)) - vec2(5.0) );\n    \n    float edge = sin(iTime-squareDist*0.5)*0.5+0.5;\n    \n    edge = (iTime-squareDist*0.5)*0.5;\n    edge = 2.0*fract(edge*0.5);\n    //value = 2.0*abs(dist-0.5);\n    //value = pow(dist, 2.0);\n    value = fract (dist*2.0);\n    value = mix(value, 1.0-value, step(1.0, edge));\n    //value *= 1.0-0.5*edge;\n    edge = pow(abs(1.0-edge), 2.0);\n    \n    //edge = abs(1.0-edge);\n    value = smoothstep( edge-0.05, edge, 0.95*value);\n    \n    \n    value += squareDist*.1;\n    //fragColor = vec4(value);\n    fragColor = mix(vec4(1.0,1.0,1.0,1.0),vec4(0.5,0.75,1.0,1.0), value);\n    fragColor.a = 0.25*clamp(value, 0.0, 1.0);\n}",
    "tags": [
      "2d",
      "cineshader"
    ],
    "author": "Hadyn",
    "views": 0,
    "likes": 212,
    "published": 3
  },
  {
    "id": "XsVBRm",
    "title": "Hydraulic Erosion",
    "description": "Landscape evolution model (fluvial incision and tectonic uplift) using the stream power law, loosely based on [url]https://arxiv.org/abs/1803.02977[/url]\n\nYou need to let it run for a few minutes for the rivers to grow.",
    "code": "#define PI 3.14159265359\n\nvoid mainImage( out vec4 r, in vec2 p ) {\n    float y = buf(p).r;\n    vec2 grad = vec2(buf(p+E).r - buf(p+W).r, buf(p+N).r - buf(p+S).r);\n    r = vec4(0.34, 0.52, 0.29, 1);\n    r = mix(r, vec4(0.88, 0.85, 0.63, 1), smoothstep(0.500, 0.625, y));\n\tr = mix(r, vec4(0.93, 0.72, 0.40, 1), smoothstep(0.625, 0.750, y));\n\tr = mix(r, vec4(0.70, 0.60, 0.53, 1), smoothstep(0.750, 0.875, y));\n\tr = mix(r, vec4(1,1,1,1), smoothstep(0.875, 1., y));\n    r.rgb *= 0.75 + 0.25 * cos(atan(grad.y, grad.x) + 0.25*PI);\n    if (y < 0.5) r = mix(r, vec4(0.73, 0.80, 0.97, 1), 0.5);\n}\n",
    "tags": [
      "terrain",
      "landscape",
      "erosion"
    ],
    "author": "davidar",
    "views": 0,
    "likes": 80,
    "published": 3
  },
  {
    "id": "WdXBW4",
    "title": "Clouds-2D",
    "description": "murieron shader",
    "code": "// https://www.shadertoy.com/view/WdXBW4\n \nconst float cloudscale = 1.1;\nconst float speed = 0.03;\nconst float clouddark = 0.5;\nconst float cloudlight = 0.3;\nconst float cloudcover = 0.2;\nconst float cloudalpha = 8.0;\nconst float skytint = 0.5;\nconst vec3 skycolour1 = vec3(0.2, 0.4, 0.6);\nconst vec3 skycolour2 = vec3(0.4, 0.7, 1.0);\n\nconst mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\nvec2 hash( vec2 p ) {\n\tp = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p ) {\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\tvec2 i = floor(p + (p.x+p.y)*K1);\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n    vec3 h = max(0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot(n, vec3(70.0));\t\n}\n\nfloat fbm(vec2 n) {\n\tfloat total = 0.0, amplitude = 0.1;\n\tfor (int i = 0; i < 7; i++) {\n\t\ttotal += noise(n) * amplitude;\n\t\tn = m * n;\n\t\tamplitude *= 0.4;\n\t}\n\treturn total;\n}\n\n// -----------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = fragCoord.xy / iResolution.xy;\n\tvec2 uv = p*vec2(iResolution.x/iResolution.y,1.0);    \n    float time = iTime * speed;\n    float q = fbm(uv * cloudscale * 0.5);\n    \n    //ridged noise shape\n\tfloat r = 0.0;\n\tuv *= cloudscale;\n    uv -= q - time;\n    float weight = 0.8;\n    for (int i=0; i<8; i++){\n\t\tr += abs(weight*noise( uv ));\n        uv = m*uv + time;\n\t\tweight *= 0.7;\n    }\n    \n    //noise shape\n\tfloat f = 0.0;\n    uv = p*vec2(iResolution.x/iResolution.y,1.0);\n\tuv *= cloudscale;\n    uv -= q - time;\n    weight = 0.7;\n    for (int i=0; i<8; i++){\n\t\tf += weight*noise( uv );\n        uv = m*uv + time;\n\t\tweight *= 0.6;\n    }\n    \n    f *= r + f;\n    \n    //noise colour\n    float c = 0.0;\n    time = iTime * speed * 2.0;\n    uv = p*vec2(iResolution.x/iResolution.y,1.0);\n\tuv *= cloudscale*2.0;\n    uv -= q - time;\n    weight = 0.4;\n    for (int i=0; i<7; i++){\n\t\tc += weight*noise( uv );\n        uv = m*uv + time;\n\t\tweight *= 0.6;\n    }\n    \n    //noise ridge colour\n    float c1 = 0.0;\n    time = iTime * speed * 3.0;\n    uv = p*vec2(iResolution.x/iResolution.y,1.0);\n\tuv *= cloudscale*3.0;\n    uv -= q - time;\n    weight = 0.4;\n    for (int i=0; i<7; i++){\n\t\tc1 += abs(weight*noise( uv ));\n        uv = m*uv + time;\n\t\tweight *= 0.6;\n    }\n\t\n    c += c1;\n    \n    vec3 skycolour = mix(skycolour2, skycolour1, p.y);\n    vec3 cloudcolour = vec3(1.1, 1.1, 0.9) * clamp((clouddark + cloudlight*c), 0.0, 1.0);\n   \n    f = cloudcover + cloudalpha*f*r;\n    \n    vec3 result = mix(skycolour, clamp(skytint * skycolour + cloudcolour, 0.0, 1.0), clamp(f + c, 0.0, 1.0));\n    \n\tfragColor = vec4( result, 1.0 );\n}\n\n/** SHADERDATA\n{\n    \"title\": \"Murieron\",\n    \"description\": \"Homenaje a las v\u00edctimas del COVID-19\",\n    \"model\": \"person\"\n}\n*/",
    "tags": [
      "cineshader"
    ],
    "author": "murieron",
    "views": 0,
    "likes": 155,
    "published": 3
  },
  {
    "id": "WtdXR8",
    "title": "glowingMarblingBlack",
    "description": "https://twitter.com/nasana_x",
    "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv =  (2.0 * fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    for(float i = 1.0; i < 10.0; i++){\n        uv.x += 0.6 / i * cos(i * 2.5* uv.y + iTime);\n        uv.y += 0.6 / i * cos(i * 1.5 * uv.x + iTime);\n    }\n    \n    fragColor = vec4(vec3(0.1)/abs(sin(iTime-uv.y-uv.x)),1.0);\n}",
    "tags": [
      "cineshader"
    ],
    "author": "nasana",
    "views": 0,
    "likes": 208,
    "published": 3
  },
  {
    "id": "Xtcyzr",
    "title": "Lotka-Volterra diffusion",
    "description": "Influence of environmental variation on a large-scale ecological model. Vegetation (green) growth rate varies with time, prey (blue) birthrate increases along y-axis, and predator (red) effectiveness along x-axis.",
    "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float vege = buf(fragCoord).x;\n    float prey = buf(fragCoord).y * 2.;\n    float pred = buf(fragCoord).z;\n\n    fragColor = vec4(0,0,0,1);\n    fragColor = mix(fragColor, vec4(0., 1., 0.1, 1), smoothstep(0., 10., vege - prey - pred));\n    fragColor = mix(fragColor, vec4(0., 0.5, 1., 1), smoothstep(0., 10., prey - pred));\n    fragColor = mix(fragColor, vec4(0.5, 0., 0., 1), smoothstep(0., 10., pred));\n\n    float plant_growth = 0.75 - 0.25 * cos(2.*PI * iTime / 60.);\n    if (iTime < 30.) plant_growth = 1.;\n\n    vec2 uv = fragCoord / iResolution.xy;\n    if (uv.y < 0.02) fragColor = vec4(0,0,0,1);\n    if (uv.y < 0.01 && uv.x < plant_growth) fragColor = vec4(0., 1., 0.1, 1);\n\n    fragColor.rgb = pow(fragColor.rgb, vec3(1./2.2));\n}\n",
    "tags": [
      "simulation",
      "diffusion",
      "reaction",
      "predator",
      "prey",
      "ecology",
      "population"
    ],
    "author": "davidar",
    "views": 0,
    "likes": 35,
    "published": 3
  },
  {
    "id": "XtffW8",
    "title": "Plate Tectonics",
    "description": "Continental drift and mountain range formation simulation",
    "code": "#define DEBUG false\n\nvoid mainImage(out vec4 r, in vec2 p) {\n    float y = buf(p).z / 50.;\n    if (DEBUG) {\n        vec4 c = buf(p);\n        r.rgb = (c.xy == vec2(0)) ? vec3(1) : .6 + .6 * cos(atan(c.y,c.x) + vec3(0,23,21));\n        r.rgb *= 0.1 + 0.9 * y;\n    } else if (y < 0.15) { // ocean\n        r = mix(vec4(0.01, 0.02, 0.08, 1), vec4(0.11, 0.28, 0.51, 1), y/0.15);\n    } else { // land\n        vec2 grad = vec2(buf(p+E).z - buf(p+W).z, buf(p+N).z - buf(p+S).z);\n        r = vec4(0.08, 0.14, 0.03, 1);\n        r = mix(r, vec4(0.18, 0.26, 0.08, 1), smoothstep(0.15, 0.25, y));\n        r = mix(r, vec4(0.52, 0.39, 0.26, 1), smoothstep(0.25, 0.50, y));\n        r = mix(r, vec4(0.32, 0.3, 0.2, 1), smoothstep(0.50, 0.75, y));\n        r = mix(r, vec4(1,1,1,1), smoothstep(0.75, 1., y));\n        r.rgb *= 0.75 + 0.25 * cos(atan(grad.y, grad.x) + 0.25*PI)\n                             * clamp(0.2 * length(grad), 0., 1.);\n    }\n}",
    "tags": [
      "procedural",
      "terrain",
      "simulation"
    ],
    "author": "davidar",
    "views": 0,
    "likes": 30,
    "published": 3
  },
  {
    "id": "3ttSzr",
    "title": "crumpledWave",
    "description": "https://twitter.com/nasana_x",
    "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv =  (2.0 * fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n   \n    for(float i = 1.0; i < 8.0; i++){\n    uv.y += i * 0.1 / i * \n      sin(uv.x * i * i + iTime * 0.5) * sin(uv.y * i * i + iTime * 0.5);\n  }\n    \n   vec3 col;\n   col.r  = uv.y - 0.1;\n   col.g = uv.y + 0.3;\n   col.b = uv.y + 0.95;\n    \n    fragColor = vec4(col,1.0);\n}",
    "tags": [
      "cineshader"
    ],
    "author": "nasana",
    "views": 0,
    "likes": 146,
    "published": 3
  },
  {
    "id": "MtKXRh",
    "title": "Kleinian limit set-Maskit slice ",
    "description": "2D limit set",
    "code": "//by Jos Leys\nvec3  background1Color=vec3(1.0,1.0,1.0);\nvec3  color3=vec3(0.2,0.0,0.6);\n\nfloat box_size_x=1.;\n\nfloat wrap(float x, float a, float s){\n\tx -= s; \n\treturn (x-a*floor(x/a)) + s;\n}\n\nvoid TransA(inout vec2 z, float a, float b){\n\tfloat iR = 1. / dot(z,z);\n\tz *= -iR;\n\tz.x = -b - z.x; z.y = a + z.y; \n\t\n}\n\nfloat  JosKleinian(vec2 z)\n{\n\tvec2 lz=z+vec2(1.), llz=z+vec2(-1.);\n    float flag=0.;\n float KleinR = 1.8462756+(1.958591-1.8462756)*0.5+0.5*(1.958591-1.8462756)*sin(-iTime*0.2);  \n float KleinI = 0.09627581+(0.0112786-0.09627581)*0.5+0.5*(0.0112786-0.09627581)*sin(-iTime*0.2);\n      \n\tfloat a = KleinR;\n    float b = KleinI;\n\tfloat f = sign(b)*1. ;     \n\tfor (int i = 0; i < 150 ; i++) \n\t{\n                z.x=z.x+f*b/a*z.y;\n\t\tz.x = wrap(z.x, 2. * box_size_x, - box_size_x);\n\t\tz.x=z.x-f*b/a*z.y;\n                       \n\t\t//If above the separation line, rotate by 180\u00b0 about (-b/2, a/2)\n        if  (z.y >= a * 0.5 + f *(2.*a-1.95)/4. * sign(z.x + b * 0.5)* (1. - exp(-(7.2-(1.95-a)*15.)* abs(z.x + b * 0.5))))\t\n        {z = vec2(-b, a) - z;}\n        \n\t\t//Apply transformation a\n\t\tTransA(z, a, b);\n\t\t\n        //\n\t\t//If the iterated points enters a 2-cycle , bail out.\n        if(dot(z-llz,z-llz) < 1e-6) {break;}\n        //if the iterated point gets outside z.y=0 and z.y=a\n        if(z.y<0. || z.y>a){flag=1.; break;}\n        //Store pr\u00e9vious iterates\n\t\tllz=lz; lz=z;\n\t}\n\n\treturn flag;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n   \tvec2 uv = fragCoord.xy / iResolution.xy;\n     uv = (1.99)*uv-vec2(0.42,.0);\n   \n    uv.x *= iResolution.x/iResolution.y;\n    float hit=JosKleinian(uv);\n      vec3 c =(1.-hit)*background1Color+hit*color3;\n   \n\tfragColor = vec4(c, 1.0);\n    \n}\n\n",
    "tags": [
      "fractal",
      "kleinian"
    ],
    "author": "JosLeys",
    "views": 0,
    "likes": 67,
    "published": 3
  },
  {
    "id": "WtKSzt",
    "title": "MONSTER",
    "description": "30min livecoding",
    "code": "float TK = 1.;\nfloat PI = 3.1415926535;\n\nvec2 rot(vec2 p,float r){\n\tmat2 m = mat2(cos(r),sin(r),-sin(r),cos(r));\n\treturn m*p;\n}\n\nvec2 pmod(vec2 p,float n){\n\tfloat np = 2.0*PI/n;\n\tfloat r = atan(p.x,p.y)-0.5*np;\n\tr = mod(r,np)-0.5*np;\n\treturn length(p)*vec2(cos(r),sin(r));\n}\n\nfloat cube(vec3 p,vec3 s){\n\tvec3 q = abs(p);\n\tvec3 m = max(s-q,0.0);\n\treturn length(max(q-s,0.0))-min(min(m.x,m.y),m.z);\n}\n\nfloat dist(vec3 p){\n\tp.z -= 1.*TK*iTime;\n\tp.xy = rot(p.xy,1.0*p.z);\n\tp.xy = pmod(p.xy,6.0);\n\tfloat k = 0.7;\n\tfloat zid = floor(p.z*k);\n\tp = mod(p,k)-0.5*k;\n\tfor(int i = 0;i<4;i++){\n\t\tp = abs(p)-0.3;\n\n\t\tp.xy = rot(p.xy,1.0+zid+0.1*TK*iTime);\n\t\tp.xz = rot(p.xz,1.0+4.7*zid+0.3*TK*iTime);\n\t}\n\treturn min(cube(p,vec3(0.3)),length(p)-0.4);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv = 2.0*(uv-0.5);\n\tuv.y *= iResolution.y/iResolution.x;\n\tuv = rot(uv,TK*iTime);\n\tvec3 ro = vec3(0.0,0.0,0.1);\n\tvec3 rd = normalize(vec3(uv,0.0)-ro);\n\tfloat t  =2.0;\n\tfloat d = 0.0;\n\tfloat ac = 0.0;\n\tfor(int i = 0;i<66;i++){\n\t\td = dist(ro+rd*t)*0.2;\n\t\td = max(0.0000,abs(d));\n\t\tt += d;\n\t\tif(d<0.001)ac += 0.1;//exp(-15.0*d);\n\t}\n\tvec3 col = vec3(0.0);\n\tcol = vec3(0.1,0.7,0.7)*0.2*vec3(ac);//vec3(exp(-1.0*t));\n\tvec3 pn = ro+rd*t;\n\tfloat kn = 0.5;\n\tpn.z += -1.5*iTime*TK;\n\tpn.z = mod(pn.z,kn)-0.5*kn;\n\tfloat em = clamp(0.01/pn.z,0.0,100.0);\n\tcol += 3.0*em*vec3(0.1,1.0,0.1);\n\tcol = clamp(col,0.0,1.0);\n\t//col = 1.0-col;\n\n\n    // Output to screen\n    fragColor = vec4(col,0.);\n}",
    "tags": [
      "raymarching",
      "cineshader"
    ],
    "author": "butadiene",
    "views": 0,
    "likes": 122,
    "published": 3
  },
  {
    "id": "WldSRn",
    "title": "002-Blue",
    "description": "Raymarching",
    "code": "float sdSphere(vec3 pos, float size)\n{\n    return length(pos) - size;\n}\n\nfloat sdBox(vec3 pos, vec3 size)\n{\n    pos = abs(pos) - vec3(size);\n    return max(max(pos.x, pos.y), pos.z);\n}\n\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    float m = p.x+p.y+p.z-s;\n    vec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    \n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\nfloat sdPlane(vec3 pos)\n{\n    return pos.y;\n}\n\nmat2 rotate(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\nvec3 repeat(vec3 pos, vec3 span)\n{\n    return abs(mod(pos, span)) - span * 0.5;\n}\n\nfloat getDistance(vec3 pos, vec2 uv)\n{\n    vec3 originalPos = pos;\n\n    for(int i = 0; i < 3; i++)\n    {\n        pos = abs(pos) - 4.5;\n        pos.xz *= rotate(1.0);\n        pos.yz *= rotate(1.0);\n    }\n\n    pos = repeat(pos, vec3(4.0));\n\n    float d0 = abs(originalPos.x) - 0.1;\n    float d1 = sdBox(pos, vec3(0.8));\n\n    pos.xy *= rotate(mix(1.0, 2.0, abs(sin(iTime))));\n    float size = mix(1.1, 1.3, (abs(uv.y) * abs(uv.x)));\n    float d2 = sdSphere(pos, size);\n    float dd2 = sdOctahedron(pos, 1.8);\n    float ddd2 = mix(d2, dd2, abs(sin(iTime)));\n  \n    return max(max(d1, -ddd2), -d0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    // camera\n    vec3 cameraOrigin = vec3(0.0, 0.0, -10.0 + iTime * 4.0);\n    vec3 cameraTarget = vec3(cos(iTime) + sin(iTime / 2.0) * 10.0, exp(sin(iTime)) * 2.0, 3.0 + iTime * 4.0);\n    vec3 upDirection = vec3(0.0, 1.0, 0.0);\n    vec3 cameraDir = normalize(cameraTarget - cameraOrigin);\n    vec3 cameraRight = normalize(cross(upDirection, cameraOrigin));\n    vec3 cameraUp = cross(cameraDir, cameraRight);\n    vec3 rayDirection = normalize(cameraRight * p.x + cameraUp * p.y + cameraDir);\n    \n    float depth = 0.0;\n    float ac = 0.0;\n    vec3 rayPos = vec3(0.0);\n    float d = 0.0;\n\n    for(int i = 0; i < 80; i++)\n    {\n        rayPos = cameraOrigin + rayDirection * depth;\n        d = getDistance(rayPos, p);\n\n        if(abs(d) < 0.0001)\n        {\n            break;\n        }\n\n        ac += exp(-d * mix(5.0, 10.0, abs(sin(iTime))));        \n        depth += d;\n    }\n    \n    vec3 col = vec3(0.0, 0.3, 0.7);\n    ac *= 1.2 * (iResolution.x/iResolution.y - abs(p.x)) ;\n    vec3 finalCol = col * ac * 0.06;\n    fragColor = vec4(finalCol, 1.0);\n    fragColor.w = 1.0 - depth * 0.1;\n}",
    "tags": [
      "cineshader"
    ],
    "author": "haquxx",
    "views": 0,
    "likes": 99,
    "published": 3
  },
  {
    "id": "lsX3W4",
    "title": "Mandelbrot - distance",
    "description": "Distance estimation to the Mandelbrot set. Basically, distance(c) = |G(c)|/|G'(c))|. More info in url=https://iquilezles.org/articles/distancefractals]this article[/url].",
    "code": "// Copyright Inigo Quilez, 2013 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work neither\n// as it is or altered, here on Shadertoy or anywhere else, in any\n// form including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it or train a neural\n// network with it without permission. I share this Work for educational\n// purposes, and you can link to it, through an URL, proper attribution\n// and unmodified screenshot, as part of your educational material. If\n// these conditions are too restrictive please contact me and we'll\n// definitely work it out.\n\n// This shader computes the distance to the Mandelbrot Set for everypixel, and colorizes\n// it accoringly.\n// \n// Z -> Z\u00b2+c, Z0 = 0. \n// therefore Z' -> 2\u00b7Z\u00b7Z' + 1\n//\n// The Hubbard-Douady potential G(c) is G(c) = log Z/2^n\n// G'(c) = Z'/Z/2^n\n//\n// So the distance is |G(c)|/|G'(c)| = |Z|\u00b7log|Z|/|Z'|\n//\n// More info here: https://iquilezles.org/articles/distancefractals\n\n\nfloat distanceToMandelbrot( in vec2 c )\n{\n    #if 1\n    {\n        float c2 = dot(c, c);\n        // skip computation inside M1 - https://iquilezles.org/articles/mset1bulb\n        if( 256.0*c2*c2 - 96.0*c2 + 32.0*c.x - 3.0 < 0.0 ) return 0.0;\n        // skip computation inside M2 - https://iquilezles.org/articles/mset2bulb\n        if( 16.0*(c2+2.0*c.x+1.0) - 1.0 < 0.0 ) return 0.0;\n    }\n    #endif\n\n    // iterate\n    float di =  1.0;\n    vec2 z  = vec2(0.0);\n    float m2 = 0.0;\n    vec2 dz = vec2(0.0);\n    for( int i=0; i<300; i++ )\n    {\n        if( m2>1024.0 ) { di=0.0; break; }\n\n\t\t// Z' -> 2\u00b7Z\u00b7Z' + 1\n        dz = 2.0*vec2(z.x*dz.x-z.y*dz.y, z.x*dz.y + z.y*dz.x) + vec2(1.0,0.0);\n\t\t\t\n        // Z -> Z\u00b2 + c\t\t\t\n        z = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\n\t\t\t\n        m2 = dot(z,z);\n    }\n\n    // distance\t\n\t// d(c) = |Z|\u00b7log|Z|/|Z'|\n\tfloat d = 0.5*sqrt(dot(z,z)/dot(dz,dz))*log(dot(z,z));\n    if( di>0.5 ) d=0.0;\n\t\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    // animation\t\n\tfloat tz = 0.5 - 0.5*cos(0.225*iTime);\n    float zoo = pow( 0.5, 13.0*tz );\n\tvec2 c = vec2(-0.05,.6805) + p*zoo;\n\n    // distance to Mandelbrot\n    float d = distanceToMandelbrot(c);\n    \n    // do some soft coloring based on distance\n\td = clamp( pow(4.0*d/zoo,0.2), 0.0, 1.0 );\n    \n    vec3 col = vec3(d);\n    \n    fragColor = vec4( col, 1.0 );\n}",
    "tags": [
      "2d",
      "fractal",
      "mandelbrot",
      "distance"
    ],
    "author": "iq",
    "views": 0,
    "likes": 231,
    "published": 3
  },
  {
    "id": "Xtf3zn",
    "title": "Tokyo",
    "description": "Tokyo by night in the rain. The car model is made by Eiffie (Shiny Toy': https://www.shadertoy.com/view/ldsGWB). I have never been in Tokyo btw.",
    "code": "// Created by Reinder Nijhoff 2014\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n// @reindernijhoff\n//\n// https://www.shadertoy.com/view/Xtf3zn\n//\n// Tokyo by night in the rain. The car model is made by Eiffie\n// (Shiny Toy': https://www.shadertoy.com/view/ldsGWB). \n// I have never been in Tokyo btw.\n\n#define BUMPMAP\n#define MARCHSTEPS 128\n#define MARCHSTEPSREFLECTION 48\n#define LIGHTINTENSITY 5.\n\n//----------------------------------------------------------------------\n\nconst vec3 backgroundColor = vec3(0.2,0.4,0.6) * 0.09;\n#define time (iTime + 90.)\n\n//----------------------------------------------------------------------\n// noises\n\nfloat hash( float n ) {\n    return fract(sin(n)*687.3123);\n}\n\nfloat noise( in vec2 x ) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*157.0;\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n               mix( hash(n+157.0), hash(n+158.0),f.x),f.y);\n}\n\nconst mat2 m2 = mat2( 0.80, -0.60, 0.60, 0.80 );\n\nfloat fbm( vec2 p ) {\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m2*p*2.02;\n    f += 0.2500*noise( p ); p = m2*p*2.03;\n    f += 0.1250*noise( p ); p = m2*p*2.01;\n//    f += 0.0625*noise( p );\n    \n    return f/0.9375;\n}\n\n//----------------------------------------------------------------------\n// distance primitives\n\nfloat udRoundBox( vec3 p, vec3 b, float r ) {\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdBox( in vec3 p, in vec3 b ) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdSphere( in vec3 p, in float s ) {\n    return length(p)-s;\n}\n\nfloat sdCylinder( in vec3 p, in vec2 h ) {\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n//----------------------------------------------------------------------\n// distance operators\n\nfloat opU( float d2, float d1 ) { return min( d1,d2); }\nfloat opS( float d2, float d1 ) { return max(-d1,d2); }\nfloat smin( float a, float b, float k ) { return -log(exp(-k*a)+exp(-k*b))/k; } //from iq\n\n//----------------------------------------------------------------------\n// Map functions\n\n// car model is made by Eiffie\n// shader 'Shiny Toy': https://www.shadertoy.com/view/ldsGWB\n\nfloat mapCar(in vec3 p0){ \n\tvec3 p=p0+vec3(0.0,1.24,0.0);\n\tfloat r=length(p.yz);\n\tfloat d= length(max(vec3(abs(p.x)-0.35,r-1.92,-p.y+1.4),0.0))-0.05;\n\td=max(d,p.z-1.0);\n\tp=p0+vec3(0.0,-0.22,0.39);\n\tp.xz=abs(p.xz)-vec2(0.5300,0.9600);p.x=abs(p.x);\n\tr=length(p.yz);\n\td=smin(d,length(max(vec3(p.x-0.08,r-0.25,-p.y-0.08),0.0))-0.04,8.0);\n\td=max(d,-max(p.x-0.165,r-0.24));\n\tfloat d2=length(vec2(max(p.x-0.13,0.0),r-0.2))-0.02;\n\td=min(d,d2);\n\n\treturn d;\n}\n\nfloat dL; // minimal distance to light\n\nfloat map( const in vec3 p ) {\n\tvec3 pd = p;\n    float d;\n    \n    pd.x = abs( pd.x );\n    pd.z *= -sign( p.x );\n    \n    float ch = hash( floor( (pd.z+18.*time)/40. ) );\n    float lh = hash( floor( pd.z/13. ) );\n    \n    vec3 pdm = vec3( pd.x, pd.y, mod( pd.z, 10.) - 5. );\n    dL = sdSphere( vec3(pdm.x-8.1,pdm.y-4.5,pdm.z), 0.1 );\n    \n    dL = opU( dL, sdBox( vec3(pdm.x-12., pdm.y-9.5-lh,  mod( pd.z, 91.) - 45.5 ), vec3(0.2,4.5, 0.2) ) );\n    dL = opU( dL, sdBox( vec3(pdm.x-12., pdm.y-11.5+lh, mod( pd.z, 31.) - 15.5 ), vec3(0.22,5.5, 0.2) ) );\n    dL = opU( dL, sdBox( vec3(pdm.x-12., pdm.y-8.5-lh,  mod( pd.z, 41.) - 20.5 ), vec3(0.24,3.5, 0.2) ) );\n   \n    if( lh > 0.5 ) {\n\t    dL = opU( dL, sdBox( vec3(pdm.x-12.5,pdm.y-2.75-lh,  mod( pd.z, 13.) - 6.5 ), vec3(0.1,0.25, 3.2) ) );\n    }\n    \n    vec3 pm = vec3( mod( pd.x + floor( pd.z * 4. )*0.25, 0.5 ) - 0.25, pd.y, mod( pd.z, 0.25 ) - 0.125 );\n\td = udRoundBox( pm, vec3( 0.245,0.1, 0.12 ), 0.005 ); \n    \n    d = opS( d, -(p.x+8.) );\n    d = opU( d, pd.y );\n\n    vec3 pdc = vec3( pd.x, pd.y, mod( pd.z+18.*time, 40.) - 20. );\n    \n    // car\n    if( ch > 0.75 ) {\n        pdc.x += (ch-0.75)*4.;\n\t    dL = opU( dL, sdSphere( vec3( abs(pdc.x-5.)-1.05, pdc.y-0.55, pdc.z ),    0.025 ) );\n\t    dL = opU( dL, sdSphere( vec3( abs(pdc.x-5.)-1.2,  pdc.y-0.65,  pdc.z+6.05 ), 0.025 ) );\n\n        d = opU( d,  mapCar( (pdc-vec3(5.,-0.025,-2.3))*0.45 ) );\n \t}\n    \n    d = opU( d, 13.-pd.x );\n    d = opU( d, sdCylinder( vec3(pdm.x-8.5, pdm.y, pdm.z), vec2(0.075,4.5)) );\n    d = opU( d, dL );\n    \n\treturn d;\n}\n\n//----------------------------------------------------------------------\n\nvec3 calcNormalSimple( in vec3 pos ) {   \n    const vec2 e = vec2(1.0,-1.0)*0.005;\n\n    vec3 n = normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t    e.yyx*map( pos + e.yyx )   + \n\t\t\t\t\t    e.yxy*map( pos + e.yxy )   + \n\t\t\t\t\t    e.xxx*map( pos + e.xxx )   );  \n    return n;\n}\n\nvec3 calcNormal( in vec3 pos ) {\n    vec3 n = calcNormalSimple( pos );\n    if( pos.y > 0.12 ) return n;\n\n#ifdef BUMPMAP\n    vec2 oc = floor( vec2(pos.x+floor( pos.z * 4. )*0.25, pos.z) * vec2( 2., 4. ) );\n\n    if( abs(pos.x)<8. ) {\n\t\toc = pos.xz;\n    }\n    \n     vec3 p = pos * 250.;\n   \t vec3 xn = 0.05*vec3(noise(p.xz)-0.5,0.,noise(p.zx)-0.5);\n     xn += 0.1*vec3(fbm(oc.xy)-0.5,0.,fbm(oc.yx)-0.5);\n    \n    n = normalize( xn + n );\n#endif\n    \n    return n;\n}\n\nvec3 int1, int2, nor1;\nvec4 lint1, lint2;\n\nfloat intersect( in vec3 ro, in vec3 rd ) {\n\tconst float precis = 0.001;\n    float h = precis*2.0;\n    float t = 0.;\n    int1 = int2 = vec3( -500. );\n    lint1 = lint2 = vec4( -500. );\n    float mld = 100.;\n    \n\tfor( int i=0; i < MARCHSTEPS; i++ ) {\n        h = map( ro+rd*t );\n\t\tif(dL < mld){\n\t\t\tmld=dL;\n            lint1.xyz = ro+rd*t;\n\t\t\tlint1.w = abs(dL);\n\t\t}\n        if( h < precis ) {\n            int1.xyz = ro+rd*t;\n            break;\n        } \n        t += max(h, precis*2.);\n    }\n    \n    if( int1.z < -400. || t > 300.) {\n        // check intersection with plane y = -0.1;\n        float d = -(ro.y + 0.1)/rd.y;\n\t\tif( d > 0. ) {\n\t\t\tint1.xyz = ro+rd*d;\n\t    } else {\n        \treturn -1.;\n    \t}\n    }\n    \n    ro = ro + rd*t;\n    nor1 = calcNormal(ro);\n    ro += 0.01*nor1;\n    rd = reflect( rd, nor1 );\n    t = 0.0;\n    h = precis*2.0;\n    mld = 100.;\n    \n    for( int i=0; i < MARCHSTEPSREFLECTION; i++ ) {\n        h = map( ro+rd*t );\n\t\tif(dL < mld){\n\t\t\tmld=dL;            \n            lint2.xyz = ro+rd*t;\n\t\t\tlint2.w = abs(dL);\n\t\t}\n        if( h < precis ) {\n   \t\t\tint2.xyz = ro+rd*t;\n            return 1.;\n        }   \n        t += max(h, precis*2.);\n    }\n\n    return 0.;\n}\n\n//----------------------------------------------------------------------\n// shade\n\nvec3 shade( in vec3 ro, in vec3 pos, in vec3 nor ) {\n    vec3  col = vec3(0.5);\n    \n    if( abs(pos.x) > 15. || abs(pos.x) < 8. ) col = vec3( 0.02 );\n    if( pos.y < 0.01 ) {\n        if( abs( int1.x ) < 0.1 ) col = vec3( 0.9 );\n        if( abs( abs( int1.x )-7.4 ) < 0.1 ) col = vec3( 0.9 );\n    }    \n    \n    float sh = clamp( dot( nor, normalize( vec3( -0.3, 0.3, -0.5 ) ) ), 0., 1.);\n  \tcol *= (sh * backgroundColor);  \n \n    if( abs( pos.x ) > 12.9 && pos.y > 9.) { // windows\n        float ha = hash(  133.1234*floor( pos.y / 3. ) + floor( (pos.z) / 3. ) );\n        if( ha > 0.95) {\n            col = ( (ha-0.95)*10.) * vec3( 1., 0.7, 0.4 );\n        }\n    }\n    \n\tcol = mix(  backgroundColor, col, exp( min(max(0.1*pos.y,0.25)-0.065*distance(pos, ro),0.) ) );\n  \n    return col;\n}\n\nvec3 getLightColor( in vec3 pos ) {\n    vec3 lcol = vec3( 1., .7, .5 );\n    \n\tvec3 pd = pos;\n    pd.x = abs( pd.x );\n    pd.z *= -sign( pos.x );\n    \n    float ch = hash( floor( (pd.z+18.*time)/40. ) );\n    vec3 pdc = vec3( pd.x, pd.y, mod( pd.z+18.*time, 40.) - 20. );\n\n    if( ch > 0.75 ) { // car\n        pdc.x += (ch-0.75)*4.;\n        if(  sdSphere( vec3( abs(pdc.x-5.)-1.05, pdc.y-0.55, pdc.z ), 0.25) < 2. ) {\n            lcol = vec3( 1., 0.05, 0.01 );\n        }\n    }\n    if( pd.y > 2. && abs(pd.x) > 10. && pd.y < 5. ) {\n        float fl = floor( pd.z/13. );\n        lcol = 0.4*lcol+0.5*vec3( hash( .1562+fl ), hash( .423134+fl ), 0. );\n    }\n    if(  abs(pd.x) > 10. && pd.y > 5. ) {\n        float fl = floor( pd.z/2. );\n        lcol = 0.5*lcol+0.5*vec3( hash( .1562+fl ),  hash( .923134+fl ), hash( .423134+fl ) );\n    }\n   \n    return lcol;\n}\n\nfloat randomStart(vec2 co){return 0.8+0.2*hash(dot(co,vec2(123.42,117.853))*412.453);}\n\n//----------------------------------------------------------------------\n// main\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {    \n    vec2 q = fragCoord.xy / iResolution.xy;\n\tvec2 p = -1.0 + 2.0*q;\n\tp.x *= iResolution.x / iResolution.y;\n        \n    if (q.y < .12 || q.y >= .88) {\n\t\tfragColor=vec4(0.,0.,0.,1.);\n\t\treturn;\n    } else {\n    \n        // camera\n        float z = time;\n        float x = -10.9+1.*sin(time*0.2);\n        vec3 ro = vec3(x,  1.3+.3*cos(time*0.26), z-1.);\n        vec3 ta = vec3(-8.,1.3+.4*cos(time*0.26), z+4.+cos(time*0.04));\n\n        vec3 ww = normalize( ta - ro );\n        vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n        vec3 vv = normalize( cross(uu,ww));\n        vec3 rd = normalize( -p.x*uu + p.y*vv + 2.2*ww );\n\n        vec3 col = backgroundColor;\n\n        // raymarch\n        float ints = intersect(ro+randomStart(p)*rd ,rd );\n        if(  ints > -0.5 ) {\n\n            // calculate reflectance\n            float r = 0.09;     \t        \n            if( int1.y > 0.129 ) r = 0.025 * hash(  133.1234*floor( int1.y / 3. ) + floor( int1.z / 3. ) );\n            if( abs(int1.x) < 8. ) {\n                if( int1.y < 0.01 ) { // road\n                    r = 0.007*fbm(int1.xz);\n                } else { // car\n                    r = 0.02;\n                }\n            }\n            if( abs( int1.x ) < 0.1 ) r *= 4.;\n            if( abs( abs( int1.x )-7.4 ) < 0.1 ) r *= 4.;\n\n            r *= 2.;\n\n            col = shade( ro, int1.xyz, nor1 );\n\n            if( ints > 0.5 ) {\n                col += r * shade( int1.xyz, int2.xyz, calcNormalSimple(int2.xyz) );\n            }  \n            if( lint2.w > 0. ) {            \n                col += (r*LIGHTINTENSITY*exp(-lint2.w*7.0)) * getLightColor(lint2.xyz);\n            } \n        } \n\n        // Rain (by Dave Hoskins)\n        vec2 st = 256. * ( p* vec2(.5, .01)+vec2(time*.13-q.y*.6, time*.13) );\n        float f = noise( st ) * noise( st*0.773) * 1.55;\n        f = 0.25+ clamp(pow(abs(f), 13.0) * 13.0, 0.0, q.y*.14);\n\n        if( lint1.w > 0. ) {\n            col += (f*LIGHTINTENSITY*exp(-lint1.w*7.0)) * getLightColor(lint1.xyz);\n        }  \n\n        col += 0.25*f*(0.2+backgroundColor);\n\n        // post processing\n        col = pow( clamp(col,0.0,1.0), vec3(0.4545) );\n        col *= 1.2*vec3(1.,0.99,0.95);   \n        col = clamp(1.06*col-0.03, 0., 1.);  \n        q.y = (q.y-.12)*(1./0.76);\n        col *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 ); \n\n        fragColor = vec4( col, 1.0 );\n    }\n}\n",
    "tags": [
      "raymarching",
      "reflection",
      "rain",
      "city",
      "car"
    ],
    "author": "reinder",
    "views": 0,
    "likes": 317,
    "published": 3
  },
  {
    "id": "MlsfR4",
    "title": "fractal pulse",
    "description": "0f9isdf",
    "code": "#define MAXDIST 20.\n#define GIFLENGTH 1.570795\n\nstruct Ray {\n\tvec3 ro;\n    vec3 rd;\n};\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat length6( vec3 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y + p.z, 1.0/6.0 );\n}\n\nfloat fractal(vec3 p)\n{\n   \tfloat len = length(p);\n    p=p.yxz;\n\n    float scale = 1.25;\n    const int iterations = 28;\n    float a = iTime;\n\tfloat l = 0.;\n    \n    vec2 rotationAnimAmp = vec2(0.05,0.04);\n\tvec2 rotationPhase = vec2(.45 + sin(iTime*4. + len*0.4) * 0.025,0.15 + cos(-0.2+iTime*4. + len*0.2) * 0.05);\n\t\n    // uncomment this to find good spots with the mouse :)\n    //m = iMouse.xy / iResolution.xy;\n    \n    vec3 juliaOffset = vec3(-3.,-1.15,-.5);\n    \n    pR(p.xy,.5+sin(-0.25+iTime*4.)*0.1);\n    \n    for (int i=0; i<iterations; i++) {\n\t\tp = abs(p);\n        // scale and offset the position\n\t\tp = p*scale + juliaOffset;\n        \n        // Rotate the position\n        pR(p.xz,rotationPhase.x*3.14 + cos(iTime*4. + len)*rotationAnimAmp.y);\n\t\tpR(p.yz,rotationPhase.y*3.14 + sin(iTime*4. + len)*rotationAnimAmp.x);\t\t\n        l=length6(p);\n\t}\n\treturn l*pow(scale, -float(iterations))-.25;\n}\n\nvec2 map(vec3 pos) {\n    float l = length(pos);\n\n    float dist = fractal(pos);\n\n    return vec2(dist, 0.);\n}\n\nvec2 march(Ray ray) \n{\n    const int steps = 30;\n    const float prec = 0.001;\n    vec2 res = vec2(0.);\n    \n    for (int i = 0; i < steps; i++) \n    {        \n        vec2 s = map(ray.ro + ray.rd * res.x);\n        \n        if (res.x > MAXDIST || s.x < prec) \n        {\n        \tbreak;    \n        }\n        \n        res.x += s.x;\n        res.y = s.y;\n        \n    }\n   \n    return res;\n}\n\nvec3 calcNormal(vec3 pos) \n{\n\tconst vec3 eps = vec3(0.005, 0.0, 0.0);\n                          \n    return normalize(\n        vec3(map(pos + eps).x - map(pos - eps).x,\n             map(pos + eps.yxz).x - map(pos - eps.yxz).x,\n             map(pos + eps.yzx).x - map(pos - eps.yzx).x ) \n    );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\nfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.2*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= .95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );    \n}\nvec4 render(Ray ray) \n{\n    vec3 col = vec3(0.);\n\tvec2 res = march(ray);\n   \n    if (res.x > MAXDIST) \n    {\n        return vec4(col, MAXDIST);\n    }\n    \n    vec3 p = ray.ro+res.x*ray.rd;\n    vec3 normal = calcNormal(p);\n    vec3 pos = p;\n    ray.ro = pos;\n    // color with ambient occlusion\n   \tcol = vec3(pow(calcAO(p, normal), 3.2))*0.5;\n   \n    col = mix(col, vec3(0.), clamp(res.x/MAXDIST, 0., 1.));\n   \treturn vec4(col, res.x);\n}\nmat3 camera(in vec3 ro, in vec3 rd, float rot) \n{\n\tvec3 forward = normalize(rd - ro);\n    vec3 worldUp = vec3(sin(rot), cos(rot), 0.0);\n    vec3 x = normalize(cross(forward, worldUp));\n    vec3 y = normalize(cross(x, forward));\n    return mat3(x, y, forward);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 camPos = vec3(9., 6.5, 12.);\n    vec3 camDir = camPos + vec3(-.85, -.5, -1. );\n    mat3 cam = camera(camPos, camDir, 0.);\n    \n    vec3 rayDir = cam * normalize( vec3(uv, 1. + sin(iTime*4.)*0.05) );\n    \n    Ray ray;\n    ray.ro = camPos;\n    ray.rd = rayDir;\n    \n    vec4 col = render(ray);\n    col.xyz = pow(col.xyz, vec3(0.6));\n\tfragColor = vec4(col.xyz,clamp(1.-col.w/MAXDIST, 0., 1.));\n}",
    "tags": [
      "1320",
      "cineshader"
    ],
    "author": "macbooktall",
    "views": 0,
    "likes": 118,
    "published": 3
  },
  {
    "id": "wdsfDH",
    "title": "Clouds 3D",
    "description": "Shader for In memoriam",
    "code": "// based in https://www.shadertoy.com/view/4sXGRM\n\nvec3 skytop = vec3(0.05, 0.2, 0.5);\n\nvec3 light = normalize(vec3(0.1, 0.25, 0.9));\n\nvec2 cloudrange = vec2(0.0, 10000.0);\n\nmat3 m = mat3(0.00, 1.60, 1.20, -1.60, 0.72, -0.96, -1.20, -0.96, 1.28);\n\n// hash function              \nfloat hash(float n)\n{\n    return fract(cos(n) * 114514.1919);\n}\n\n// 3d noise function\nfloat noise(in vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = smoothstep(0.0, 1.0, fract(x));\n        \n    float n = p.x + p.y * 10.0 + p.z * 100.0;\n    \n    return mix(\n        mix(mix(hash(n + 0.0), hash(n + 1.0), f.x),\n            mix(hash(n + 10.0), hash(n + 11.0), f.x), f.y),\n        mix(mix(hash(n + 100.0), hash(n + 101.0), f.x),\n            mix(hash(n + 110.0), hash(n + 111.0), f.x), f.y), f.z);\n}\n\n// Fractional Brownian motion\nfloat fbm(vec3 p)\n{\n    float f = 0.5000 * noise(p);\n    p = m * p;\n    f += 0.2500 * noise(p);\n    p = m * p;\n    f += 0.1666 * noise(p);\n    p = m * p;\n    f += 0.0834 * noise(p);\n    return f;\n}\n\nvec3 camera(float time)\n{\n    return vec3(5000.0 * sin(1.0 * time), 5000. + 1500. * sin(0.5 * time), 6000.0 * time);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    float time = (iTime + 13.5 + 44.) * 1.0;\n    vec3 campos = camera(time);\n    vec3 camtar = camera(time + 0.4);\n\n    vec3 front = normalize(camtar - campos);\n    vec3 right = normalize(cross(front, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(right, front));\n    vec3 fragAt = normalize(uv.x * right + uv.y * up + front);\n    \n    // clouds\n    vec4 sum = vec4(0, 0, 0, 0);\n    for (float depth = 0.0; depth < 100000.0; depth += 200.0)\n    {\n        vec3 ray = campos + fragAt * depth;\n        if (cloudrange.x < ray.y && ray.y < cloudrange.y)\n        {\n            float alpha = smoothstep(0.5, 1.0, fbm(ray * 0.00025));\n            vec3 localcolor = mix(vec3(1.1, 1.05, 1.0), vec3(0.3, 0.3, 0.2), alpha);\n            alpha = (1.0 - sum.a) * alpha;\n            sum += vec4(localcolor * alpha, alpha);\n        }\n    }\n    \n    float alpha = smoothstep(0.7, 1.0, sum.a);\n    sum.rgb /= sum.a + 0.0001;\n\n    float sundot = clamp(dot(fragAt, light), 0.0, 1.0);\n    vec3 col = 0.8 * (skytop);\n    col += 0.47 * vec3(1.6, 1.4, 1.0) * pow(sundot, 350.0);\n    col += 0.4 * vec3(0.8, 0.9, 1.0) * pow(sundot, 2.0);\n    \n    sum.rgb -= 0.6 * vec3(0.8, 0.75, 0.7) * pow(sundot, 13.0) * alpha;\n    \n    sum.rgb += 0.2 * vec3(1.3, 1.2, 1.0) * pow(sundot, 5.0) * (1.0 - alpha);\n\n    col = mix(col, sum.rgb, sum.a);\n\n    fragColor = vec4(col, 1.0);\n    // fragColor = vec4(col, sum.a);\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"Murieron\",\n\t\"description\": \"Homenaje a las v\u00edctimas del COVID-19\",\n\t\"model\": \"person\"\n}\n*/",
    "tags": [
      "cineshader"
    ],
    "author": "murieron",
    "views": 0,
    "likes": 48,
    "published": 3
  },
  {
    "id": "tlGXRz",
    "title": "Dth Str",
    "description": "from angle of victims",
    "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n \t\t\n    float t =  -iTime * 3. + 5000. +  sin(iTime / 3.) * 5.;\n    \n    float dist = distance(uv, vec2(0., 0.)) * .6;\n    float maxDist = .5;\n    vec4 color;\n               \n    float expDist = dist * dist * dist;\n    float strength = (sin(expDist * 100.)+1.)/2.;\n    float height = (sin(t * strength)+1.)/2.;\n    float alpha = 1. - expDist / (maxDist * maxDist * maxDist) + (1. - height) * -0.014  ;\n    color = vec4(.9,.9,.9, 9.) * height - (1. - alpha) * 0.652;\n    color.a = alpha;\n    if(dist > maxDist) color = vec4(.1,.1,.1, 0.);\n    fragColor = color;\n}",
    "tags": [
      "cineshader"
    ],
    "author": "amausagi",
    "views": 0,
    "likes": 52,
    "published": 3
  },
  {
    "id": "wttXDl",
    "title": "Palace of Mind",
    "description": "IFS",
    "code": "vec2 rot(vec2 p,float r) {\n    mat2 m = mat2(cos(r),sin(r),-sin(r),cos(r));\n    return m*p;\n}\n\nfloat cube(vec3 p,vec3 s) {\n    vec3 q = abs(p);\n    vec3 m = max(s - q,0.0);\n    return length(max(q - s,0.0)) - min(min(m.x,m.y),m.z);\n}\n\n\nfloat hasira(vec3 p,vec3 s) {\n    vec2 q = abs(p.xy);\n    vec2 m = max(s.xy - q.xy,vec2(0.0,0.0));\n    return length(max(q.xy - s.xy,0.0)) - min(m.x,m.y);\n}\n\nfloat closs(vec3 p,vec3 s) {\n    float d1 = hasira(p,s);\n    float d2 = hasira(p.yzx,s.yzx);\n    float d3 = hasira(p.zxy,s.zxy);\n    return min(min(d1,d2),d3);\n}\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat dist(vec3 p) {\n    float k = 1.2;\n    vec3 sxyz = floor((p.xyz - 0.5 * k) / k) * k;\n    float sz = rand(sxyz.xz);\n    float t = iTime*0.05+50.0;\n    p.xy = rot(p.xy, t*sign(sz-0.5) * (sz * 0.5 + 0.7));\n    p.z += t*sign(sz - 0.5)*(sz*0.5+0.7);\n    p = mod(p, k) - 0.5*k;\n    float s = 7.0;\n    p *= s;\n    p.yz = rot(p.yz, 0.76);\n    for (int i = 0; i < 4; i++) {\n        p = abs(p) - 0.4+(0.25+0.1*sz)*sin(t*(0.5+sz));\n        p.xy = rot(p.xy, t*(0.7+sz));\n        p.yz = rot(p.yz, 1.3*t+sz);\n    }\n\n    float d1 = closs(p,vec3(0.06,0.06,0.06));\n\n    return d1/s;\n}\n\nvec3 gn(vec3 p) {\n\n    const float h = 0.001;\n    const vec2 k = vec2(1.0, -1.0);\n    return normalize(k.xyy * dist(p + k.xyy * h) +\n                     k.yyx * dist(p + k.yyx * h) +\n                     k.yxy * dist(p + k.yxy * h) +\n                     k.xxx * dist(p + k.xxx * h));\n\n}\nvec3 light(vec3 p,vec3 view) {\n    vec3 normal = gn(p);\n    float vn = clamp(dot(-view, normal),0.0,1.0);\n    vec3 ld = normalize(vec3(-1,0.9*sin(iTime*0.5)-0.1,0));\n    float NdotL = max(dot(ld, normal), 0.0);\n    vec3 R = normalize(-ld + NdotL * normal * 2.0);\n    float spec = pow(max(dot(-view, R), 0.0), 20.0) * clamp(sign(NdotL),0.0,1.0);\n    vec3 col = vec3(1, 1, 1) * (pow(vn,2.0)*0.9 +spec * 0.3);\n    float  k = 0.5;\n    float ks = 0.9;\n    vec2 sxz = floor((p.xz - 0.5 * ks) / ks) * ks;\n    float sx = rand(sxz);\n    float sy = rand(sxz+100.1);\n    float emissive = clamp(0.001/abs((mod(abs(p.y*sx+p.x*sy)+iTime*sign(sx-0.5)*0.4, k) - 0.5 * k)),0.0,1.0);\n    return clamp(col * vec3(0.3,0.5,0.9)*0.7 +emissive*vec3(0.2,0.2,1.0),0.0,1.0);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.yy;\n    vec3 tn = iTime*vec3(0.0,0.0,1.0)*0.3;\n    float tk = iTime*0.3;\n    vec3 ro = vec3(1.*cos(tk),0.2*sin(tk),1.*sin(tk))+tn;\n    vec3 ta = vec3(0.0,0.0,0.0)+tn;\n    vec3 cdir = normalize(ta-ro);\n    vec3 up =vec3(0.,1.,0.);\n    vec3 side = cross(cdir,up);\n    up = cross(side,cdir);\n    float fov = 1.3;\n    vec3 rd = normalize(p.x*side+p.y*up+cdir*fov);\n    float d = 0.0;\n    float t = 0.1;\n    float far = 18.;\n    float near = t;\n    float hit = 0.0001;\n    for(int i =0;i<100;i++){\n      d = dist(ro+rd*t);\n      t += d;\n      if (hit>d) break;\n    }\n\tvec3 bcol = vec3(0.1, 0.1, 0.8);\n    vec3 col = light(ro + rd * t, rd);\n\n    col = mix(bcol, col, pow(clamp((far - t) / (far - near), 0.0, 1.0),2.0));\n\n   \tcol.x = pow(col.x,2.2);\n    col.y = pow(col.y,2.2);\n    col.z = pow(col.z,2.2);\n\tcol *= 2.0;\n    fragColor = vec4(col,1.1-t);\n}\n\n\n",
    "tags": [
      "raymarchingcineshader"
    ],
    "author": "butadiene",
    "views": 0,
    "likes": 46,
    "published": 3
  },
  {
    "id": "MdjGR1",
    "title": "Filtering procedurals",
    "description": "One way to decouple material pattern/texturing/shading from lighting and visibility. The (procedural) texture is adaptively filtered/supersampled based on ray differentials (max 100 samples) at a rate independent of the lighting and visibility/tracing.",
    "code": "// The MIT License\n// Copyright \u00a9 2013 Inigo Quilez\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org/\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A test on using ray differentials (only primary rays for now) to choose texture filtering\n// footprint, and adaptively supersample/filter the procedural texture/patter (up to a rate\n// of 10x10).\n\n// This solves texture aliasing without resorting to full-screen 10x10 supersampling, which would\n// involve doing raytracing and lighting 10x10 times (not realtime at all).\n \n// The tecnique should be used to filter every texture independently. The ratio of the supersampling\n// could be inveresely proportional to the screen/lighing supersampling rate such that the cost\n// of texturing would be constant no matter the final image quality settings.\n\n\n//===============================================================================================\n//===============================================================================================\n\nconst int MaxSamples = 10;  // 10*10\n\nvec3 mytexture( vec3 p, vec3 n, float matid );\n\n// sample a procedural texture with filtering\nvec3 sampleTextureWithFilter( in vec3 uvw, in vec3 ddx_uvw, in vec3 ddy_uvw, in vec3 nor, in float mid )\n{\n    int sx = 1 + int( clamp( 4.0*length(ddx_uvw-uvw), 0.0, float(MaxSamples-1) ) );\n    int sy = 1 + int( clamp( 4.0*length(ddy_uvw-uvw), 0.0, float(MaxSamples-1) ) );\n\n\tvec3 no = vec3(0.0);\n\n    for( int j=0; j<sy; j++ )\n    for( int i=0; i<sx; i++ )\n    {\n        vec2 st = vec2( float(i), float(j) ) / vec2( float(sx),float(sy) );\n        no += mytexture( uvw + st.x*(ddx_uvw-uvw) + st.y*(ddy_uvw-uvw), nor, mid );\n    }\n\n\treturn no / float(sx*sy);\n}\n\nvec3 sampleTexture( in vec3 uvw, in vec3 nor, in float mid )\n{\n    return mytexture( uvw, nor, mid );\n}\n\n\n//===============================================================================================\n//===============================================================================================\n// noise implementation\n//===============================================================================================\n//===============================================================================================\n\nvec3 hash3( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*13.5453123);\n}\n\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash3( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash3( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash3( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash3( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash3( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash3( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash3( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash3( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\n//===============================================================================================\n//===============================================================================================\n// sphere implementation\n//===============================================================================================\n//===============================================================================================\n\nfloat softShadowSphere( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n    vec3 oc = sph.xyz - ro;\n    float b = dot( oc, rd );\n\t\n    float res = 1.0;\n    if( b>0.0 )\n    {\n        float h = dot(oc,oc) - b*b - sph.w*sph.w;\n        res = smoothstep( 0.0, 1.0, 2.0*h/b );\n    }\n    return res;\n}\n\nfloat occSphere( in vec4 sph, in vec3 pos, in vec3 nor )\n{\n    vec3 di = sph.xyz - pos;\n    float l = length(di);\n    return 1.0 - dot(nor,di/l)*sph.w*sph.w/(l*l); \n}\n\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n    float t = -1.0;\n\tvec3  ce = ro - sph.xyz;\n\tfloat b = dot( rd, ce );\n\tfloat c = dot( ce, ce ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h>0.0 )\n\t{\n\t\tt = -b - sqrt(h);\n\t}\n\t\n\treturn t;\n}\n\n//===============================================================================================\n//===============================================================================================\n// scene\n//===============================================================================================\n//===============================================================================================\n\n\n// spheres\nconst vec4 sc0 = vec4( 0.0,1.0, 0.0, 1.0 );\nconst vec4 sc1 = vec4( 0.0,1.0,14.0, 4.0 );\nconst vec4 sc2 = vec4(-11.0,1.0, 12.0, 4.0 );\nconst vec4 sc3 = vec4( 13.0,1.0,-10.0, 4.0 );\n\nfloat intersect( vec3 ro, vec3 rd, out vec3 pos, out vec3 nor, out float occ, out float matid )\n{\n    // raytrace\n\tfloat tmin = 10000.0;\n\tnor = vec3(0.0);\n\tocc = 1.0;\n\tpos = vec3(0.0);\n\t\n\t// raytrace-plane\n\tfloat h = (0.0-ro.y)/rd.y;\n\tif( h>0.0 ) \n\t{ \n\t\ttmin = h; \n\t\tnor = vec3(0.0,1.0,0.0); \n\t\tpos = ro + h*rd;\n\t\tmatid = 0.0;\n\t\tocc = occSphere( sc0, pos, nor ) * \n\t\t\t  occSphere( sc1, pos, nor ) *\n\t\t\t  occSphere( sc2, pos, nor ) *\n\t\t\t  occSphere( sc3, pos, nor );\n\t}\n\n\t// raytrace-sphere\n\th = iSphere( ro, rd, sc0 );\n\tif( h>0.0 && h<tmin ) \n\t{ \n\t\ttmin = h; \n        pos = ro + h*rd;\n\t\tnor = normalize(pos-sc0.xyz); \n\t\tmatid = 1.0;\n\t\tocc = 0.5 + 0.5*nor.y;\n\t}\n\n\th = iSphere( ro, rd, sc1 );\n\tif( h>0.0 && h<tmin ) \n\t{ \n\t\ttmin = h; \n        pos = ro + tmin*rd;\n\t\tnor = normalize(ro+h*rd-sc1.xyz); \n\t\tmatid = 1.0;\n\t\tocc = 0.5 + 0.5*nor.y;\n\t}\n\n\th = iSphere( ro, rd, sc2 );\n\tif( h>0.0 && h<tmin ) \n\t{ \n\t\ttmin = h; \n        pos = ro + tmin*rd;\n\t\tnor = normalize(ro+h*rd-sc2.xyz); \n\t\tmatid = 1.0;\n\t\tocc = 0.5 + 0.5*nor.y;\n\t}\n\n\th = iSphere( ro, rd, sc3 );\n\tif( h>0.0 && h<tmin ) \n\t{ \n\t\ttmin = h; \n        pos = ro + tmin*rd;\n\t\tnor = normalize(ro+h*rd-sc3.xyz); \n\t\tmatid = 1.0;\n\t\tocc = 0.5 + 0.5*nor.y;\n\t}\n\n\treturn tmin;\t\n}\n\nvec3 texCoords( in vec3 p )\n{\n\treturn 64.0*p;\n}\n\nvec3 mytexture( vec3 p, vec3 n, float matid )\n{\n\tp += 0.1;\n\tvec3 ip  = floor(p/20.0);\n\tvec3 fp  = fract(0.5+p/20.0);\n\n\tfloat id = fract(sin(dot(ip,vec3(127.1,311.7, 74.7)))*58.5453123);\n\tid = mix( id, 0.3, matid );\n\t\n\tfloat f = mod( ip.x + mod(ip.y + mod(ip.z, 2.0), 2.0), 2.0 );\n\t\n\tfloat g = 0.5 + 1.0*noise( p * mix( vec3(0.2+0.8*f,1.0,1.0-0.8*f), vec3(1.0), matid) );\n\t\n\tg *= mix( smoothstep( 0.03, 0.04, abs(fp.x-0.5)/0.5 )*\n\t          smoothstep( 0.03, 0.04, abs(fp.z-0.5)/0.5 ),\n\t\t\t  1.0,\n\t\t\t  matid );\n\t\n\tvec3 col = 0.5 + 0.5*sin( 1.0 + 2.0*id + vec3(0.0,1.0,2.0) );\n\t\n\treturn col * g;\n}\n\nvoid calcCamera( out vec3 ro, out vec3 ta )\n{\n\tfloat an = 0.1*iTime;\n\tro = vec3( 5.5*cos(an), 1.0, 5.5*sin(an) );\n    ta = vec3( 0.0, 1.0, 0.0 );\n\n}\n\nvec3 doLighting( in vec3 pos, in vec3 nor, in float occ, in vec3 rd )\n{\n    float sh = min( min( min( softShadowSphere( pos, vec3(0.57703), sc0 ),\n\t\t\t\t              softShadowSphere( pos, vec3(0.57703), sc1 )),\n\t\t\t\t              softShadowSphere( pos, vec3(0.57703), sc2 )),\n                              softShadowSphere( pos, vec3(0.57703), sc3 ));\n\tfloat dif = clamp(dot(nor,vec3(0.57703)),0.0,1.0);\n\tfloat bac = clamp(dot(nor,vec3(-0.707,0.0,-0.707)),0.0,1.0);\n    vec3 lin  = dif*vec3(1.50,1.40,1.30)*sh;\n\t     lin += occ*vec3(0.15,0.20,0.30);\n\t     lin += bac*vec3(0.20,0.20,0.20);\n\t     lin += sh*0.8*pow(clamp(dot(reflect(rd,nor),vec3(0.57703)),0.0,1.0),12.0);\n\n    return lin;\n}\n//===============================================================================================\n//===============================================================================================\n// render\n//===============================================================================================\n//===============================================================================================\n\nvoid calcRayForPixel( vec2 pix, out vec3 resRo, out vec3 resRd )\n{\n\tvec2 p = (-iResolution.xy + 2.0*pix) / iResolution.y;\n\t\n     // camera movement\t\n\tvec3 ro, ta;\n\tcalcCamera( ro, ta );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\t\n\tresRo = ro;\n\tresRd = rd;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2  p  = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n    float th = (-iResolution.x + 2.0*iMouse.x) / iResolution.y;\n\t\n    if( iMouse.z<0.01) th = 0.5/ iResolution.y;\n\t\n\tvec3 ro, rd, ddx_ro, ddx_rd, ddy_ro, ddy_rd;\n\tcalcRayForPixel( fragCoord.xy + vec2(0.0,0.0), ro, rd );\n\tcalcRayForPixel( fragCoord.xy + vec2(1.0,0.0), ddx_ro, ddx_rd );\n\tcalcRayForPixel( fragCoord.xy + vec2(0.0,1.0), ddy_ro, ddy_rd );\n\t\t\n    // trace\n\tvec3 pos, nor;\n\tfloat occ, mid;\n    float t = intersect( ro, rd, pos, nor, occ, mid );\n\n\tvec3 col = vec3(0.9);\n\tif( t<100.0 )\n\t{\n#if 1\n\t\t// -----------------------------------------------------------------------\n        // compute ray differentials by intersecting the tangent plane to the  \n        // surface.\t\t\n\t\t// -----------------------------------------------------------------------\n\n\t\t// computer ray differentials\n\t\tvec3 ddx_pos = ddx_ro - ddx_rd*dot(ddx_ro-pos,nor)/dot(ddx_rd,nor);\n\t\tvec3 ddy_pos = ddy_ro - ddy_rd*dot(ddy_ro-pos,nor)/dot(ddy_rd,nor);\n\n\t\t// calc texture sampling footprint\t\t\n\t\tvec3     uvw = texCoords(     pos );\n\t\tvec3 ddx_uvw = texCoords( ddx_pos );\n\t\tvec3 ddy_uvw = texCoords( ddy_pos );\n#else\n\t\t// -----------------------------------------------------------------------\n        // Because we are in the GPU, we do have access to differentials directly\n        // This wouldn't be the case in a regular raytrace.\n\t\t// It wouldn't work as well in shaders doing interleaved calculations in\n\t\t// pixels (such as some of the 3D/stereo shaders here in Shadertoy)\n\t\t// -----------------------------------------------------------------------\n\t\tvec3 uvw = texCoords( pos );\n\n\t\t// calc texture sampling footprint\t\t\n\t\tvec3 ddx_uvw = uvw + dFdx( uvw ); \n        vec3 ddy_uvw = uvw + dFdy( uvw ); \n#endif\n\t\t// shading\t\t\n\t\tvec3 mate = vec3(0.0);\n\t\t\n\t\tif( p.x<th ) \n            mate = sampleTexture( uvw, nor, mid );\n        else\n            mate = sampleTextureWithFilter( uvw, ddx_uvw, ddy_uvw, nor, mid );\n\n        // lighting\t\n\t\tvec3 lin = doLighting( pos, nor, occ, rd );\n\n        // combine lighting with material\t\t\n\t\tcol = mate * lin;\n\t\t\n        // fog\t\t\n        col = mix( col, vec3(0.9), 1.0-exp( -0.0002*t*t ) );\n\t}\n\t\n    // gamma correction\t\n\tcol = pow( col, vec3(0.4545) );\n\n\tcol *= smoothstep( 0.006, 0.008, abs(p.x-th) );\n\t\n\tfragColor = vec4( col, 1.0 );\n}",
    "tags": [
      "procedural",
      "3d",
      "filter",
      "filtering",
      "differentials"
    ],
    "author": "iq",
    "views": 0,
    "likes": 212,
    "published": 3
  },
  {
    "id": "MsfXRf",
    "title": "Fragment plane",
    "description": "Study simple texture.",
    "code": "#define ITE_MAX 15\n\nvec2 rot(vec2 p, float a)\n{\n\treturn vec2(cos(a) * p.x - sin(a) * p.y, sin(a) * p.x + cos(a) * p.y);\n}\n\nvec3 tex(vec2 uv)\n{\n\tvec3 c = vec3(fract(uv.xyy));\n\tif(mod(uv.x * 2.0, 2.0) < 0.9) return vec3(0);\n\tif(mod(uv.y * 1.0, 1.0) < 0.9) return vec3(0);\n\treturn c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tfloat M   = iTime * 0.5;\n\tfloat fog = 1.0;\n\tvec2 uv   = 2.0 * ( fragCoord.xy / iResolution.xy ) - 1.0;\n\t     uv  *= vec2(iResolution.x / iResolution.y, 1.0);\n\t     uv   = rot(uv, -iMouse.y * 0.015);\n\tvec3  c   = vec3(0);\n\tfor(int i = 0 ; i < ITE_MAX; i++) {\n\t\tc = tex(vec2(uv.x / abs(uv.y / (float(i) + 1.0)) + M + iMouse.x * 0.015, abs(uv.y)));\n\t\tif(length(c) > 0.5) break;\n\t\tuv   = uv.yx * 1.3;\n\t\tfog *= 0.9;\n\t}\n\tfragColor = (1.0 - vec4(c.xyyy * (fog * fog)));\n    fragColor.a = fog;\n}",
    "tags": [
      "mouse",
      "fullscreen",
      "faketexture",
      "cineshader"
    ],
    "author": "gyabo",
    "views": 0,
    "likes": 41,
    "published": 3
  },
  {
    "id": "MlyBRd",
    "title": "narrow sky",
    "description": "sky",
    "code": "const float MATH_PI = float( 3.14159265359 );\nconst vec3 SKY_COLOR = vec3(0.05, 0.2, 0.5);\nconst vec3 LIGHT = normalize( vec3(  0.1, 0.8,  0.9 ) );\nconst vec3 LIGHT_BACK = LIGHT * - 1.0;\nconst float AIRPLANE_SIZE = 20.0; // AIRPLANE\u63cf\u753b\u7bc4\u56f2\u76f4\u5f84\nconst float AIRPLANE_SCALE = 1.0; // AIRPLANE\u30b9\u30b1\u30fc\u30eb\nconst float TIME_SCALE = 1.0;\nconst float EP = 0.0001;\nconst int AIRPLANE_COUNT = 5;\nconst float PI = 3.141592;\nconst float PI2 = PI * 2.0;\n\n\nconst vec2 cloudrange = vec2(0.0, 10000.0);\nconst vec3 cloudmove = vec3(0.0 , 0.0, 600.0);\n\nmat3 airplanes[AIRPLANE_COUNT];\n\nfloat dot2(in vec2 v ) { return dot(v,v); }\nfloat dot2(in vec3 v ) { return dot(v,v); }\n\n// random/hash function              \nfloat hash( float n )\n{\n  return fract(cos(n)*41415.92653);\n}\n\n// 3d noise function\nfloat noise( in vec3 x )\n{\n  vec3 p  = floor(x);\n  vec3 f  = smoothstep(0.0, 1.0, fract(x));\n  float n = p.x + p.y*57.0 + 113.0*p.z;\n\n  return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n    mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n    mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\nmat3 m = mat3( 0.00,  1.60,  1.20, -1.60,  0.72, -0.96, -1.20, -0.96,  1.28 );\n\n// Fractional Brownian motion\nfloat fbm( vec3 p )\n{\n  float f = 0.5000*noise( p ); p = m*p*1.1;\n  f += 0.2500*noise( p ); p = m*p*1.2;\n  f += 0.1666*noise( p ); p = m*p;\n  f += 0.0834*noise( p );\n  return f;\n}\n\nvec3 foldXZ(vec3 p)\n{\n    p.x = abs(p.x);\n    p.z = abs(p.z);\n    return p;\n}\n\nmat2 rotate(float a)\n{\n    float s = sin(a),c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\nvec4 dElongate( in vec3 p, in vec3 h )\n{\n    vec3 q = abs(p)-h;\n    return vec4( max(q,0.0), min(max(q.x,max(q.y,q.z)),0.0) );\n}\n\nfloat dSphere(vec3 pos, float size)\n{\n    return length(pos) - size;\n}\n\nfloat dEllipsoid(vec3 pos, vec3 size)\n{\n    return dSphere(pos / size, 1.0);\n}\n\nfloat dRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat dTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat dBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat dTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat dTree(vec3 po, inout vec4 hitColor)\n{\n    vec3 p = po;\n    // p = vec3(floor(p.x),floor(p.y),floor(p.z));\n    p.x = mod(p.x, 20.) - 10.0;\n    p.z = mod(p.z, 20.) - 10.0;\n\n    vec3 size = vec3(0.4, 4.0, 0.4);\n    float branch = dBox(p, size);\n    for (int i = 0; i < 2; i++)\n    {\n        vec3 q = foldXZ(p);\n        q.y -= size.y;\n        q.xy *= rotate(-0.4);\n        q.zy *= rotate(-0.4);\n        branch = min(branch, dBox(q, size));\n        p = q;\n    }\n\n    p.y -= size.y;\n    float leaf = dEllipsoid(p, vec3(3,2,3));\n\n    if (branch < leaf)\n    {\n        hitColor = vec4(0.44, 0.29, 0.22, 1.0);\n    }\n    else\n    {\n        float hoge = step(fract(po.x) + fract(po.y) + fract(po.z), 0.9) * 0.5;\n        hitColor = vec4(0.44 - hoge, 0.99 - hoge, 0.22 - hoge, 1.0);\n    }\n\n    return min(branch, leaf);\n}\n\nvec3 rotateX(vec3 position, float rotate)\n{\n    return vec3(position.x, position.z * -sin(rotate) + position.y * cos(rotate), position.z * cos(rotate) + position.y * sin(rotate));\n}\n\nfloat dAircraft(vec3 ray, inout vec4 hitColor)\n{\n    vec3 body1 = vec3(0.5, 0.6, 2.0) * AIRPLANE_SCALE;\n    vec3 body1Pos = vec3(0, 0.2, -1.) * AIRPLANE_SCALE;\n    float body1Rot = 3.14 * -0.03;\n    vec3 body2 = vec3(1, 1, 5) * AIRPLANE_SCALE;\n    vec3 body2Pos = vec3(0, 1, 0) * AIRPLANE_SCALE;\n    float body2Rot = 3.14 * 0.0;\n    vec3 body3 = vec3(0.5, 0.9, 7) * AIRPLANE_SCALE;\n    vec3 body3Pos = vec3(1, -1, 1.1) * AIRPLANE_SCALE;\n    float body3Rot = 3.14 * 0.5;\n    vec2 body4 = vec2(0.3, 0.1) * AIRPLANE_SCALE;\n    vec3 body4Pos = vec3(-1.5, 1.5, 1) * AIRPLANE_SCALE;\n    float body4Distortion = 3.14 * 0.0;\n    vec2 body5 = vec2(8.0, -6.0) * AIRPLANE_SCALE;\n    vec3 body5Pos = vec3(0, -1, 0) * AIRPLANE_SCALE;\n    vec2 body6 = vec2(4.0, -3.0) * AIRPLANE_SCALE;\n    vec3 body6Pos = vec3(0, -1.1, -5) * AIRPLANE_SCALE;\n    vec3 body7 = vec3(2.4, 0.5, 2.0) * AIRPLANE_SCALE;\n    vec3 body7Pos = vec3(0, 1.5, 5) * AIRPLANE_SCALE;\n    vec3 body8_1 = vec3(1.2, 0, -4.0) * AIRPLANE_SCALE;\n    vec3 body8_2 = vec3(2.4, 2.5, -7.5) * AIRPLANE_SCALE;\n    vec3 body8_3 = vec3(1.4, -1., -7.5) * AIRPLANE_SCALE;\n    vec3 body8Pos = vec3(0, -1, 0) * AIRPLANE_SCALE;\n\n    float body1Depth = dEllipsoid(rotateX(ray, body1Rot) + body1Pos, body1);\n    float body2Depth = dEllipsoid(rotateX(ray, body2Rot) + body2Pos, body2);\n    float body3Depth = dRoundCone(rotateX(vec3(ray.x, ray.y, ray.z), body3Rot) + body3Pos, body3.x, body3.y, body3.z);\n    // abs\u3057\u305f\u3044\n    float body3_1Depth = dRoundCone(rotateX(vec3(-ray.x, ray.y, ray.z), body3Rot) + body3Pos, body3.x, body3.y, body3.z);\n    vec4 body4_ = dElongate(vec3(abs(ray.x), ray.y, ray.z) + body4Pos + vec3(0, 0, ray.y * -0.5), vec3(0.6, 0.1, 2.0));\n    float body4Depth = body4_.w + dTorus(rotateX(body4_.xzy + vec3(0, 0, 0), body4Distortion), body4);\n    float body5Depth = dTriangle(ray, vec3(body5.x, 0.0, body5.y) + body5Pos, vec3(-body5.x, 0.0, body5.y) + body5Pos, body5Pos) - 0.3;\n    float body6Depth = dTriangle(ray, vec3(body6.x, 0.0, body6.y) + body6Pos, vec3(-body6.x, 0.0, body6.y) + body6Pos, body6Pos) - 0.2;\n    float body7Depth = dBox(ray + body7Pos + vec3(0, 0, ray.y * -0.5), body7);\n    float body8Depth = dTriangle(vec3(abs(ray.x), ray.y, ray.z), body8_1 + body8Pos, body8_2 + body8Pos, body8_3 + body8Pos) - 0.1;\n\n    hitColor = vec4(1.0, 1.0, 1.0, 1.0);\n    float depth = min(min(min(min(min(min(min(min(body1Depth, body2Depth), body3Depth), body3_1Depth), body4Depth), body5Depth), body6Depth), body7Depth), body8Depth);\n\n    if (EP > abs(depth - body1Depth))\n    {\n        hitColor = vec4(0.2, 0.2, 0.2, 1.0);\n    }\n\n    return depth;\n}\n\nvec3 dAircraftNormal(vec3 pos)\n{\n    vec4 _tmp;\n    return normalize(vec3(\n            dAircraft(pos, _tmp) - dAircraft(vec3(pos.x - EP, pos.y, pos.z), _tmp),\n            dAircraft(pos, _tmp) - dAircraft(vec3(pos.x, pos.y - EP, pos.z), _tmp),\n            dAircraft(pos, _tmp) - dAircraft(vec3(pos.x, pos.y, pos.z - EP), _tmp)\n        ));\n}\n\nmat4 getWorldMat(mat3 transform)\n{\n    // trans world\n    vec3 axisX = cross(transform[1], transform[2]) * -1.0;\n\n    return mat4(\n        axisX.x, axisX.y, axisX.z, 0,\n        transform[1].x, transform[1].y, transform[1].z, 0,\n        transform[2].x, transform[2].y, transform[2].z, 0,\n        0, 0, 0, 1 \n        );\n}\n\nvoid airplaneRender(inout vec4 color, inout float depth, float time, vec3 cameraPos, vec3 rayDirection)\n{\n    for (int i = 0; i < AIRPLANE_COUNT; i++)\n    {\n        mat4 worldMat = getWorldMat(airplanes[i]);\n\n        vec3 localCameraPosition = (worldMat * vec4(cameraPos - airplanes[i][0], 1.0)).xyz;\n        vec3 localRayDirection = (worldMat * vec4(rayDirection, 1.0)).xyz;\n\n        float airplaneDepth = length(localCameraPosition) - AIRPLANE_SIZE * 0.5;\n        vec4 hitColor = color;\n\n\n        float marchDepth = 0.0;\n        for (int i = 0; i < 1000; i++)\n        {\n            if (marchDepth > airplaneDepth + AIRPLANE_SIZE || depth < marchDepth)\n            {\n                break;\n            }\n\n            vec3 ray = localCameraPosition + localRayDirection * marchDepth;\n            float diff = dAircraft(ray, hitColor);\n\n            if (diff < EP)\n            {\n                depth = marchDepth + diff;\n                vec3 normal = dAircraftNormal(ray);\n                color = vec4(vec3(clamp(dot(normal, LIGHT) * hitColor, 0.0, 1.0)) + 0.2, 1.0);\n            }\n            else\n            {\n                // \u7d30\u304b\u3044\u6240\u306b\u7cbe\u5ea6\u3092\u3088\u305b\u308b\n                marchDepth += diff;\n            }\n\n            marchDepth += AIRPLANE_SIZE * 0.001;\n        }\n    }\n}\n\nvoid skyRender(inout vec4 color, inout float depth, float time, vec3 cameraPos, vec3 rayDirection)\n{\n    float sundot = clamp(dot(rayDirection, LIGHT),0.0,1.0);\n        \n    // render sky\n    float t = pow(1.0-0.7*rayDirection.y, 15.0);\n    vec3 col = 0.8 * SKY_COLOR;\n    // sun\n    col += 0.47*vec3(1.6,1.4,1.0)*pow( sundot, 350.0 );\n    // sun haze\n    col += 0.4*vec3(0.8,0.9,1.0)*pow( sundot, 2.0 );\n        \n    // CLOUDS\n    vec4 sum = vec4(0,0,0,0);\n    float c = 0.;\n    for(int i=0;i<1000;i++) // or while\n    { \n        c +=100.; // cloud depth\n        vec3 cpos = cameraPos + c*rayDirection + cloudmove * iTime; // cloud position\n        if(cloudrange.x < cpos.y && cpos.y < cloudrange.y){\n            float alpha = smoothstep(0.5, 1.0, fbm( cpos*0.00025 ))*.9; // fractal cloud density\n            vec3 localcolor = mix(vec3( 1.1, 1.05, 1.0 ), 0.7*vec3( 0.4,0.4,0.3 ), alpha); // density color white->gray\n            alpha = (1.0-sum.w)*alpha; // alpha/density saturation (the more a cloud layer's density, the more the higher layers will be hidden)\n            sum += vec4(localcolor*alpha, alpha); // sum up weightened color\n        }\n        \n        if (0. < rayDirection.y && cloudrange.y < cpos.y)\n        break;\n        if (rayDirection.y < 0. && cpos.y < cloudrange.x)\n        break;\n        if (0.98 < sum.w)\n        break;\n        if (depth < c)\n        break;\n    }\n        \n\n\n    float alpha = smoothstep(0.7, 1.0, sum.w);\n    sum.rgb /= sum.w+0.0001;\n\n    sum.rgb -= 0.6*vec3(0.8, 0.75, 0.7)*pow(sundot,13.0)*alpha;\n    sum.rgb += 0.2*vec3(1.3, 1.2, 1.0)* pow(sundot,5.0)*(1.0-alpha);\n\n    col = mix( col, sum.rgb , sum.w );\n\n    color = color + vec4(col, 1.0);\n}\n\nvoid objectRender(inout vec4 color, inout float depth, float time, vec3 cameraPos, vec3 rayDirection)\n{\n    airplaneRender(color, depth, time, cameraPos, rayDirection);\n}\n\nvec3 getAirplanePosition(float time, int index)\n{\n    vec3 line = vec3(0, 5000., 500);\n    vec3 line2 = vec3(cos(time * 0.2) * 1000.0 - 250., 20, sin(time * 0.2 - 10.0) * 1000.0);\n    vec3 member = vec3(float(index) * 20., 10.0, float(index) * 100.);\n    return line + line2 + member;\n}\n\nvoid objectUpdate(float time)\n{\n    mat4 leaderWorld = inverse(getWorldMat(airplanes[0]));\n\n    for(int index = 0; index < AIRPLANE_COUNT; index++)\n    {\n        vec3 position = getAirplanePosition(time, index);\n        vec3 prevPosition = getAirplanePosition(time - EP, index);\n        vec3 nextPosition = getAirplanePosition(time + EP, index);\n        vec3 dir = normalize(nextPosition - position);\n        vec3 top = vec3(0, 1, 0);\n        airplanes[index] = mat3(position, top, dir);\n    }\n}\n\nvoid cameraUpdate(vec2 fragCoord, float time, out vec3 cameraPosition, out vec3 rayDirection)\n{\n    vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    cameraPosition = vec3(sin(1.0*time -10.0) * 100., 5000., 0.0);\n\n    vec3 cameraDirection = normalize(airplanes[0][0] - cameraPosition);\n    vec3 cameraTop = normalize(cameraDirection + vec3(0, 1, 0));\n    vec3 right = normalize(cross(cameraDirection, cameraTop));\n    cameraTop = cross(cameraDirection, right) * -1.0;\n\n    rayDirection = normalize(uv.x * right + uv.y * cameraTop + cameraDirection);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float time = iTime * TIME_SCALE;\n    vec3 cameraPos;\n    vec3 rayDirection;\n    vec4 color;\n    float depth = 100000.0;\n\n    objectUpdate(time);\n    cameraUpdate(fragCoord, time, cameraPos, rayDirection);\n\n    objectRender(color, depth, time, cameraPos, rayDirection);\n    skyRender(color, depth, time, cameraPos, rayDirection);\n\n\tfragColor = color;\n\n    float debugcolor = depth * 0.01;\n    //fragColor = vec4(debugcolor, debugcolor, debugcolor, 1.0);\n}",
    "tags": [
      "sky",
      "cineshader"
    ],
    "author": "lise",
    "views": 0,
    "likes": 13,
    "published": 3
  },
  {
    "id": "MdlXz8",
    "title": "Tileable Water Caustic",
    "description": "Found this on GLSL sandbox. I really liked it, changed a few things and made it tile-able. \nCheck out the #define to see the tiling.\nSee it full-screen if you can.",
    "code": "// Found this on GLSL sandbox. I really liked it, changed a few things and made it tileable.\n// :)\n// by David Hoskins.\n// Original water turbulence effect by joltz0r\n\n\n// Redefine below to see the tiling...\n//#define SHOW_TILING\n\n#define TAU 6.28318530718\n#define MAX_ITER 5\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tfloat time = iTime * .5+23.0;\n    // uv should be the 0-1 uv of texture...\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n#ifdef SHOW_TILING\n\tvec2 p = mod(uv*TAU*2.0, TAU)-250.0;\n#else\n    vec2 p = mod(uv*TAU, TAU)-250.0;\n#endif\n\tvec2 i = vec2(p);\n\tfloat c = 1.0;\n\tfloat inten = .005;\n\n\tfor (int n = 0; n < MAX_ITER; n++) \n\t{\n\t\tfloat t = time * (1.0 - (3.5 / float(n+1)));\n\t\ti = p + vec2(cos(t - i.x) + sin(t + i.y), sin(t - i.y) + cos(t + i.x));\n\t\tc += 1.0/length(vec2(p.x / (sin(i.x+t)/inten),p.y / (cos(i.y+t)/inten)));\n\t}\n\tc /= float(MAX_ITER);\n\tc = 1.17-pow(c, 1.4);\n\tvec3 colour = vec3(pow(abs(c), 8.0));\n    colour = clamp(colour + vec3(0.0, 0.35, 0.5), 0.0, 1.0);\n\n\t#ifdef SHOW_TILING\n\t// Flash tile borders...\n\tvec2 pixel = 2.0 / iResolution.xy;\n\tuv *= 2.0;\n\tfloat f = floor(mod(iTime*.5, 2.0)); \t// Flash value.\n\tvec2 first = step(pixel, uv) * f;\t\t   \t// Rule out first screen pixels and flash.\n\tuv  = step(fract(uv), pixel);\t\t\t\t// Add one line of pixels per tile.\n\tcolour = mix(colour, vec3(1.0, 1.0, 0.0), (uv.x + uv.y) * first.x * first.y); // Yellow line\n\t#endif\n    \n\tfragColor = vec4(colour, 1.0);\n}",
    "tags": [
      "water",
      "caustic"
    ],
    "author": "Dave_Hoskins",
    "views": 0,
    "likes": 611,
    "published": 3
  },
  {
    "id": "ltXyzS",
    "title": "Hot and Cold Crustacean",
    "description": "Varied rotations depending on distance from a point. It goes from hot to cold from within the crustacean's core.",
    "code": "#define M_PI 3.1415926535897932384626433832795\n#define rot(a)  mat2( cos(a), sin(a),  -sin(a), cos(a) )\n\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    // set my uv\n    vec2 uv = iResolution.xy;\n    uv = (u+u - vec2(uv.x, 0) ) / uv.y;\n    \n    float T = iTime;\n    \n    // rotate the uv\n    float l = length(uv);\n    uv *= rot( l * 0.5);\n    uv *= uv/l * 4.0;\t\t// detail resolution\n        \n    // set some colors\n    vec3 color;\n    for( int i = 0; i < 3; i++){\n        float v = length( mod(uv, 0.5) - uv.x * 0.25 );\n        uv.y *= ((sin( v * 5.0) ) * 0.5) * ((sin(T - length(uv) * 0.5 ) + M_PI) * 0.4);\n        color[i] = cos(T + pow(length(uv), float(i) * 0.25));\n    }\n\n    vec3 color2 = vec3(pow(uv.y, 1.0) * 0.5);\n    fragColor = vec4( mix(color, color2, length(uv) * 0.5), 1.0);\n}",
    "tags": [
      "2d",
      "sin",
      "rotate",
      "hot",
      "cold",
      "crustacean",
      "cineshader"
    ],
    "author": "TheGrego",
    "views": 0,
    "likes": 33,
    "published": 3
  },
  {
    "id": "4td3zj",
    "title": "Raymarched Hexagonal Truchet",
    "description": "Raymarched hexagonal Truchet tile, based off of Fabrice and Mattz's examples.",
    "code": "/*\n\n\tRaymarched Hexagonal Truchet\n\t----------------------------\n\n\tRaymarching a hexagonal Truchet pattern. The Truchet pattern itself is pretty easy to produce.\n\tThis particular production method is based off of one of Fabrice Neyret's finely tuned examples, \n\twhich in turn was based on something Mattz did a while back. Both examples are below.\n\n\tTechnically, there isn't a lot to it. The hardest part was producing the Truchet pattern in a \n\treasonably quick way, but most of that was already done for me. Therefore, since I had nothing new \n\tto add, I prettied it up a bit... and by that I mean, I made it really shiny. Probably too shiny. \n\tIt kind of hurts my eyes. :)\n\n\tThe weird, abstract, dragon disco style wasn't intentional. I'm briefly passing through parts of \n\tAsia next week, so that may have mildy influenced my style choices. Hopefully, it meets \n\t834144373's approval. :)\n\t\n\n\tBased on:\n\n\thexagonal truchet ( 352 ) - FabriceNeyret2\n\thttps://www.shadertoy.com/view/Xdt3D8\n\n\t... which, in turn, was based on:\n\thexagonal tiling - mattz\n\thttps://www.shadertoy.com/view/4d2GzV\n\n*/\n\n\n// Using a 2D Hexagonal Truchet pattern as the source of the height map. This is based on Fabrice's \n// example which in turn was based on one by Mattz. I tailored it to suit my needs - and hopefully, \n// sped it up a bit, but it wouldn't shock me if I'd slowed it down instead. :)\n//\n// The process is pretty simple: Break space up into hexagons and color them according to the distance \n// from the center, then randomly flip some about the X-axis. The pattern you're left with isn't that \n// visually appealing. However, once you wrap or fold the values over, you get some nice symmetrical \n// patterns.\n// \n// Just to complicate things slightly, I'm performing the final value folding steps outside of this\n// function in order to color things in sections... It's not that important.\nfloat heightMap(in vec2 p) { \n    \n    p *= 3.;\n    \n\t// Hexagonal coordinates.\n    vec2 h = vec2(p.x + p.y*.57735, p.y*1.1547);\n    \n    // Closest hexagon center.\n    vec2 fh = floor(h);\n    vec2 f = h - fh; h = fh;\n    float c = fract((h.x + h.y)/3.);\n    h =  c<.666 ?   c<.333 ?  h  :  h + 1.  :  h  + step(f.yx, f); \n\n    p -= vec2(h.x - h.y*.5, h.y*.8660254);\n    \n    // Rotate (flip, in this case) random hexagons. Otherwise, you'd have a bunch of circles only.\n    // Note that \"h\" is unique to each hexagon, so we can use it as the random ID.\n    c = fract(cos(dot(h, vec2(41, 289)))*43758.5453); // Reusing \"c.\"\n    p -= p*step(c, .5)*2.; // Equivalent to: if (c<.5) p *= -1.;\n    \n    // Minimum squared distance to neighbors. Taking the square root after comparing, for speed.\n    // Three partitions need to be checked due to the flipping process.\n    p -= vec2(-1, 0);\n    c = dot(p, p); // Reusing \"c\" again.\n    p -= vec2(1.5, .8660254);\n    c = min(c, dot(p, p));\n    p -= vec2(0, -1.73205);\n    c = min(c, dot(p, p));\n    \n    return sqrt(c);\n    \n    // Wrapping the values - or folding the values over (abs(c-.5)*2., cos(c*6.283*1.), etc) - to produce \n    // the nicely lined-up, wavy patterns. I\"m perfoming this step in the \"map\" function. It has to do \n    // with coloring and so forth.\n    //c = sqrt(c);\n    //c = cos(c*6.283*1.) + cos(c*6.283*2.);\n    //return (clamp(c*.6+.5, 0., 1.));\n\n}\n\n// Raymarching an XY-plane - raised a little by the hexagonal Truchet heightmap. Pretty standard.\nfloat map(vec3 p){\n    \n    \n    float c = heightMap(p.xy); // Height map.\n    // Wrapping, or folding the height map values over, to produce the nicely lined-up, wavy patterns.\n    c = cos(c*6.2831589) + cos(c*6.2831589*2.);\n    c = (clamp(c*.6 +.5, 0., 1.));\n\n    \n    // Back plane, placed at vec3(0., 0., 1.), with plane normal vec3(0., 0., -1).\n    // Adding some height to the plane from the heightmap. Not much else to it.\n    return 1. - p.z - c*.025;\n\n    \n}\n\n// The normal function with some edge detection and curvature rolled into it. Sometimes, it's possible to \n// get away with six taps, but we need a bit of epsilon value variance here, so there's an extra six.\nvec3 getNormal(vec3 p, inout float edge, inout float crv) { \n\t\n    vec2 e = vec2(.01, 0); // Larger epsilon for greater sample spread, thus thicker edges.\n\n    // Take some distance function measurements from either side of the hit point on all three axes.\n\tfloat d1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\tfloat d3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\tfloat d5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\tfloat d = map(p)*2.;\t// The hit point itself - Doubled to cut down on calculations. See below.\n     \n    // Edges - Take a geometry measurement from either side of the hit point. Average them, then see how\n    // much the value differs from the hit point itself. Do this for X, Y and Z directions. Here, the sum\n    // is used for the overall difference, but there are other ways. Note that it's mainly sharp surface \n    // curves that register a discernible difference.\n    edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);\n    //edge = max(max(abs(d1 + d2 - d), abs(d3 + d4 - d)), abs(d5 + d6 - d)); // Etc.\n    \n    // Once you have an edge value, it needs to normalized, and smoothed if possible. How you \n    // do that is up to you. This is what I came up with for now, but I might tweak it later.\n    edge = smoothstep(0., 1., sqrt(edge/e.x*2.));\n    \n    // We may as well use the six measurements to obtain a rough curvature value while we're at it.\n    crv = clamp((d1 + d2 + d3 + d4 + d5 + d6 - d*3.)*32. + .6, 0., 1.);\n\t\n    // Redoing the calculations for the normal with a more precise epsilon value.\n    e = vec2(.0025, 0);\n\td1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\td3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\td5 = map(p + e.yyx), d6 = map(p - e.yyx); \n    \n    \n    // Return the normal.\n    // Standard, normalized gradient mearsurement.\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calculateAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 2., occ = 0.;\n    for(float i=0.; i<5.; i++){\n    \n        float hr = .01 + i*.5/4.;        \n        float dd = map(n * hr + p);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp(1.0 - occ, 0., 1.);    \n}\n\n\n/*\n// Surface bump function. Cheap, but with decent visual impact.\nfloat bumpSurf3D( in vec3 p){\n    \n    float c = heightMap((p.xy + p.z*.025)*6.);\n    c = cos(c*6.283*3.);\n    //c = sqrt(clamp(c+.5, 0., 1.));\n    c = (c*.5 + .5);\n    \n    return c;\n\n}\n\n// Standard function-based bump mapping function.\nvec3 dbF(in vec3 p, in vec3 nor, float bumpfactor){\n    \n    const vec2 e = vec2(0.001, 0);\n    float ref = bumpSurf3D(p);                 \n    vec3 grad = (vec3(bumpSurf3D(p - e.xyy),\n                      bumpSurf3D(p - e.yxy),\n                      bumpSurf3D(p - e.yyx) )-ref)/e.x;                     \n          \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + grad*bumpfactor );\n\t\n}\n*/\n\n// Compact, self-contained version of IQ's 3D value noise function.\nfloat n3D(vec3 p){\n    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(mod(h, 6.2831589))*43758.5453), \n            fract(sin(mod(h + s.x, 6.2831589))*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n// Simple environment mapping. Pass the reflected vector in and create some\n// colored noise with it. The normal is redundant here, but it can be used\n// to pass into a 3D texture mapping function to produce some interesting\n// environmental reflections.\nvec3 envMap(vec3 rd, vec3 sn){\n    \n    vec3 sRd = rd; // Save rd, just for some mixing at the end.\n    \n    // Add a time component, scale, then pass into the noise function.\n    rd.xy -= iTime*.25;\n    rd *= 3.;\n    \n    float c = n3D(rd)*.57 + n3D(rd*2.)*.28 + n3D(rd*4.)*.15; // Noise value.\n    c = smoothstep(.4, 1., c); // Darken and add contast for more of a spotlight look.\n    \n    vec3 col = vec3(c, c*c, c*c*c*c); // Simple, warm coloring.\n    //vec3 col = vec3(min(c*1.5, 1.), pow(c, 2.5), pow(c, 12.)); // More color.\n    \n    // Mix in some more red to tone it down and return.\n    return mix(col, col.yzx, sRd*.25+.25); \n    \n}\n\n// vec2 to vec2 hash.\nvec2 hash22(vec2 p) { \n\n    // Faster, but doesn't disperse things quite as nicely as other combinations. :)\n    float n = sin(mod(dot(p, vec2(41, 289)), 6.2831589));\n    return fract(vec2(262144, 32768)*n)*.75 + .25; \n    \n    // Animated.\n    //p = fract(vec2(262144, 32768)*n); \n    //return sin( p*6.2831853 + iTime )*.35 + .65; \n    \n}\n\n// 2D 2nd-order Voronoi: Obviously, this is just a rehash of IQ's original. I've tidied\n// up those if-statements. Since there's less writing, it should go faster. That's how \n// it works, right? :)\n//\nfloat Voronoi(in vec2 p){\n    \n\tvec2 g = floor(p), o; p -= g;\n\t\n\tvec3 d = vec3(1); // 1.4, etc. \"d.z\" holds the distance comparison value.\n    \n\tfor(int y = -1; y <= 1; y++){\n\t\tfor(int x = -1; x <= 1; x++){\n            \n\t\t\to = vec2(x, y);\n            o += hash22(g + o) - p;\n            \n\t\t\td.z = dot(o, o); \n            // More distance metrics.\n            //o = abs(o);\n            //d.z = max(o.x*.8666 + o.y*.5, o.y);// \n            //d.z = max(o.x, o.y);\n            //d.z = (o.x*.7 + o.y*.7);\n            \n            d.y = max(d.x, min(d.y, d.z));\n            d.x = min(d.x, d.z); \n                       \n\t\t}\n\t}\n\t\n    return max(d.y/1.2 - d.x*1., 0.)/1.2;\n    //return d.y - d.x; // return 1.-d.x; // etc.\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    \n    // Unit directional ray - Coyote's observation.\n    vec3 rd = normalize(vec3(2.*fragCoord - iResolution.xy, iResolution.y));\n\n    float tm = iTime/2.;\n    // Rotate the XY-plane back and forth. Note that sine and cosine are kind of rolled into one.\n    vec2 a = sin(vec2(1.570796, 0) + sin(tm/4.)*.3); // Fabrice's observation.\n    rd.xy = mat2(a, -a.y, a.x)*rd.xy;\n    \n    \n    // Ray origin. Moving in the X-direction to the right.\n    vec3 ro = vec3(tm, cos(tm/4.), 0.);\n    \n    \n    // Light position, hovering around behind the camera.\n    vec3 lp = ro + vec3(cos(tm/2.)*.5, sin(tm/2.)*.5, -.5);\n    \n    // Standard raymarching segment. Because of the straight forward setup, not many iterations are necessary.\n    float d, t=0.;\n    for(int j=0;j<32;j++){\n      \n        d = map(ro + rd*t); // distance to the function.\n        t += d*.7; // Total distance from the camera to the surface.\n        \n        // The plane \"is\" the far plane, so no \"far = plane\" break is needed.\n        if(d<0.001) break; \n    \n    }\n    \n    // Edge and curve value. Passed into, and set, during the normal calculation.\n    float edge, crv;\n   \n    // Surface postion, surface normal and light direction.\n    vec3 sp = ro + rd*t;\n    vec3 sn = getNormal(sp, edge, crv);\n    vec3 ld = lp - sp;\n    \n    \n    \n    // Coloring and texturing the surface.\n    //\n    // Height map.\n    float c = heightMap(sp.xy); \n    \n    // Folding, or wrapping, the values above to produce the snake-like pattern that lines up with the randomly\n    // flipped hex cells produced by the height map.\n    vec3 fold = cos(vec3(1, 2, 4)*c*6.2831589);\n    \n    // Using the height map value, then wrapping it, to produce a finer grain Truchet pattern for the overlay.\n    float c2 = heightMap((sp.xy + sp.z*.025)*6.);\n    c2 = cos(c2*6.2831589*3.);\n    c2 = (clamp(c2 +.5, 0., 1.)); \n\n    \n    // Function based bump mapping. I prefer none in this example, but it's there if you want it.   \n    //if(temp.x>0. || temp.y>0.) sn = dbF(sp, sn, .001);\n    \n    // Surface color value.\n    vec3 oC = vec3(1);\n\n\tif(fold.x>0.) oC = vec3(1, .05, .1)*c2; // Reddish pink with finer grained Truchet overlay.\n    \n    if(fold.x<0.05 && (fold.y)<0.) oC = vec3(1, .7, .45)*(c2*.25 + .75); // Lighter lined borders.\n    else if(fold.x<0.) oC = vec3(1, .8, .4)*c2; // Gold, with overlay.\n        \n    //oC *= n3D(sp*128.)*.35 + .65; // Extra fine grained noisy texturing.\n\n     \n    // Sending some greenish particle pulses through the snake-like patterns. With all the shininess going \n    // on, this effect is a little on the subtle side.\n    float p1 = 1.0 - smoothstep(0., .1, fold.x*.5+.5); // Restrict to the snake-like path.\n    // Other path.\n\t//float p2 = 1.0 - smoothstep(0., .1, cos(heightMap(sp.xy + 1. + iTime/4.)*6.283)*.5+.5);\n\tfloat p2 = 1.0 - smoothstep(0., .1, Voronoi(sp.xy*4. + vec2(tm, cos(tm/4.))));\n    p1 = (p2 + .25)*p1; // Overlap the paths.\n    oC += oC.yxz*p1*p1; // Gives a kind of electron effect. Works better with just Voronoi, but it'll do.\n    \n   \n    \n    \n    float lDist = max(length(ld), 0.001); // Light distance.\n    float atten = 1./(1. + lDist*.125); // Light attenuation.\n    \n    ld /= lDist; // Normalizing the light direction vector.\n    \n    float diff = max(dot(ld, sn), 0.); // Diffuse.\n    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 16.); // Specular.\n    float fre = pow(clamp(dot(sn, rd) + 1., .0, 1.), 3.); // Fresnel, for some mild glow.\n    \n    // Shading. Note, there are no actual shadows. The camera is front on, so the following\n    // two functions are enough to give a shadowy appearance.\n    crv = crv*.9 + .1; // Curvature value, to darken the crevices.\n    float ao = calculateAO(sp, sn); // Ambient occlusion, for self shadowing.\n\n \n    \n    // Combining the terms above to light the texel.\n    vec3 col = oC*(diff + .5) + vec3(1., .7, .4)*spec*2. + vec3(.4, .7, 1)*fre;\n    \n    col += (oC*.5+.5)*envMap(reflect(rd, sn), sn)*6.; // Fake environment mapping.\n \n    \n    // Edges.\n    col *= 1. - edge*.85; // Darker edges.   \n    \n    // Applying the shades.\n    col *= (atten*crv*ao);\n\n\n    // Rough gamma correction, then present to the screen.\n\tfragColor = vec4(sqrt(clamp(col, 0., 1.)), 1.);\n}",
    "tags": [
      "raymarch",
      "map",
      "hexagon",
      "truchet",
      "edge",
      "environment"
    ],
    "author": "Shane",
    "views": 0,
    "likes": 352,
    "published": 3
  },
  {
    "id": "tdKGW1",
    "title": "Shadertober 03 - Bait",
    "description": "I'm hooked",
    "code": "#define AA 2\n\n//gotta love iq and his wonderful website of knowledge\nfloat sub(float d1, float d2){return max(-d1,d2);}\n\nfloat smin(float d1, float d2, float k)\n{\n    float h = clamp(0.5+0.5*(d2-d1)/k,0.0,1.0);\n    return mix(d2,d1,h)-k*h*(1.0-h);\n}\n\nfloat elipsoid(vec3 pos, vec3 rad)\n{\n    float k0=length(pos/rad);\n    float k1 = length(pos/rad/rad);\n    \n    return k0*(k0-1.0)/k1;\n}\n\nfloat capsule(vec3 p, float h, float r)\n{\n    p.y-=clamp(p.y,0.0,h);\n    return length(p)-r;\n}\n\n\nvec2 map(vec3 pos)   \n{\n    float mat = -1.;\n    vec3 wormPos = pos+vec3(0.,1.5+sin(iTime/2.)*.2,0.);\n    vec3 hookPos = wormPos-vec3(-0.3,.55,0);\n    float w = elipsoid(wormPos+vec3(wormPos.z*.3,abs(wormPos.z)*.1,0.)*sin(iTime-wormPos.z),vec3(.3,.3+fract(wormPos.z*5.)/20.,4.25));\n    float hb = elipsoid(hookPos+vec3(-0.3,-.4,0.),vec3(.7,.8,10.));\n    float ht = elipsoid(hookPos+vec3(-.3,-.15,0.),vec3(.8,0.9,0.1));\n    float base = sub(hb,ht);\n    float top = capsule(hookPos+vec3(.35,.0,0.),3.,.1+.05*hookPos.y/2.);\n    float hook = smin(base,top,.2);\n    \n    float line = capsule(hookPos+vec3(0.35,-3.0,0.),10.,.02);\n    \n    vec3 mp = mod(pos+vec3(-5.,-iTime,0.),vec3(30.,4,30.))-.5;\n    \n    float bubble = min(length(pos+vec3(-3,-30.+mod(-iTime*5.,220.),0))-.25,\n                    length(pos+vec3(0,-90.+mod(-iTime*3.,130.),8))-.15);\n    bubble=min(bubble,length(pos+vec3(5.,-90.+mod(-iTime*4.,180.),-8))-.2);\n    float d = min(min(w,hook),line);\n    d=min(d,bubble);\n    \n    if(d==w)mat=1.;\n    else if(d==hook)mat=2.;\n    else if(d==line)mat=3.;\n    else if(d==bubble)mat=4.;\n    \n    return vec2(d,mat);\n}\n\nvec3 normal(vec3 p)\n{\n    float eps = 0.005;\n    return normalize(vec3(\n        map(vec3(p.x+eps,p.y,p.z)).x-map(vec3(p.x-eps,p.y,p.z)).x,\n        map(vec3(p.x,p.y+eps,p.z)).x-map(vec3(p.x,p.y-eps,p.z)).x,\n        map(vec3(p.x,p.y,p.z+eps)).x-map(vec3(p.x,p.y,p.z-eps)).x\n    ));\n}\n\nfloat castShadow(in vec3 ro, in vec3 rd)\n{\n    float res = 1.0;\n    float t = 0.0001;\n    for(int i=0;i<128;i++)\n    {\n        \n        vec3 pos = ro+t*rd;\n        vec2 h = map(pos);\n        \n        res= min(res, 18.0*h.x/t);\n        if(h.x<0.0001)break;\n        t+=h.x;\n        if(t>20.0)break;\n        \n    }\n    \n    return clamp(res,0.,1.);\n}\n\nvec2 ray(vec3 ro, vec3 rd)\n{\n    \n    float t = 0.0;\n    float m =0.0;\n    int bounces = 128;\n    float max_dist = 30.0;\n    for(int i=0;i<bounces;i++)\n    {\n        vec3 pos = ro+t*rd;\n        vec2 h = map(pos);\n        m=h.y;\n        if(h.x<0.0001)\n        {\n            break;\n        }\n        t+=h.x/2.;\n        if(t>max_dist)break;\n    }\n    \n    if(t>max_dist)t=-1.;\n    \n    return vec2(t,m);\n    \n}\n\nvec3 color(vec3 p, vec3 n, vec2 r)\n{\n    vec3 col = vec3(0.);\n    vec3 mate=vec3(0.);\n    if(r.y<1.5)mate=vec3(0.7,.1,.3)*.6;\n    else if(r.y<2.5)\n    {\n        mate=vec3(1.,1.,2.);\n    }\n    else if(r.y<3.5)mate=vec3(.1);\n    else if(r.y<4.5)mate=vec3(0.3,0.3,4.5);\n    vec3 sun_dir = normalize(vec3(.5,2.,0.2));\n    float sun_dif = clamp(dot(n,sun_dir),0.0,1.0);\n    float sun_sha = castShadow(p+n*0.001,sun_dir);\n    float sky_dif = clamp(0.5+0.5*dot(n,vec3(0.,1.,0.)),0.,1.);\n    \n    col=mate*vec3(1.0,3.0,2.0)*sun_dif*sun_sha;\n    col+=mate*vec3(0.1,0.1,0.3)*sky_dif;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float d = 0.0;\n    vec3 tot=vec3(0.0);\n    for(int ii=0;ii<AA;ii++)\n    {\n        for(int jj=0;jj<AA;jj++)\n        {\n            vec2 offset = vec2(float(ii),float(jj))/float(AA);\n            \n            vec2 uv = (2.*(fragCoord+offset)-iResolution.xy)/iResolution.y;\n            \n            float time = iTime/10.;\n            vec3 ro = vec3(sin(time)*-10.,1.,cos(time)*-9.);\n            vec3 ta = vec3(0.,-.5,0.);\n\n            vec3 ww = normalize(ta-ro);\n\n            vec3 uu = normalize(cross(ww,vec3(0,1,0)));\n            vec3 vv = normalize(cross(uu,ww));\n\n            vec3 rd = normalize(uv.x*uu+uv.y*vv+2.*ww);\n\n            vec2 r = ray(ro,rd);\n            d=r.x;\n\n            vec3 p = ro+rd*r.x;\n\n            vec3 n =normal(p);\n\n            vec3 col = vec3(0.0,0,1.6-p.y)*(.8+sin(sin(p.x)+cos(p.y*20.+iTime-uv.x*5.))*vec3(.1));\n\n            if(r.x>0.0)\n            {\n                col=color(p,n,r);\n\n                if(r.y==2.||r.y==4.)\n                {\n                    rd = reflect(rd,n);\n                    ro=p+n*.001;\n                    r = ray(ro,rd);\n                    p=ro+r.x*rd;\n                    vec3 c = color(p,normal(p),r);\n                    if(r.x>0.)col+=c;\n                    else col+=c/4.;\n                }\n\n            }\n\n\t\t    col=pow(col,vec3(.454545));\n            tot+=col;\n        }\n    }\n\n    tot/=float(AA*AA);\n    fragColor = vec4(tot,normalize(d));\n}",
    "tags": [
      "raymarching",
      "worm",
      "inktober",
      "shadertober",
      "bait",
      "backwardscaptain",
      "cineshader"
    ],
    "author": "BackwardsCap",
    "views": 0,
    "likes": 12,
    "published": 3
  },
  {
    "id": "Xdj3DV",
    "title": "Quad Sphere",
    "description": "I love sphere. :-)",
    "code": "#define ITEMAX 75\n\nfloat QuadSphere(vec3 p, vec3 pos, vec3 size, float radius) {\n\treturn length(max(abs(p - pos), 0.0) - size) - radius;\n}\n\nvec2 rot(vec2 p, float r) {\n\tfloat c = cos(r), s = sin(r);\n\treturn vec2(p.x * c - p.y * s, p.x * s + p.y * c);\n}\n\nfloat map(vec3 p) {\n\tfloat t = 1000.;\n\tvec3 pos   = vec3(0.0, 0.0, 0.0);\n\tfloat gt = iTime;\n\tvec3 scale = vec3(0.2 + sin(gt) * 0.1, 0.1, 0.1);\n\tfor(int i = 0 ; i < 3; i++) {\n\t\tvec3 r = mod(p, 1.0) - 0.5;\n\t\tr.xy = rot(r.xy, gt * 0.7);\n\t\tr.yz = rot(r.yz, gt);\n\t\tt = min(t, QuadSphere(r, pos, scale, 0.05));\n\t\tpos   = pos.yzx;\n\t\tscale = scale.yzx;\n\t}\n\treturn t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tfloat gt = iTime;\n\tfloat d  = 0.0, dt = 0.0, ite = 0.0;\n\tvec2 uv  = -1.0 + 2.0 * ( fragCoord.xy / iResolution.xy );\n\tvec3 dir = normalize(vec3(uv * vec2(iResolution.x/iResolution.y, 1.0), 1.0));\n\tvec3 pos = vec3(0,gt,gt).zxy * 0.2;\n\tdir.xy   = rot(dir.xy, gt * 0.1);\n\tdir.yz   = rot(dir.yz, gt * 0.1);\n\n\tfor(int i = 0 ; i < ITEMAX; i++) {\n\t\tdt = map(pos + dir * d);\n\t\tif(dt < .001) break;\n\t\td += dt;\n\t\tite++;\n\t}\n\n\tvec3 col = vec3(d * 0.05);\n\tif(dt < 0.001) {\n\t\tfloat  www = pow(1.0 - (ite / float(ITEMAX)), 10.0);\n\t\tcol += www * (vec3(0,1,3).xyz * 0.5);\n\t}\n\tfragColor = vec4(sqrt(col) + dir * 0.03, 1.0 / (d * d) /* 1.0 / ite */);\n}\n",
    "tags": [
      "raymarching",
      "cineshader"
    ],
    "author": "gyabo",
    "views": 0,
    "likes": 18,
    "published": 3
  },
  {
    "id": "MdfGWn",
    "title": "Ellipse - Distance Estimation",
    "description": "If a circle is deformed into an ellipse distances are nor preserved, and hence its thickness is not constant (left). A (first order) distance estimation can be done by diving the implicit by the modulo of its gradient, producing constant thickness (right)",
    "code": "// The MIT License\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org/\n// Copyright \u00a9 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// An example on how to compute a distance estimation to an implicit by dividing\n// the implicit by the length of its gradient. The same process can be applied to any\n// shape defined by an implicity formula. In this shader, the formula is an ellipse\n//\n// More information here: https://iquilezles.org/articles/distance/\n//\n// Top    left : f(x,y)\n// Top    right: f(x,y) divided by analytical gradient\n// Bottom left : f(x,y) divided by numerical GPU gradient\n// Bottom right: f(x,y) divided by numerical gradient\n\n\nconst float a = 1.0;\nconst float b = 3.0;\n\nfloat r, e;\n\n// f(x,y) (top left)\nfloat ellipse1(vec2 p)\n{\n    float f = length( p*vec2(a,b) );\n    return abs(f-r);\n}\n\n// f(x,y) divided by analytical gradient (top right)\nfloat ellipse2(vec2 p)\n{\n    float f = length( p*vec2(a,b) );\n    float g = length( p*vec2(a*a,b*b) );\n    return abs(f-r)*f/g;\n}\n\n// f(x,y) divided by numerical GPU gradient (bottom left)\nfloat ellipse3(vec2 p)\n{\n    float f = ellipse1(p);\n    float g = length( vec2(dFdx(f),dFdy(f))/e );\n    //float g = fwidth(f)/e;\n\treturn f/g;\n}\n\n// f(x,y) divided by numerical gradient (bottom right)\nfloat ellipse4(vec2 p)\n{\n    float f = ellipse1(p);\n    float g = length( vec2(ellipse1(p+vec2(e,0.0))-ellipse1(p-vec2(e,0.0)),\n                           ellipse1(p+vec2(0.0,e))-ellipse1(p-vec2(0.0,e))) )/(2.0*e);\n    return f/g;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    r = 0.9 + 0.1*sin(3.1415927*iTime);\n    e = 2.0/iResolution.y;\n    \n\tvec2 uv = (2.0*fragCoord-iResolution.xy) / iResolution.y;\n    \n\tfloat f1 = ellipse1(uv);\n\tfloat f2 = ellipse2(uv);\n\tfloat f3 = ellipse3(uv);\n\tfloat f4 = ellipse4(uv);\n\t\n\tvec3 col = vec3(0.3);\n\n    // ellipse     \n    float f = mix( mix(f1,f2,step(0.0,uv.x)), \n                   mix(f3,f4,step(0.0,uv.x)), \n                   step(uv.y,0.0) );\n    \n\tcol = mix( col, vec3(1.0,0.6,0.2), 1.0-smoothstep( 0.1, 0.11, f ) );\n    \n    // lines    \n\tcol *= smoothstep( e, 2.0*e, abs(uv.x) );\n\tcol *= smoothstep( e, 2.0*e, abs(uv.y) );\n\t\n\tfragColor = vec4( col, 1.0 );\n}",
    "tags": [
      "2d",
      "distanceestimation",
      "ellipse"
    ],
    "author": "iq",
    "views": 0,
    "likes": 72,
    "published": 3
  },
  {
    "id": "MsfGzM",
    "title": "Two Tweets (244 chars)",
    "description": "Inspired by Nautilus. An experiment on how far I could go in just 280 characters, the size of 2 tweets.\n\nMore info: [url]http://iquilezles.org/articles/derivative/derivative.htm[/url]",
    "code": "// Copyright Inigo Quilez, 2013 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work neither\n// as it is or altered, here on Shadertoy or anywhere else, in any\n// form including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it or train a neural\n// network with it without permission. I share this Work for educational\n// purposes, and you can link to it, through an URL, proper attribution\n// and unmodified screenshot, as part of your educational material. If\n// these conditions are too restrictive please contact me and we'll\n// definitely work it out.\n\n\n//---------------------\n// 255 chars\n//---------------------\n\n#define f (length(cos(o)+.05*cos(9.*o.y*o.x)-.1*cos(9.*(.3*o.x-o.y+o.z)))-1.)\n\nvoid mainImage( out vec4 c, in vec2 p )\n{\n    vec3 d = .5-vec3(p,1)/iResolution.x, o = d;\n        \n    //for( p.y=0.,o.z=iTime; p.y++<2e2; o+=f*d );\n    for( p.y=2e2,o.z=iTime; p.y-->0.; o+=f*d );\n    \n    o -= d;    p.x = f;\n    o += d-.6; p.y = f;\n    \n    c = (p.yxxx+p.yyxx)*exp(.2*(iTime-o.z));\n}\n\n\n/*\n//---------------------\n// 244 chars (can't publish, infinite loop at some resolutions)\n//---------------------\n\n#define f (length(cos(o)+.05*cos(9.*o.y*o.x)-.1*cos(9.*(.3*o.x-o.y+o.z)))-1.)\n\nvoid mainImage( out vec4 c, in vec2 p )\n{\n    vec3 d = .5-vec3(p,1)/iResolution.x, o = d;\n    \n    for( o.z=iTime; f>.01; o+=f*d );\n    \n    o -= d;    p.x = f;\n    o += d-.6; p.y = f;\n    \n    c = (p.yxxx+p.yyxx)*exp(.2*(iTime-o.z));\n}\n*/\n\n/*\n//---------------------\n// 261 chars (-3 by Fabryce)\n//---------------------\n\nfloat f( vec3 p )\n{ \n\tp.z += iTime;\n    return length(      cos(p)\n                  + .05*cos(9.*p.y*p.x)\n                  - .1 *cos(9.*(.3*p.x-p.y+p.z))\n                  ) - 1.; \n}\n\nvoid mainImage( out vec4 c, in vec2 p )\n{\n    vec3 d = .5-vec3(p,1)/iResolution.x, o = d;\n    \n    for( c=vec4(0,1,2,0); c.w++<2e2; o+=f(o)*d );\n    \n    c = abs( f(o-d)*c + f(o-.6)*c.zyxw )*(1.-.1*o.z);\n}\n/*\n//---------------------\n// 265 chars\n//---------------------\n\nfloat f( vec3 p )\n{ \n\tp.z += iTime;\n    return length(      cos(p)\n                  + .05*cos(9.*p.y*p.x)\n                  - .1 *cos(9.*(.3*p.x-p.y+p.z))\n                  ) - 1.; \n}\n\nvoid mainImage( out vec4 c, in vec2 p )\n{\n    vec3 d = .5-vec3(p,1)/iResolution.x, o = d;\n    \n    for( c=vec4(0,1,2,0); c.w<256.; c.w++ ) o += f(o)*d;\n    \n    c = abs( f(o-d)*c + f(o-.6)*c.zyxw )*(1.-.1*o.z);\n}\n*/\n\n\n/* \n//---------------------\n// 268 chars\n//---------------------\n\nfloat f( vec3 p )\n{ \n\tp.z += iTime;\n    return length(      cos(p)\n                  + .05*cos(9.*p.y*p.x)\n                  - .1 *cos(9.*(.3*p.x-p.y+p.z))\n                  ) - 1.; \n}\n\nvoid mainImage( out vec4 c, in vec2 p )\n{\n    vec3 d = .5-vec3(p,1)/iResolution.x, o = d;\n    \n    for( int i=0; i<256; i++ )\n        o += f(o)*d;\n        \n    c = vec4(0,1,2,3);\n    c = abs( f(o-d)*c + f(o-.6)*c.zyxw )*(1.-.1*o.z);\n}\n\n*/",
    "tags": [
      "3d",
      "raymarching",
      "distancefield",
      "tweet",
      "sizecoding",
      "size"
    ],
    "author": "iq",
    "views": 0,
    "likes": 116,
    "published": 3
  },
  {
    "id": "XsfGRn",
    "title": "Heart - 2D",
    "description": "The shader version of love!",
    "code": "// Created by inigo quilez - iq/2013\n//   https://www.youtube.com/c/InigoQuilez\n//   https://iquilezles.org/\n// I share this piece (art and code) here in Shadertoy and through its Public API, only for educational purposes. \n// You cannot use, sell, share or host this piece or modifications of it as part of your own commercial or non-commercial product, website or project.\n// You can share a link to it or an unmodified screenshot of it provided you attribute \"by Inigo Quilez, @iquilezles and iquilezles.org\". \n// If you are a teacher, lecturer, educator or similar and these conditions are too restrictive for your needs, please contact me and we'll work it out.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/min(iResolution.y,iResolution.x);\n\t\n    // background color\n    vec3 bcol = vec3(1.0,0.8,0.7-0.07*p.y)*(1.0-0.25*length(p));\n\n    // animate\n    float tt = mod(iTime,1.5)/1.5;\n    float ss = pow(tt,.2)*0.5 + 0.5;\n    ss = 1.0 + ss*0.5*sin(tt*6.2831*3.0 + p.y*0.5)*exp(-tt*4.0);\n    p *= vec2(0.5,1.5) + ss*vec2(0.5,-0.5);\n\n    // shape\n\tp.y -= 0.25;\n    float a = atan(p.x,p.y)/3.141593;\n    float r = length(p);\n    float h = abs(a);\n    float d = (13.0*h - 22.0*h*h + 10.0*h*h*h)/(6.0-5.0*h);\n    \n\t// color\n\tfloat s = 0.75 + 0.75*p.x;\n\ts *= 1.0-0.4*r;\n\ts = 0.3 + 0.7*s;\n\ts *= 0.5+0.5*pow( 1.0-clamp(r/d, 0.0, 1.0 ), 0.1 );\n\tvec3 hcol = vec3(1.0,0.4*r,0.3)*s;\n\t\n    vec3 col = mix( bcol, hcol, smoothstep( -0.01, 0.01, d-r) );\n\n    fragColor = vec4(col,1.0);\n}",
    "tags": [
      "procedural",
      "2d"
    ],
    "author": "iq",
    "views": 0,
    "likes": 244,
    "published": 3
  },
  {
    "id": "4t3SzN",
    "title": "Iterations - inversion 2",
    "description": "A set of 48 spiral inversions at random positions performed to the input point.",
    "code": "// Copyright Inigo Quilez, 2016 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work in any form,\n// including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it.\n// I share this Work for educational purposes, and you can link to it,\n// through an URL, proper attribution and unmodified screenshot, as part\n// of your educational material. If these conditions are too restrictive\n// please contact me and we'll definitely work it out.\n\n// based on https://www.shadertoy.com/view/XdXGDS\n\n#define AA 2\n\n// Other \"Iterations\" shaders:\n//\n// \"trigonometric\"   : https://www.shadertoy.com/view/Mdl3RH\n// \"trigonometric 2\" : https://www.shadertoy.com/view/Wss3zB\n// \"circles\"         : https://www.shadertoy.com/view/MdVGWR\n// \"coral\"           : https://www.shadertoy.com/view/4sXGDN\n// \"guts\"            : https://www.shadertoy.com/view/MssGW4\n// \"inversion\"       : https://www.shadertoy.com/view/XdXGDS\n// \"inversion 2\"     : https://www.shadertoy.com/view/4t3SzN\n// \"shiny\"           : https://www.shadertoy.com/view/MslXz8\n// \"worms\"           : https://www.shadertoy.com/view/ldl3W4\n// \"stripes\"         : https://www.shadertoy.com/view/wlsfRn\n\n\nvec3 shape( in vec2 uv )\n{\n\tfloat time = iTime*0.05  + 47.0;\n    \n\tvec2 z = -1.0 + 2.0*uv;\n\tz *= 1.5;\n    \n    vec3 col = vec3(1.0);\n\tfor( int j=0; j<48; j++ )\n\t{\n        float s = float(j)/16.0;\n        float f = 0.2*(0.5 + 1.0*fract(sin(s*20.0)));\n\n\t\tvec2 c = 0.5*vec2( cos(f*time+17.0*s),sin(f*time+19.0*s) );\n\t\tz -= c;\n\t\tfloat zr = length( z );\n\t    float ar = atan( z.y, z.x ) + zr*0.6;\n\t    z  = vec2( cos(ar), sin(ar) )/zr;\n\t\tz += c;\n\n        // color\t\t\n        col -= 0.5*exp( -10.0*dot(z,z) )* (0.25+0.4*sin( 5.5 + 1.5*s + vec3(1.6,0.8,0.5) ));\n\t}\n        \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float e = 1.0/iResolution.x;\n\n    vec3 tot = vec3(0.0);\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {        \n        vec2 uv = (fragCoord+vec2(m,n)/float(AA))/iResolution.xy;\n\t    vec3 col = shape( uv );\n        float f = dot(col,vec3(0.333));\n        vec3 nor = normalize( vec3( dot(shape(uv+vec2(e,0.0)),vec3(0.333))-f, \n                                    dot(shape(uv+vec2(0.0,e)),vec3(0.333))-f, \n                                    e ) );\n        col += 0.2*vec3(1.0,0.9,0.5)*dot(nor,vec3(0.8,0.4,0.2));;\n\t    col += 0.3*nor.z;\n        tot += col;\n    }\n    tot /= float(AA*AA);\n\n    tot = pow( clamp(tot,0.0,1.0), vec3(0.8,1.1,1.3) );\n\t\n    vec2 uv = fragCoord/iResolution.xy;\n    tot *= 0.4 + 0.6*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.1 );\n\n    fragColor = vec4( tot, 1.0 );\n}",
    "tags": [
      "procedural",
      "2d",
      "inversion",
      "iteration"
    ],
    "author": "iq",
    "views": 0,
    "likes": 147,
    "published": 3
  },
  {
    "id": "MdXSzS",
    "title": "Galaxy of Universes",
    "description": "Big Bang? *pfft* It's just a small explosion somewhere in a rotating Galaxy of Universes!\nThanks to Kali for his fractal formula.",
    "code": "// https://www.shadertoy.com/view/MdXSzS\n// The Big Bang - just a small explosion somewhere in a massive Galaxy of Universes.\n// Outside of this there's a massive galaxy of 'Galaxy of Universes'... etc etc. :D\n\n// To fake a perspective it takes advantage of the screen being wider than it is tall.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy) - .5;\n\tfloat t = iTime * .1 + ((.25 + .05 * sin(iTime * .1))/(length(uv.xy) + .07)) * 2.2;\n\tfloat si = sin(t);\n\tfloat co = cos(t);\n\tmat2 ma = mat2(co, si, -si, co);\n\n\tfloat v1, v2, v3;\n\tv1 = v2 = v3 = 0.0;\n\t\n\tfloat s = 0.0;\n\tfor (int i = 0; i < 90; i++)\n\t{\n\t\tvec3 p = s * vec3(uv, 0.0);\n\t\tp.xy *= ma;\n\t\tp += vec3(.22, .3, s - 1.5 - sin(iTime * .13) * .1);\n\t\tfor (int i = 0; i < 8; i++)\tp = abs(p) / dot(p,p) - 0.659;\n\t\tv1 += dot(p,p) * .0015 * (1.8 + sin(length(uv.xy * 13.0) + .5  - iTime * .2));\n\t\tv2 += dot(p,p) * .0013 * (1.5 + sin(length(uv.xy * 14.5) + 1.2 - iTime * .3));\n\t\tv3 += length(p.xy*10.) * .0003;\n\t\ts  += .035;\n\t}\n\t\n\tfloat len = length(uv);\n\tv1 *= smoothstep(.7, .0, len);\n\tv2 *= smoothstep(.5, .0, len);\n\tv3 *= smoothstep(.9, .0, len);\n\t\n\tvec3 col = vec3( v3 * (1.5 + sin(iTime * .2) * .4),\n\t\t\t\t\t(v1 + v3) * .3,\n\t\t\t\t\t v2) + smoothstep(0.2, .0, len) * .85 + smoothstep(.0, .6, v3) * .3;\n\n\tfragColor=vec4(min(pow(abs(col), vec3(1.2)), 1.0), 1.0);\n}",
    "tags": [
      "galaxy",
      "universes"
    ],
    "author": "Dave_Hoskins",
    "views": 0,
    "likes": 354,
    "published": 3
  },
  {
    "id": "WsjBRW",
    "title": "Turbulence noise test",
    "description": "Turbulence noise test for cineshader",
    "code": "\n//\tSimplex 3D Noise \n//\tby Ian McEwan, Ashima Arts\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat snoise(vec3 v){ \n    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n    vec3 i  = floor(v + dot(v, C.yyy) );\n    vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n\n    //  x0 = x0 - 0. + 0.0 * C \n    vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n    vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n    vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n// Permutations\n    i = mod(i, 289.0 ); \n    vec4 p = permute( permute( permute( \n                         i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n                     + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n                     + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients\n// ( N*N points uniformly over a square, mapped onto an octahedron.)\n    float n_ = 1.0/7.0; // N=7\n    vec3  ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n// Mix final noise value\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nfloat fbm( vec3 p ) {\n        float f = 0.0;\n        f += 0.5000*snoise( p ); p = p*2.02;\n        f += 0.2500*snoise( p ); p = p*2.03;\n        f += 0.1250*snoise( p ); p = p*2.01;\n        f += 0.0625*snoise( p );\n        return f/0.9375;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    float mouseRatio = smoothstep(100.0, 0.0, length(iMouse.xy - fragCoord.xy));\n    float noise = 0.25 + fbm(vec3(uv * 12.0 + (iMouse.xy - fragCoord.xy) * mouseRatio * 0.05, iTime * 0.18 + 0.5 * mouseRatio));\n    noise *= 0.25 + snoise(vec3(uv * 4.0 + 1.5, iTime * 0.15));\n    //fragColor = vec4(1.0, 1.0, 1.0, noise);\n    \n    for(float i = 1.0; i < 8.0; i++){\n    uv.y += i * 0.1 / i * \n      sin(uv.x * i * i + iTime * 0.5) * sin(uv.y * i * i + iTime * 0.5);\n  \t}\n    \n   vec3 col;\n   col.r = uv.y + noise - 0.1;\n   col.g = uv.y + noise + 0.3;\n   col.b = uv.y + noise + 0.95;\n    \n    fragColor = vec4(col,noise);\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"Turbulence noise\",\n\t\"description\": \"probando shadertoy a cineshader\",\n\t\"model\": \"person\"\n}\n*/",
    "tags": [
      "test",
      "cineshader"
    ],
    "author": "exandro",
    "views": 0,
    "likes": 31,
    "published": 3
  },
  {
    "id": "ldSSzV",
    "title": "Wet stone",
    "description": "stone generation",
    "code": "/*\n\"Wet stone\" by Alexander Alekseev aka TDM - 2014\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tdmaav@gmail.com\n*/\n\n#define SMOOTH\n//#define AA\n\nconst int NUM_STEPS = 32;\nconst int AO_SAMPLES = 4;\nconst vec2 AO_PARAM = vec2(1.2, 3.5);\nconst vec2 CORNER_PARAM = vec2(0.25, 40.0);\nconst float INV_AO_SAMPLES = 1.0 / float(AO_SAMPLES);\nconst float TRESHOLD \t= 0.1;\nconst float EPSILON \t= 1e-3;\nconst float LIGHT_INTENSITY = 0.25;\nconst vec3 RED \t\t= vec3(1.0,0.7,0.7) * LIGHT_INTENSITY;\nconst vec3 ORANGE \t= vec3(1.0,0.67,0.43) * LIGHT_INTENSITY;\nconst vec3 BLUE \t= vec3(0.54,0.77,1.0) * LIGHT_INTENSITY;\nconst vec3 WHITE \t= vec3(1.2,1.07,0.98) * LIGHT_INTENSITY;\n\nconst float DISPLACEMENT = 0.1;\n\n// math\nmat3 fromEuler(vec3 ang) {\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    mat3 m;\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\n\tm[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\n\tm[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\n\treturn m;\n}\nvec3 saturation(vec3 c, float t) {\n    return mix(vec3(dot(c,vec3(0.2126,0.7152,0.0722))),c,t);\n}\nfloat hash11(float p) {\n    return fract(sin(p * 727.1)*435.545);\n}\nfloat hash12(vec2 p) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*437.545);\n}\nvec3 hash31(float p) {\n\tvec3 h = vec3(127.231,491.7,718.423) * p;\t\n    return fract(sin(h)*435.543);\n}\n\n// 3d noise\nfloat noise_3(in vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\t\n\tvec3 u = f*f*(3.0-2.0*f);\n    \n    vec2 ii = i.xy + i.z * vec2(5.0);\n    float a = hash12( ii + vec2(0.0,0.0) );\n\tfloat b = hash12( ii + vec2(1.0,0.0) );    \n    float c = hash12( ii + vec2(0.0,1.0) );\n\tfloat d = hash12( ii + vec2(1.0,1.0) ); \n    float v1 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n    \n    ii += vec2(5.0);\n    a = hash12( ii + vec2(0.0,0.0) );\n\tb = hash12( ii + vec2(1.0,0.0) );    \n    c = hash12( ii + vec2(0.0,1.0) );\n\td = hash12( ii + vec2(1.0,1.0) );\n    float v2 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n        \n    return max(mix(v1,v2,u.z),0.0);\n}\n\n// fBm\nfloat fbm3(vec3 p, float a, float f) {\n    return noise_3(p);\n}\n\nfloat fbm3_high(vec3 p, float a, float f) {\n    float ret = 0.0;    \n    float amp = 1.0;\n    float frq = 1.0;\n    for(int i = 0; i < 5; i++) {\n        float n = pow(noise_3(p * frq),2.0);\n        ret += n * amp;\n        frq *= f;\n        amp *= a * (pow(n,0.2));\n    }\n    return ret;\n}\n\n// lighting\nfloat diffuse(vec3 n,vec3 l,float p) { return pow(max(dot(n,l),0.0),p); }\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \n    float nrm = (s + 8.0) / (3.1415 * 8.0);\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\n}\n\n// distance functions\nfloat plane(vec3 gp, vec4 p) {\n\treturn dot(p.xyz,gp+p.xyz*p.w);\n}\nfloat sphere(vec3 p,float r) {\n\treturn length(p)-r;\n}\nfloat capsule(vec3 p,float r,float h) {\n    p.y -= clamp(p.y,-h,h);\n\treturn length(p)-r;\n}\nfloat cylinder(vec3 p,float r,float h) {\n\treturn max(abs(p.y/h),capsule(p,r,h));\n}\nfloat box(vec3 p,vec3 s) {\n\tp = abs(p)-s;\n    return max(max(p.x,p.y),p.z);\n}\nfloat rbox(vec3 p,vec3 s) {\n\tp = abs(p)-s;\n    return length(p-min(p,0.0));\n}\nfloat quad(vec3 p,vec2 s) {\n\tp = abs(p) - vec3(s.x,0.0,s.y);\n    return max(max(p.x,p.y),p.z);\n}\n\n// boolean operations\nfloat boolUnion(float a,float b) { return min(a,b); }\nfloat boolIntersect(float a,float b) { return max(a,b); }\nfloat boolSub(float a,float b) { return max(a,-b); }\n\n// smooth operations. thanks to iq\nfloat boolSmoothIntersect(float a, float b, float k ) {\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n    return mix(a,b,h) + k*h*(1.0-h);\n}\nfloat boolSmoothSub(float a, float b, float k ) {\n    return boolSmoothIntersect(a,-b,k);\n}\t\n\n// world\nfloat rock(vec3 p) {    \n    float d = sphere(p,1.0);    \n    for(int i = 0; i < 9; i++) {\n        float ii = float(i);\n        float r = 2.5 + hash11(ii);\n        vec3 v = normalize(hash31(ii) * 2.0 - 1.0);\n        #ifdef SMOOTH\n        d = boolSmoothSub(d,sphere(p+v*r,r * 0.8), 0.03);\n        #else\n    \td = boolSub(d,sphere(p+v*r,r * 0.8));\n        #endif        \n    }\n    return d;\n}\n\nfloat map(vec3 p) {\n    float d = rock(p) + fbm3(p*4.0,0.4,2.96) * DISPLACEMENT;\n    d = boolUnion(d,plane(p,vec4(0.0,1.0,0.0,1.0)));\n    return d;\n}\n\nfloat map_detailed(vec3 p) {\n    float d = rock(p) + fbm3_high(p*4.0,0.4,2.96) * DISPLACEMENT;\n    d = boolUnion(d,plane(p,vec4(0.0,1.0,0.0,1.0)));\n    return d;\n}\n\n// tracing\nvec3 getNormal(vec3 p, float dens) {\n    vec3 n;\n    n.x = map_detailed(vec3(p.x+EPSILON,p.y,p.z));\n    n.y = map_detailed(vec3(p.x,p.y+EPSILON,p.z));\n    n.z = map_detailed(vec3(p.x,p.y,p.z+EPSILON));\n    return normalize(n-map_detailed(p));\n}\nvec2 getOcclusion(vec3 p, vec3 n) {\n    vec2 r = vec2(0.0);\n    for(int i = 0; i < AO_SAMPLES; i++) {\n        float f = float(i)*INV_AO_SAMPLES;\n        float hao = 0.01+f*AO_PARAM.x;\n        float hc = 0.01+f*CORNER_PARAM.x;\n        float dao = map(p + n * hao) - TRESHOLD;\n        float dc = map(p - n * hc) - TRESHOLD;\n        r.x += clamp(hao-dao,0.0,1.0) * (1.0-f);\n        r.y += clamp(hc+dc,0.0,1.0) * (1.0-f);\n    }    \n    r.x = clamp(1.0-r.x*INV_AO_SAMPLES*AO_PARAM.y,0.0,1.0);\n    r.y = clamp(r.y*INV_AO_SAMPLES*CORNER_PARAM.y,0.0,1.0);\n    return r;\n}\nvec2 spheretracing(vec3 ori, vec3 dir, out vec3 p) {\n    vec2 td = vec2(0.0);\n    for(int i = 0; i < NUM_STEPS; i++) {\n        p = ori + dir * td.x;\n        td.y = map(p);\n        if(td.y < TRESHOLD) break;\n        td.x += (td.y-TRESHOLD) * 0.9;\n    }\n    return td;\n}\n\n// stone\nvec3 getStoneColor(vec3 p, float c, vec3 l, vec3 n, vec3 e) {\n    c = min(c + pow(noise_3(vec3(p.x*20.0,0.0,p.z*20.0)),70.0) * 8.0, 1.0);\n    float ic = pow(1.0-c,0.5);\n    vec3 base = vec3(0.42,0.3,0.2) * 0.35;\n    vec3 sand = vec3(0.51,0.41,0.32)*0.9;\n    vec3 color = mix(base,sand,c);\n        \n    float f = pow(1.0 - max(dot(n,-e),0.0), 5.0) * 0.75 * ic;    \n    color += vec3(diffuse(n,l,0.5) * WHITE);\n    color += vec3(specular(n,l,e,8.0) * WHITE * 1.5 * ic);\n    n = normalize(n - normalize(p) * 0.4);    \n    color += vec3(specular(n,l,e,80.0) * WHITE * 1.5 * ic);    \n    color = mix(color,vec3(1.0),f); \n    \n    color *= sqrt(abs(p.y*0.5+0.5)) * 0.4 + 0.6;\n    color *= (n.y * 0.5 + 0.5) * 0.4 + 0.6; \n    \n    return color;\n}\n\nvec3 getPixel(in vec2 coord, float time) {\n    vec2 iuv = coord / iResolution.xy * 2.0 - 1.0;\n    vec2 uv = iuv;\n    uv.x *= iResolution.x / iResolution.y;\n        \n    // ray\n    vec3 ang = vec3(0.0,0.2,time);\n    if(iMouse.z > 0.0) ang = vec3(0.0,clamp(2.0-iMouse.y*0.01,0.0,3.1415),iMouse.x*0.01);\n\tmat3 rot = fromEuler(ang);\n    \n    vec3 ori = vec3(0.0,0.0,2.8);\n    vec3 dir = normalize(vec3(uv.xy,-2.0));    \n    ori = ori * rot;\n    dir = dir * rot;\n    \n    // tracing\n    vec3 p;\n    vec2 td = spheretracing(ori,dir,p);\n    vec3 n = getNormal(p,td.y);\n    vec2 occ = getOcclusion(p,n);\n    vec3 light = normalize(vec3(0.0,1.0,0.0)); \n         \n    // color\n    vec3 color = vec3(1.0);    \n    if(td.x < 3.5 && p.y > -0.89) color = getStoneColor(p,occ.y,light,n,dir);\n    color *= occ.x;\n    return color;\n}\n\n// main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float time = iTime * 0.3;\n        \n#ifdef AA\n    vec3 color = vec3(0.0);\n    for(int i = -1; i <= 1; i++)\n    for(int j = -1; j <= 1; j++) {\n        vec2 uv = fragCoord+vec2(i,j)/3.0;\n        color += getPixel(uv, time);\n    }\n    color /= 9.0;\n#else\n    vec3 color = getPixel(fragCoord, time);\n#endif\n    color = sqrt(color);\n    color = saturation(color,1.7);\n               \n    // vignette\n    vec2 iuv = fragCoord / iResolution.xy * 2.0 - 1.0;\n    float vgn = smoothstep(1.2,0.7,abs(iuv.y)) * smoothstep(1.1,0.8,abs(iuv.x));\n    color *= 1.0 - (1.0 - vgn) * 0.15;\t\n    \n\tfragColor = vec4(color,1.0);\n}",
    "tags": [
      "procedural",
      "noise",
      "rock",
      "wet",
      "stone"
    ],
    "author": "TDM",
    "views": 0,
    "likes": 506,
    "published": 3
  },
  {
    "id": "XsjGDt",
    "title": "A Simple Circle",
    "description": "A function to draw a simple circle based on coordinates and radius.",
    "code": "/**\n * @author jonobr1 / http://jonobr1.com/\n */\n\n/**\n * Convert r, g, b to normalized vec3\n */\nvec3 rgb(float r, float g, float b) {\n\treturn vec3(r / 255.0, g / 255.0, b / 255.0);\n}\n\n/**\n * Draw a circle at vec2 `pos` with radius `rad` and\n * color `color`.\n */\nvec4 circle(vec2 uv, vec2 pos, float rad, vec3 color) {\n\tfloat d = length(pos - uv) - rad;\n\tfloat t = clamp(d, 0.0, 1.0);\n\treturn vec4(color, 1.0 - t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec2 uv = fragCoord.xy;\n\tvec2 center = iResolution.xy * 0.5;\n\tfloat radius = 0.25 * iResolution.y;\n\n    // Background layer\n\tvec4 layer1 = vec4(rgb(210.0, 222.0, 228.0), 1.0);\n\t\n\t// Circle\n\tvec3 red = rgb(225.0, 95.0, 60.0);\n\tvec4 layer2 = circle(uv, center, radius, red);\n\t\n\t// Blend the two\n\tfragColor = mix(layer1, layer2, layer2.a);\n\n}",
    "tags": [
      "2d",
      "geometry"
    ],
    "author": "jonobr1",
    "views": 0,
    "likes": 135,
    "published": 3
  },
  {
    "id": "3tdSRn",
    "title": "001-DrawCircle",
    "description": "Draw circle",
    "code": "vec3 drawCircle(vec2 pos, float radius, float width, float power, vec4 color)\n{\n    vec2 mousePos = iMouse.xy - vec2(0.5);\n    float dist1 = length(pos);\n    dist1 = fract((dist1 * 5.0) - fract(iTime));\n    float dist2 = dist1 - radius;\n    float intensity = pow(radius / abs(dist2), width); \n    vec3 col = color.rgb * intensity * power * max((0.8- abs(dist2)), 0.0);\n    return col;\n}\n\nvec3 hsv2rgb(float h, float s, float v)\n{\n    vec4 t = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);\n    vec3 p = abs(fract(vec3(h) + t.xyz) * 6.0 - vec3(t.w));\n    return v * mix(vec3(t.x), clamp(p - vec3(t.x), 0.0, 1.0), s);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // // -1.0 ~ 1.0\n    vec2 pos = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    float h = mix(0.5, 0.65, length(pos));\n    vec4 color = vec4(hsv2rgb(h, 1.0, 1.0), 1.0);\n    float radius = 0.5;\n    float width = 0.8;\n    float power = 0.1;\n    vec3 finalColor = drawCircle(pos, radius, width, power, color);\n\n    pos = abs(pos);\n    // vec3 finalColor = vec3(pos.x, 0.0, pos.y);\n\n    fragColor = vec4(finalColor, 1.0);\n}\n\n",
    "tags": [
      "cineshader"
    ],
    "author": "haquxx",
    "views": 0,
    "likes": 91,
    "published": 3
  },
  {
    "id": "4s23zz",
    "title": "Warping - procedural 1",
    "description": "Warp. Tutorial here: [url]https://iquilezles.org/articles/warp[/url].",
    "code": "// Copyright Inigo Quilez, 2013 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work neither\n// as it is or altered, here on Shadertoy or anywhere else, in any\n// form including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it or train a neural\n// network with it without permission. I share this Work for educational\n// purposes, and you can link to it, through an URL, proper attribution\n// and unmodified screenshot, as part of your educational material. If\n// these conditions are too restrictive please contact me and we'll\n// definitely work it out.\n\n// See https://iquilezles.org/articles/warp for details\n\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2\n#endif\n\nfloat hash(vec2 p)  // replace this by something better\n{\n    p  = fract( p*0.6180339887 );\n    p *= 25.0;\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\n// consider replacing this by a proper noise function\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float a = hash(p+vec2(0,0));\n\tfloat b = hash(p+vec2(1,0));\n\tfloat c = hash(p+vec2(0,1));\n\tfloat d = hash(p+vec2(1,1));\n    return mix(mix( a, b,f.x), mix( c, d,f.x),f.y);\n}\n\nconst mat2 mtx = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat fbm4( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*(-1.0+2.0*noise( p )); p = mtx*p*2.02;\n    f += 0.2500*(-1.0+2.0*noise( p )); p = mtx*p*2.03;\n    f += 0.1250*(-1.0+2.0*noise( p )); p = mtx*p*2.01;\n    f += 0.0625*(-1.0+2.0*noise( p ));\n    return f/0.9375;\n}\n\nfloat fbm6( vec2 p )\n{\n    float f = 0.0;\n    f += 0.500000*noise( p ); p = mtx*p*2.02;\n    f += 0.250000*noise( p ); p = mtx*p*2.03;\n    f += 0.125000*noise( p ); p = mtx*p*2.01;\n    f += 0.062500*noise( p ); p = mtx*p*2.04;\n    f += 0.031250*noise( p ); p = mtx*p*2.01;\n    f += 0.015625*noise( p );\n    return f/0.96875;\n}\n\nvec2 fbm4_2( vec2 p )\n{\n    return vec2( fbm4(p+vec2(1.0)), fbm4(p+vec2(6.2)) );\n}\n\nvec2 fbm6_2( vec2 p )\n{\n    return vec2( fbm6(p+vec2(9.2)), fbm6(p+vec2(5.7)) );\n}\n\nfloat func( vec2 q, out vec2 o, out vec2 n )\n{\n    q += 0.05*sin(vec2(0.11,0.13)*iTime + length( q )*4.0);\n    \n    q *= 0.7 + 0.2*cos(0.05*iTime);\n\n    o = 0.5 + 0.5*fbm4_2( q );\n    \n    o += 0.02*sin(vec2(0.13,0.11)*iTime*length( o ));\n\n    n = fbm6_2( 4.0*o );\n\n    vec2 p = q + 2.0*n + 1.0;\n\n    float f = 0.5 + 0.5*fbm4( 2.0*p );\n\n    f = mix( f, f*f*f*3.5, f*abs(n.x) );\n\n    f *= 1.0-0.5*pow( 0.5+0.5*sin(8.0*p.x)*sin(8.0*p.y), 8.0 );\n\n    return f;\n}\n\nfloat funcs( in vec2 q )\n{\n    vec2 t1, t2;\n    return func(q,t1,t2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int mi=0; mi<AA; mi++ )\n    for( int ni=0; ni<AA; ni++ )\n    {\n        // pixel coordinates\n        vec2 of = vec2(float(mi),float(ni)) / float(AA) - 0.5;\n        vec2 q = (2.0*(fragCoord+of)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 q = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n\n        vec2 o, n;\n        float f = func(q, o, n);\n        \n        vec3 col = vec3(0.2,0.1,0.4);\n        col = mix( col, vec3(0.3,0.05,0.05), f );\n        col = mix( col, vec3(0.9,0.9,0.9), dot(n,n) );\n        col = mix( col, vec3(0.5,0.2,0.2), 0.5*o.y*o.y );\n        col = mix( col, vec3(0.0,0.2,0.4), 0.5*smoothstep(1.2,1.3,abs(n.y)+abs(n.x)) );\n        col *= f*2.0;\n\n        vec2 ex = vec2( 1.0 / iResolution.x, 0.0 );\n        vec2 ey = vec2( 0.0, 1.0 / iResolution.y );\n        #if AA>1\n        ex /= float(AA);\n        ey /= float(AA);\n        #endif\n        vec3 nor = normalize( vec3( funcs(q+ex) - f, ex.x, funcs(q+ey) - f ) );\n        \n        vec3 lig = normalize( vec3( 0.9, -0.2, -0.4 ) );\n        float dif = clamp( 0.3+0.7*dot( nor, lig ), 0.0, 1.0 );\n\n        vec3 lin  = vec3(0.85,0.90,0.95)*(nor.y*0.5+0.5);\n             lin += vec3(0.15,0.10,0.05)*dif;\n\n        col *= lin;\n        col = vec3(1.0)-col;\n        col = col*col;\n        col *= vec3(1.2,1.25,1.2);\n        \n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n    \n\tvec2 p = fragCoord / iResolution.xy;\n\ttot *= 0.5 + 0.5 * sqrt(16.0*p.x*p.y*(1.0-p.x)*(1.0-p.y));\n\t\n\tfragColor = vec4( tot, 1.0 );\n}",
    "tags": [
      "procedural",
      "2d",
      "fbm"
    ],
    "author": "iq",
    "views": 0,
    "likes": 448,
    "published": 3
  },
  {
    "id": "4dX3zl",
    "title": "Branchless Voxel Raycasting",
    "description": "Typical DDA algorithms used for voxel traversal use if statements to decide which axis to advance the ray along.  I have devised a modification that eliminates most of them, increasing the performance on GPUs, which do not cope well with branching code.",
    "code": "//The raycasting code is somewhat based around a 2D raycasting toutorial found here: \n//http://lodev.org/cgtutor/raycasting.html\n\nconst bool USE_BRANCHLESS_DDA = true;\nconst int MAX_RAY_STEPS = 64;\n\nfloat sdSphere(vec3 p, float d) { return length(p) - d; } \n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\t\nbool getVoxel(ivec3 c) {\n\tvec3 p = vec3(c) + vec3(0.5);\n\tfloat d = min(max(-sdSphere(p, 7.5), sdBox(p, vec3(6.0))), -sdSphere(p, 25.0));\n\treturn d < 0.0;\n}\n\nvec2 rotate2d(vec2 v, float a) {\n\tfloat sinA = sin(a);\n\tfloat cosA = cos(a);\n\treturn vec2(v.x * cosA - v.y * sinA, v.y * cosA + v.x * sinA);\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 screenPos = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\tvec3 cameraDir = vec3(0.0, 0.0, 0.8);\n\tvec3 cameraPlaneU = vec3(1.0, 0.0, 0.0);\n\tvec3 cameraPlaneV = vec3(0.0, 1.0, 0.0) * iResolution.y / iResolution.x;\n\tvec3 rayDir = cameraDir + screenPos.x * cameraPlaneU + screenPos.y * cameraPlaneV;\n\tvec3 rayPos = vec3(0.0, 2.0 * sin(iTime * 2.7), -12.0);\n\t\t\n\trayPos.xz = rotate2d(rayPos.xz, iTime);\n\trayDir.xz = rotate2d(rayDir.xz, iTime);\n\t\n\tivec3 mapPos = ivec3(floor(rayPos + 0.));\n\n\tvec3 deltaDist = abs(vec3(length(rayDir)) / rayDir);\n\t\n\tivec3 rayStep = ivec3(sign(rayDir));\n\n\tvec3 sideDist = (sign(rayDir) * (vec3(mapPos) - rayPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist; \n\t\n\tbvec3 mask;\n\t\n\tfor (int i = 0; i < MAX_RAY_STEPS; i++) {\n\t\tif (getVoxel(mapPos)) continue;\n\t\tif (USE_BRANCHLESS_DDA) {\n            //Thanks kzy for the suggestion!\n            mask = lessThanEqual(sideDist.xyz, min(sideDist.yzx, sideDist.zxy));\n\t\t\t/*bvec3 b1 = lessThan(sideDist.xyz, sideDist.yzx);\n\t\t\tbvec3 b2 = lessThanEqual(sideDist.xyz, sideDist.zxy);\n\t\t\tmask.x = b1.x && b2.x;\n\t\t\tmask.y = b1.y && b2.y;\n\t\t\tmask.z = b1.z && b2.z;*/\n\t\t\t//Would've done mask = b1 && b2 but the compiler is making me do it component wise.\n\t\t\t\n\t\t\t//All components of mask are false except for the corresponding largest component\n\t\t\t//of sideDist, which is the axis along which the ray should be incremented.\t\t\t\n\t\t\t\n\t\t\tsideDist += vec3(mask) * deltaDist;\n\t\t\tmapPos += ivec3(vec3(mask)) * rayStep;\n\t\t}\n\t\telse {\n\t\t\tif (sideDist.x < sideDist.y) {\n\t\t\t\tif (sideDist.x < sideDist.z) {\n\t\t\t\t\tsideDist.x += deltaDist.x;\n\t\t\t\t\tmapPos.x += rayStep.x;\n\t\t\t\t\tmask = bvec3(true, false, false);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsideDist.z += deltaDist.z;\n\t\t\t\t\tmapPos.z += rayStep.z;\n\t\t\t\t\tmask = bvec3(false, false, true);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (sideDist.y < sideDist.z) {\n\t\t\t\t\tsideDist.y += deltaDist.y;\n\t\t\t\t\tmapPos.y += rayStep.y;\n\t\t\t\t\tmask = bvec3(false, true, false);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsideDist.z += deltaDist.z;\n\t\t\t\t\tmapPos.z += rayStep.z;\n\t\t\t\t\tmask = bvec3(false, false, true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvec3 color;\n\tif (mask.x) {\n\t\tcolor = vec3(0.5);\n\t}\n\tif (mask.y) {\n\t\tcolor = vec3(1.0);\n\t}\n\tif (mask.z) {\n\t\tcolor = vec3(0.75);\n\t}\n\tfragColor.rgb = color;\n\t//fragColor.rgb = vec3(0.1 * noiseDeriv);\n}",
    "tags": [
      "3d",
      "raymarching",
      "raycasting",
      "voxel"
    ],
    "author": "fb39ca4",
    "views": 0,
    "likes": 191,
    "published": 3
  },
  {
    "id": "lsf3WH",
    "title": "Noise - value - 2D",
    "description": "Value Noise . It's cheap compared to Gradient Noise ([url]https://www.shadertoy.com/view/XdXGW8[/urk]) and produces blocky patterns (left), but it's good enough to generate fractal noise in most cases (right).",
    "code": "// The MIT License\n// Copyright \u00a9 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org/\n\n// Value Noise (http://en.wikipedia.org/wiki/Value_noise), not to be confused with Perlin's\n// Noise, is probably the simplest way to generate noise (a random smooth signal with \n// mostly all its energy in the low frequencies) suitable for procedural texturing/shading,\n// modeling and animation.\n//\n// It produces lowe quality noise than Gradient Noise (https://www.shadertoy.com/view/XdXGW8)\n// but it is slightly faster to compute. When used in a fractal construction, the blockyness\n// of Value Noise gets qcuikly hidden, making it a very popular alternative to Gradient Noise.\n//\n// The principle is to create a virtual grid/latice all over the plane, and assign one\n// random value to every vertex in the grid. When querying/requesting a noise value at\n// an arbitrary point in the plane, the grid cell in which the query is performed is\n// determined, the four vertices of the grid are determined and their random\n// value fetched and then bilinearly interpolated with a smooth interpolant.\n\n// All noise functions here:\n//\n// https://www.shadertoy.com/playlist/fXlXzf&from=0&num=12\n\n\n// 0: integer hash\n// 1: float hash (aliasing based) (don't do this unless you live in the year 2013)\n#define METHOD 0\n\n// 0: cubic\n// 1: quintic\n#define INTERPOLANT 0\n\n#if METHOD==0\nfloat hash( in ivec2 p )  // this hash is not production ready, please\n{                         // replace this by something better\n\n    // 2D -> 1D\n    int n = p.x*3 + p.y*113;\n\n    // 1D hash by Hugo Elias\n\tn = (n << 13) ^ n;\n    n = n * (n * n * 15731 + 789221) + 1376312589;\n    return -1.0+2.0*float( n & 0x0fffffff)/float(0x0fffffff);\n}\n#else\nfloat hash(vec2 p)  // replace this by something better\n{\n    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n}\n#endif\n\nfloat noise( in vec2 p )\n{\n    #if METHOD==0\n    ivec2 i = ivec2(floor( p ));\n    #else\n    vec2 i = floor( p );\n    #endif\n    vec2 f = fract( p );\n\t\n    #if INTERPOLANT==1\n    // quintic interpolant\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    #else\n    // cubic interpolant\n    vec2 u = f*f*(3.0-2.0*f);\n    #endif    \n\n    #if METHOD==0\n    return mix( mix( hash( i + ivec2(0,0) ), \n                     hash( i + ivec2(1,0) ), u.x),\n                mix( hash( i + ivec2(0,1) ), \n                     hash( i + ivec2(1,1) ), u.x), u.y);\n    #else\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n    #endif\n}\n\n// -----------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy / iResolution.xy;\n\n\tvec2 uv = p*vec2(iResolution.x/iResolution.y,1.0) + iTime*0.25;\n\t\n\tfloat f = 0.0;\n\n    // left: value noise\t\n\tif( p.x<0.6 )\n\t{\n\t\tf = noise( 32.0*uv );\n\t}\n    // right: fbm - fractal noise (4 octaves)\n    else\t\n\t{\n\t\tuv *= 8.0;\n        mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\t\tf  = 0.5000*noise( uv ); uv = m*uv;\n\t\tf += 0.2500*noise( uv ); uv = m*uv;\n\t\tf += 0.1250*noise( uv ); uv = m*uv;\n\t\tf += 0.0625*noise( uv ); uv = m*uv;\n\t}\n\n\tf = 0.5 + 0.5*f;\n\t\n    f *= smoothstep( 0.0, 0.005, abs(p.x-0.6) );\t\n\t\n\tfragColor = vec4( f, f, f, 1.0 );\n}",
    "tags": [
      "procedural",
      "2d",
      "noise",
      "perlin"
    ],
    "author": "iq",
    "views": 0,
    "likes": 175,
    "published": 3
  },
  {
    "id": "WdVfRc",
    "title": "M-O (from Wall-E)",
    "description": "Anyone remember 'M-O' from Pixar's 'Wall-E' movie?  Here's my tribute to that little chap.",
    "code": "// 'M-O'\n// by dean_the_coder (Twitter: @deanthecoder)\n//\n// Processed by 'GLSL Shader Shrinker'\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n//\n// Anyone remember 'M-O' from Pixar's 'Wall-E' movie?\n// Here's my tribute to that little chap.\n//\n// Technically I wanted to practice writing a shader that\n// performs well enough that I can enable anti-aliasing by\n// default, has quite a small codebase (my shaders usually\n// tend to be a bit on the large side), and doesn't require\n// any external textures.\n//\n// With more GPU power I would have liked to make the red\n// light spin around within refracted glass. I might\n// come back to that if I ever get a more powerful laptop.\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane\n// and a bunch of others for sharing their knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat arms, time,\n      g = 0.;\n\n#define AA\t// Enable this line if your GPU can take it!\n\nstruct Hit {\n\tfloat d; // SDF distance.\n\tint id; // Material ID.\n\tvec2 t; // uv texture coords.\n};\n\nfloat n21(vec2 p) {\n\tconst vec3 s = vec3(7, 157, 0);\n\tvec2 h,\n\t     ip = floor(p);\n\tp = fract(p);\n\tp = p * p * (3. - 2. * p);\n\th = s.zy + dot(ip, s.xy);\n\th = mix(fract(sin(h) * 43.5453), fract(sin(h + s.x) * 43.5453), p.x);\n\treturn mix(h.x, h.y, p.y);\n}\n\nvoid minH(inout Hit a, Hit b) { if (b.d < a.d) a = b; }\n\nmat2 rot(float a) {\n\tfloat c = cos(a),\n\t      s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\nfloat sdCyl(vec3 p, vec2 hr) {\n\tvec2 d = abs(vec2(length(p.zy), p.x)) - hr;\n\treturn min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nfloat sdTaper(vec2 p, vec3 r) {\n\tp.x = abs(p.x);\n\tp.y = -p.y;\n\tfloat b = (r.x - r.y) / r.z,\n\t      a = sqrt(1. - b * b),\n\t      k = dot(p, vec2(-b, a));\n\tif (k > a * r.z) return length(p - vec2(0, r.z)) - r.y;\n\treturn (k < 0. ? length(p) : dot(p, vec2(a, b))) - r.x;\n}\n\nfloat sdArm(vec3 p, float c) {\n\treturn max(max(sdTaper(p.yz, vec3(.5, .2, 2)), abs(abs(p.x) - 1.55)) - .1,  // Main arm.\n\t(p.z + 1.5 + sin(p.y * 7.) * .1) * c);\n}\n\n// The sine wave applied to the dirt track.\nfloat trk(float z) { return sin(z * .2 - time); }\n\n// Map the scene using SDF functions.\nHit map(vec3 p) {\n\t// Floor.\n\tHit h = Hit(length(p.y), 1, p.xz);\n\n\t// Walls.\n\tminH(h, Hit(min(dot(p, vec3(-.707, .707, 0)) + 9., dot(p, vec3(-1, 0, 0)) + 20.), 0, p.yz));\n\n\t// Wall lights.\n\tfloat f, b,\n\t      d = sdBox(vec3(p.xy, mod(p.z - time * 8., 40.)) - vec3(20, 7.25, 20), vec3(.1, .1, 8));\n\tg += .01 / (.01 + d * d);\n\tminH(h, Hit(d - .7, 4, p.xy));\n\tp.x += trk(-.9);\n\tp.xz *= rot(trk(7.) * .2);\n\n\t// Ball.\n\tminH(h, Hit(length(p - vec3(0, 1, 0)) - 1., 2, p.xy));\n\tp.yz *= rot(-arms);\n\tp.y -= 1.7;\n\tminH(h, Hit(sdBox(p, vec3(1.2, .9, .8 + cos((p.y + 5.1) * 1.33) * .5)) - .2, 3, p.xy)); // Lower body.\n\tvec3 op = p;\n\n\t// Arms/Hands.\n\tp.y -= .5;\n\tp.yz *= rot(-arms);\n\td = sdArm(p, -1.);\n\tp.z += arms + cos(time * 15.) * .1;\n\tminH(h, Hit(min(d, sdArm(p, 1.)), 0, op.xy));\n\n\t// Brush.\n\tb = .2 + .8 * abs(sin(p.x * 18.)) * .1;\n\tminH(h, Hit(sdCyl(p + vec3(0, 0, 2), vec2(.1 + b, 1.4)), 2, p.xy));\n\n\t// Arm extenders.\n\tp.x = abs(p.x) - 1.55;\n\tp.z++;\n\tminH(h, Hit(sdBox(p, vec3(.08, .22, .6)), 2, p.xz));\n\n\t// Head.\n\tp = op;\n\tp.yz *= rot(arms * -.7);\n\tp.xz *= rot(trk(0.) * .1);\n\tp.y -= 2.;\n\tp.z += .5;\n\tf = cos(p.y + .8);\n\tminH(h, Hit(max(sdBox(p, vec3(mix(1.2, 1.4, f), .8, mix(.9, 1.2, f))),  // Head.\n\t2.5 - length(p.yz + vec2(2.5, -.8)) // Rear cut-out.\n\t) - .2, 6, p.xy));\n\n\t// Light - Top.\n\tp.y -= mix(.96, 2.5, arms);\n\tminH(h, Hit(sdBox(p, vec3(.5, .04, .5)), 3, p.xy));\n\tminH(h, Hit(sdBox(p + vec3(0, .3, 0), vec3(.45, .3, .45)), 5, p.xy));\n\treturn h;\n}\n\nvec3 calcN(vec3 p) {\n\tconst vec2 e = vec2(.024, -.024);\n\treturn normalize(e.xyy * map(p + e.xyy).d + e.yyx * map(p + e.yyx).d + e.yxy * map(p + e.yxy).d + e.xxx * map(p + e.xxx).d);\n}\n\nfloat calcShadow(vec3 p, vec3 ld) {\n\tfloat h,\n\t      s = 1.,\n\t      t = .1;\n\tfor (int i = 0; i < 20; i++) {\n\t\th = map(p + ld * t).d;\n\t\ts = min(s, 15. * h / t);\n\t\tt += h;\n\t\tif (s < .001 || t > 2.7) break;\n\t}\n\n\treturn clamp(s, 0., 1.);\n}\n\n// Quick ambient occlusion.\nfloat ao(vec3 p, vec3 n, float h) { return map(p + h * n).d / h; }\n\n/**********************************************************************************/\nvec3 vig(vec3 c, vec2 fc) {\n\tvec2 q = fc.xy / iResolution.xy;\n\tc *= .5 + .5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .4);\n\treturn c;\n}\n\n// Calculate the floor normal vector.\nvec2 flrN(vec2 t) {\n\treturn n21(vec2(t.x * 1.2, t.y)) * .3 +  // Surface texture.\n\tsmoothstep(0., .04, abs(sin(t * .5)));\n}\n\nvec3 mat(Hit h, vec3 p, inout vec3 n) {\n\tif (h.id == 1) {\n\t\t// Floor\n\t\tvec2 d,\n\t\t     t = h.t + vec2(trk(p.z), time * -5.);\n\t\tn.xz += flrN(vec2(h.t.x, t.y));\n\t\tn = normalize(n);\n\t\tfloat mm = n21(mod(t * 10., 20.));\n\t\td = abs(vec2(abs(abs(t.x) - .8) - .3, mod(t.y, .4) - .1)) - vec2(.2, .1);\n\t\treturn vec3(.3, .4, .5) * mix(1., mm, (1. - step(0., min(max(d.x, d.y), 0.))) * step(p.z, -2.5));\n\t}\n\n\tif (h.id == 2) return vec3(.1); // Ball, brush\n\tif (h.id == 3) return vec3(1. - step(abs(h.t.y + .7), .15) * .9); // White body\n\tif (h.id == 4) return vec3(25); // Wall light.\n\tif (h.id == 5) return vec3(1, 0, 0);\n\tif (h.id == 6) {\n\t\t// Face\n\t\tvec2 t = vec2(abs(h.t.x), h.t.y);\n\t\tif (t.y < -.3 && t.x < 1.) {\n\t\t\tt.x += arms * .4;\n\t\t\tfloat l = .3 + .7 * abs(sin(t.y * 50.));\n\t\t\tt *= rot(.6 * arms);\n\t\t\treturn .01 + vec3(1.5, 1.5, 0) * step(abs(t.x - .3), .25) * step(abs(t.y + .7), .1 - arms * .1) * l;\n\t\t}\n\t}\n\n\treturn vec3(1);\n}\n\nvec3 lights(vec3 p, vec3 rd, Hit h) {\n\tvec3 n = calcN(p),\n\t     ld = normalize(vec3(6, 3, -10) - p);\n\treturn mat(h, p, n) // Material color.\n\t * ((max(0., .1 + .9 * dot(ld, n)) // Primary light.\n\t + max(0., .1 + .9 * dot(ld * vec3(-1, 0, -1), n)) // Bounce light.\n\t) * mix(.3, .6, calcShadow(p, ld)) // Shadows.\n\t * mix(ao(p, n, .3), ao(p, n, 2.), .7) // Ambient occlusion.\n\t + pow(max(0., dot(rd, reflect(ld, n))), 30.) // Specular.\n\t) * vec3(2, 1.8, 1.7);\n}\n\nvec3 march(vec3 ro, vec3 rd) {\n\t// Raymarch.\n\tvec3 p, n, c;\n\tfloat d = .01;\n\tHit h;\n\tfor (int i = 0; i < 110; i++) {\n\t\tp = ro + rd * d;\n\t\th = map(p);\n\t\tif (abs(h.d) < .0015) break;\n\t\td += h.d;\n\t}\n\n\t// Calculate pixel color.\n\tc = lights(p, rd, h) + g;\n\tif (h.id == 1) {\n\t\t// Ray hit the floor - Apply reflection.\n\t\tn = calcN(p);\n\t\tn.xz -= flrN(p.xz - vec2(0, time * 5.)) * .024;\n\t\trd = reflect(rd, normalize(n));\n\t\td = .5;\n\t\tro = p;\n\t\tfor (int i = 0; i < 90; i++) {\n\t\t\tp = ro + rd * d;\n\t\t\th = map(p);\n\t\t\tif (abs(h.d) < .0015) break;\n\t\t\td += h.d;\n\t\t}\n\n\t\tif (abs(h.d) < .0015) c = mix(c, mat(h, p, n), .01);\n\t}\n\n\treturn c;\n}\n\nvoid mainImage(out vec4 c, vec2 fc) {\n\ttime = mod(iTime, 30.) - 1.;\n\tarms = (time < 0. ? smoothstep(-1., 0., time) : abs(sin(time * 10.) * .1) + .9) * .38;\n\ttime = max(0., time);\n\tvec3 ro = vec3(-7, 4, -7. - sin(time * .3)),\n\t     col = vec3(0);\n#ifdef AA\n\tfor (float dx = 0.; dx <= 1.; dx++) {\n\t\tfor (float dy = 0.; dy <= 1.; dy++) {\n\t\t\tvec2 uv = (fc + vec2(dx, dy) * .5 - .5 * iResolution.xy) / iResolution.y;\n#else\n\t\t\tvec2 uv = (fc - .5 * iResolution.xy) / iResolution.y;\n#endif\n\t\t\tvec3 f = normalize(vec3(0, 3, -4) - ro),\n\t\t\t     r = normalize(cross(vec3(0, 1, 0), f));\n\t\t\tcol += march(ro, normalize(f + r * uv.x + cross(f, r) * uv.y));\n#ifdef AA\n\t\t}\n\t}\n\n\tcol /= 4.;\n#endif\n\tc.rgb = vig(pow(col, vec3(.45)), fc);\n}",
    "tags": [
      "3d",
      "raymarching",
      "pixar",
      "movie",
      "cineshader",
      "walle"
    ],
    "author": "dean_the_coder",
    "views": 0,
    "likes": 152,
    "published": 3
  },
  {
    "id": "4ds3zn",
    "title": "Apollonian",
    "description": "The classic standard apollonian/kleinian fractal (everybody needs to render one at some point).",
    "code": "// Created by inigo quilez - iq/2013\n//   https://www.youtube.com/c/InigoQuilez\n//   https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work neither\n// as it is or altered, here on Shadertoy or anywhere else, in any\n// form including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it or train a neural\n// network with it without permission. I share this Work for educational\n// purposes, and you can link to it, through an URL, proper attribution\n// and unmodified screenshot, as part of your educational material. If\n// these conditions are too restrictive please contact me and we'll\n// definitely work it out.\n\n\n// I can't recall where I learnt about this fractal.\n//\n// Coloring and fake occlusions are done by orbit trapping, as usual.\n\n\n// Antialiasing level\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2 // Make it 3 if you have a fast machine\n#endif\n\nvec4 orb; \n\nfloat map( vec3 p, float s )\n{\n\tfloat scale = 1.0;\n\n\torb = vec4(1000.0); \n\t\n\tfor( int i=0; i<8;i++ )\n\t{\n\t\tp = -1.0 + 2.0*fract(0.5*p+0.5);\n\n\t\tfloat r2 = dot(p,p);\n\t\t\n        orb = min( orb, vec4(abs(p),r2) );\n\t\t\n\t\tfloat k = s/r2;\n\t\tp     *= k;\n\t\tscale *= k;\n\t}\n\t\n\treturn 0.25*abs(p.y)/scale;\n}\n\nfloat trace( in vec3 ro, in vec3 rd, float s )\n{\n\tfloat maxd = 30.0;\n    float t = 0.01;\n    for( int i=0; i<512; i++ )\n    {\n\t    float precis = 0.001 * t;\n        \n\t    float h = map( ro+rd*t, s );\n        if( h<precis||t>maxd ) break;\n        t += h;\n    }\n\n    if( t>maxd ) t=-1.0;\n    return t;\n}\n\nvec3 calcNormal( in vec3 pos, in float t, in float s )\n{\n    float precis = 0.001 * t;\n\n    vec2 e = vec2(1.0,-1.0)*precis;\n    return normalize( e.xyy*map( pos + e.xyy, s ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, s ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, s ) + \n                      e.xxx*map( pos + e.xxx, s ) );\n}\n\nvec3 render( in vec3 ro, in vec3 rd, in float anim )\n{\n    // trace\t\n    vec3 col = vec3(0.0);\n    float t = trace( ro, rd, anim );\n    if( t>0.0 )\n    {\n        vec4 tra = orb;\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, t, anim );\n\n        // lighting\n        vec3  light1 = vec3(  0.577, 0.577, -0.577 );\n        vec3  light2 = vec3( -0.707, 0.000,  0.707 );\n        float key = clamp( dot( light1, nor ), 0.0, 1.0 );\n        float bac = clamp( 0.2 + 0.8*dot( light2, nor ), 0.0, 1.0 );\n        float amb = (0.7+0.3*nor.y);\n        float ao = pow( clamp(tra.w*2.0,0.0,1.0), 1.2 );\n\n        vec3 brdf  = 1.0*vec3(0.40,0.40,0.40)*amb*ao;\n        brdf += 1.0*vec3(1.00,1.00,1.00)*key*ao;\n        brdf += 1.0*vec3(0.40,0.40,0.40)*bac*ao;\n\n        // material\t\t\n        vec3 rgb = vec3(1.0);\n        rgb = mix( rgb, vec3(1.0,0.80,0.2), clamp(6.0*tra.y,0.0,1.0) );\n        rgb = mix( rgb, vec3(1.0,0.55,0.0), pow(clamp(1.0-2.0*tra.z,0.0,1.0),8.0) );\n\n        // color\n        col = rgb*brdf*exp(-0.2*t);\n    }\n\n    return sqrt(col);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime*0.25;\n    float anim = 1.1 + 0.5*smoothstep( -0.3, 0.3, cos(0.1*iTime) );\n    \n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int jj=0; jj<AA; jj++ )\n    for( int ii=0; ii<AA; ii++ )\n    #else\n    int ii = 1, jj = 1;\n    #endif\n    {\n        vec2 q = fragCoord.xy+vec2(float(ii),float(jj))/float(AA);\n        vec2 p = (2.0*q-iResolution.xy)/iResolution.y;\n\n        // camera\n        vec3 ro = vec3( 2.8*cos(0.1+.33*time), 0.4 + 0.30*cos(0.37*time), 2.8*cos(0.5+0.35*time) );\n        vec3 ta = vec3( 1.9*cos(1.2+.41*time), 0.4 + 0.10*cos(0.27*time), 1.9*cos(2.0+0.38*time) );\n        float roll = 0.2*cos(0.1*time);\n        vec3 cw = normalize(ta-ro);\n        vec3 cp = vec3(sin(roll), cos(roll),0.0);\n        vec3 cu = normalize(cross(cw,cp));\n        vec3 cv = normalize(cross(cu,cw));\n        vec3 rd = normalize( p.x*cu + p.y*cv + 2.0*cw );\n\n        tot += render( ro, rd, anim );\n    }\n    \n    tot = tot/float(AA*AA);\n    \n\tfragColor = vec4( tot, 1.0 );\t\n\n}",
    "tags": [
      "3d",
      "raymarching",
      "fractal",
      "distancefield",
      "kleinian",
      "apollonian",
      "vr"
    ],
    "author": "iq",
    "views": 0,
    "likes": 316,
    "published": 3
  },
  {
    "id": "ltlSWf",
    "title": "Flux Core",
    "description": "Long range space-based energy transmission requires a flux core to amplify and concentrate energy.\n*** Try out the high quality non-realtime renderer. Feel free to use it for your shaders if you want to render screenshots.",
    "code": "/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^ This means do ANYTHING YOU WANT with this code. Because we are programmers, not lawyers.\n-Otavio Good\n*/\n\n// ---------------- Config ----------------\n// This is an option that lets you render high quality frames for screenshots. It enables\n// stochastic antialiasing and motion blur automatically for any shader.\n//#define NON_REALTIME_HQ_RENDER\nconst float frameToRenderHQ = 20.0; // Time in seconds of frame to render\nconst float antialiasingSamples = 16.0; // 16x antialiasing - too much might make the shader compiler angry.\n\n//#define MANUAL_CAMERA\n\n\n#define ZERO_TRICK max(0, -iFrame)\n// --------------------------------------------------------\n// These variables are for the non-realtime block renderer.\nfloat localTime = 0.0;\nfloat seed = 1.0;\n\n// Animation variables\nfloat animStructure = 1.0;\nfloat fade = 1.0;\n\n// ---- noise functions ----\nfloat v31(vec3 a)\n{\n    return a.x + a.y * 37.0 + a.z * 521.0;\n}\nfloat v21(vec2 a)\n{\n    return a.x + a.y * 37.0;\n}\nfloat Hash11(float a)\n{\n    return fract(sin(a)*10403.9);\n}\nfloat Hash21(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(sin(f)*104003.9);\n}\nvec2 Hash22(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(cos(f)*vec2(10003.579, 37049.7));\n}\nvec2 Hash12(float f)\n{\n    return fract(cos(f)*vec2(10003.579, 37049.7));\n}\nfloat Hash1d(float u)\n{\n    return fract(sin(u)*143.9);\t// scale this down to kill the jitters\n}\nfloat Hash2d(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(sin(f)*104003.9);\n}\nfloat Hash3d(vec3 uv)\n{\n    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;\n    return fract(sin(f)*110003.9);\n}\nfloat mixP(float f0, float f1, float a)\n{\n    return mix(f0, f1, a*a*(3.0-2.0*a));\n}\nconst vec2 zeroOne = vec2(0.0, 1.0);\nfloat noise2d(vec2 uv)\n{\n    vec2 fr = fract(uv.xy);\n    vec2 fl = floor(uv.xy);\n    float h00 = Hash2d(fl);\n    float h10 = Hash2d(fl + zeroOne.yx);\n    float h01 = Hash2d(fl + zeroOne);\n    float h11 = Hash2d(fl + zeroOne.yy);\n    return mixP(mixP(h00, h10, fr.x), mixP(h01, h11, fr.x), fr.y);\n}\nfloat noise(vec3 uv)\n{\n    vec3 fr = fract(uv.xyz);\n    vec3 fl = floor(uv.xyz);\n    float h000 = Hash3d(fl);\n    float h100 = Hash3d(fl + zeroOne.yxx);\n    float h010 = Hash3d(fl + zeroOne.xyx);\n    float h110 = Hash3d(fl + zeroOne.yyx);\n    float h001 = Hash3d(fl + zeroOne.xxy);\n    float h101 = Hash3d(fl + zeroOne.yxy);\n    float h011 = Hash3d(fl + zeroOne.xyy);\n    float h111 = Hash3d(fl + zeroOne.yyy);\n    return mixP(\n        mixP(mixP(h000, h100, fr.x),\n             mixP(h010, h110, fr.x), fr.y),\n        mixP(mixP(h001, h101, fr.x),\n             mixP(h011, h111, fr.x), fr.y)\n        , fr.z);\n}\n\nconst float PI=3.14159265;\n\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\nvec3 RotateX(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(v.x, cos * v.y + sin * v.z, -sin * v.y + cos * v.z);\n}\nvec3 RotateY(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(cos * v.x - sin * v.z, v.y, sin * v.x + cos * v.z);\n}\nvec3 RotateZ(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  return vec3(cos * v.x + sin * v.y, -sin * v.x + cos * v.y, v.z);\n}\n\n// This spiral noise works by successively adding and rotating sin waves while increasing frequency.\n// It should work the same on all computers since it's not based on a hash function like some other noises.\n// It can be much faster than other noise functions if you're ok with some repetition.\nconst float nudge = 0.71;\t// size of perpendicular vector\nfloat normalizer = 1.0 / sqrt(1.0 + nudge*nudge);\t// pythagorean theorem on that perpendicular to maintain scale\n// Total hack of the spiral noise function to get a rust look\nfloat RustNoise3D(vec3 p)\n{\n    float n = 0.0;\n    float iter = 1.0;\n    float pn = noise(p*0.125);\n    pn += noise(p*0.25)*0.5;\n    pn += noise(p*0.5)*0.25;\n    pn += noise(p*1.0)*0.125;\n    for (int i = ZERO_TRICK; i < 7; i++)\n    {\n        //n += (sin(p.y*iter) + cos(p.x*iter)) / iter;\n        float wave = saturate(cos(p.y*0.25 + pn) - 0.998);\n        wave *= noise(p * 0.125)*1016.0;\n        n += wave;\n        p.xy += vec2(p.y, -p.x) * nudge;\n        p.xy *= normalizer;\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        iter *= 1.4733;\n    }\n    return n;\n}\n\n// ---- functions to remap / warp space ----\nfloat repsDouble(float a)\n{\n    return abs(a * 2.0 - 1.0);\n}\nvec2 repsDouble(vec2 a)\n{\n    return abs(a * 2.0 - 1.0);\n}\n\nvec2 mapSpiralMirror(vec2 uv)\n{\n    float len = length(uv);\n    float at = atan(uv.x, uv.y);\n    at = at / PI;\n    float dist = (fract(log(len)+at*0.5)-0.5) * 2.0;\n    at = repsDouble(at);\n    at = repsDouble(at);\n    return vec2(abs(dist), abs(at));\n}\n\nvec2 mapSpiral(vec2 uv)\n{\n    float len = length(uv);\n    float at = atan(uv.x, uv.y);\n    at = at / PI;\n    float dist = (fract(log(len)+at*0.5)-0.5) * 2.0;\n    //dist += sin(at*32.0)*0.05;\n    // at is [-1..1]\n    // dist is [-1..1]\n    at = repsDouble(at);\n    at = repsDouble(at);\n    return vec2(dist, at);\n}\n\nvec2 mapCircleInvert(vec2 uv)\n{\n    float len = length(uv);\n    float at = atan(uv.x, uv.y);\n    //at = at / PI;\n    //return uv;\n    len = 1.0 / len;\n    return vec2(sin(at)*len, cos(at)*len);\n}\n\nvec3 mapSphereInvert(vec3 uv)\n{\n    float len = length(uv);\n    vec3 dir = normalize(uv);\n    len = 1.0 / len;\n    return dir * len;\n}\n\n// ---- shapes defined by distance fields ----\n// See this site for a reference to more distance functions...\n// https://iquilezles.org/articles/distfunctions\nfloat length8(vec2 v)\n{\n\treturn pow(pow(abs(v.x),8.0) + pow(abs(v.y), 8.0), 1.0/8.0);\n}\n\n// box distance field\nfloat sdBox(vec3 p, vec3 radius)\n{\n  vec3 dist = abs(p) - radius;\n  return min(max(dist.x, max(dist.y, dist.z)), 0.0) + length(max(dist, 0.0));\n}\n\n// Makes a warped torus that rotates around\nfloat sdTorusWobble( vec3 p, vec2 t, float offset)\n{\n   \tfloat a = atan(p.x, p.z);\n    float subs = 2.0;\n\ta = sin(a*subs+localTime*4.0+offset*3.234567);\n\tvec2 q = vec2(length(p.xz)-t.x-a*0.1,p.y);\n\treturn length8(q)-t.y;\n}\n\n// simple cylinder distance field\nfloat cyl(vec2 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat glow = 0.0, glow2 = 0.0, glow3 = 0.0;\nfloat pulse;\n// This is the big money function that makes the crazy fractally shape\n// The input is a position in space.\n// The output is the distance to the nearest surface.\nfloat DistanceToObject(vec3 p)\n{\n    vec3 orig = p;\n    // Magically remap space to be in a spiral\n    p.yz = mapSpiralMirror(p.yz);\n    // Mix between spiral space and unwarped space. This changes the scene\n    // from the tunnel to the spiral.\n    p = mix(orig, p, animStructure);\n//    p = mix(p, orig, cos(localTime)*0.5+0.5);\n\n    // Cut out stuff outside of outer radius\n\tconst float outerRad = 3.5;\n    float lenXY = length(p.xy);\n    float final = lenXY - outerRad;\n    // Carve out inner radius\n    final = max(final, -(lenXY - (outerRad-0.65)));\n\n    // Slice the object in a 3d grid\n    float slice = 0.04;\n    vec3 grid = -abs(fract(p)-0.5) + slice;\n    //final = max(final, grid.x);\n    //final = max(final, grid.y);\n    final = max(final, grid.z);\n\n    // Carve out cylinders from the object on all 3 axis, scaled 3 times\n    // This gives it the fractal look.\n    vec3 rep = fract(p)-0.5;\n    float scale = 1.0;\n    float mult = 0.32;\n    for (int i = ZERO_TRICK; i < 3; i++)\n    {\n        float uglyDivider = max(1.0, float(i));\t// wtf is this? My math sucks :(\n        // carve out 3 cylinders\n        float dist = cyl(rep.xz/scale, mult/scale)/uglyDivider;\n        final = max(final, -dist);\n        dist = cyl(rep.xy/scale, mult/scale)/uglyDivider;\n        final = max(final, -dist);\n        dist = cyl(rep.yz/scale, mult/scale)/uglyDivider;\n        final = max(final, -dist);\n        // Scale and repeat.\n        scale *= 1.14+1.0;// + sin(localTime)*0.995;\n        rep = fract(rep*scale) - 0.5;\n    }\n\n    // Make radial struts that poke into the center of the spiral\n    vec3 sp = p;\n    sp.x = abs(sp.x)-5.4;\n    sp.z = fract(sp.z) - 0.5;\n    // Bad distance field on these makes them sometimes disappear. Math. :(\n    float struts = sdBox(sp+vec3(2.95, 0.1-sin(sp.x*2.0)*1.1, 0.0), vec3(1.5, 0.05, 0.02))*0.5;\n    //glow3 += (0.00005)/max(0.01, struts);\n    final = min(final, struts);\n\n    // Make spiral glows that rotate and pulse energy to the center\n    rep.yz = (fract(p.yz)-0.5);\n    rep.x = p.x;\n    scale = 1.14+1.0;\n    float jolt = max(0.0, sin(length(orig.yz) + localTime*20.0))*0.94;\n    jolt *= saturate(0.3-pulse);\n    float spiral = sdBox(RotateX(rep+vec3(-0.05,0.0,0.0), pulse), vec3(0.01+jolt,1.06, mult*0.01)/scale );\n    glow3 += (0.0018)/max(0.0025,spiral);\n    final = min(final, spiral + (1.0-animStructure) * 100.0);\n\n    // Make a warped torus that rotates around and glows orange\n    vec3 rp = p.xzy;\n    rp.x = -abs(rp.x);\n    rp.y = fract(rp.y) - 0.5;\n    float torus = sdTorusWobble(rp + vec3(3.0, 0.0, 0.0), vec2(0.2, 0.0003), p.z);\n    glow2 += 0.0015 / max(0.03, torus);\n    final = min(final, torus);\n\n    // Make the glowing tower in the center.\n    // This also gives a bit of a glow to everything.\n    glow += (0.02+abs(sin(orig.x-localTime*3.0)*0.15)*jolt )/length(orig.yz);\n\n    return final;\n}\n\n// Input is UV coordinate of pixel to render.\n// Output is RGB color.\nvec3 RayTrace(in vec2 fragCoord )\n{\n    glow = 0.0;\n    glow2 = 0.0;\n    glow3 = 0.0;\n\t// -------------------------------- animate ---------------------------------------\n    // Default to spiral shape\n    animStructure = 1.0;\n\n    // Make a cycling, clamped sin wave to animate the glow-spiral rotation.\n    float slt = sin(localTime);\n    float stepLike = pow(abs(slt), 0.75)*sign(slt);\n    stepLike = max(-1.0, min(1.0, stepLike*1.5));\n    pulse = stepLike*PI/4.0 + PI/4.0;\n\n\tvec3 camPos, camUp, camLookat;\n\t// ------------------- Set up the camera rays for ray marching --------------------\n    // Map uv to [-1.0..1.0]\n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;\n\n#ifdef MANUAL_CAMERA\n    // Camera up vector.\n\tcamUp=vec3(0,1,0);\n\n\t// Camera lookat.\n\tcamLookat=vec3(0,0.0,0);\n\n    // debugging camera\n    float mx=iMouse.x/iResolution.x*PI*2.0;// + localTime * 0.166;\n\tfloat my=-iMouse.y/iResolution.y*10.0;// + sin(localTime * 0.3)*0.8+0.1;//*PI/2.01;\n\tcamPos = vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*8.35;\n#else\n    // Do the camera fly-by animation and different scenes.\n    // Time variables for start and end of each scene\n    const float t0 = 0.0;\n    const float t1 = 9.0;\n    const float t2 = 16.0;\n    const float t3 = 24.0;\n    const float t4 = 40.0;\n    const float t5 = 48.0;\n    const float t6 = 70.0;\n    // Repeat the animation after time t6\n    localTime = fract(localTime / t6) * t6;\n    /*const float t0 = 0.0;\n    const float t1 = 0.0;\n    const float t2 = 0.0;\n    const float t3 = 0.0;\n    const float t4 = 0.0;\n    const float t5 = 0.0;\n    const float t6 = 18.0;*/\n    if (localTime < t1)\n    {\n\t    animStructure = 0.0;\n        float time = localTime - t0;\n        float alpha = time / (t1 - t0);\n        fade = saturate(time);\n        fade *= saturate(t1 - localTime);\n        camPos = vec3(56.0, -2.5, 1.5);\n        camPos.x -= alpha * 6.8;\n        camUp=vec3(0,1,0);\n        camLookat=vec3(50,0.0,0);\n    } else if (localTime < t2)\n    {\n    \tanimStructure = 0.0;\n        float time = localTime - t1;\n        float alpha = time / (t2 - t1);\n        fade = saturate(time);\n        fade *= saturate(t2 - localTime);\n        camPos = vec3(12.0, 3.3, -0.5);\n        camPos.x -= smoothstep(0.0, 1.0, alpha) * 4.8;\n        camUp=vec3(0,1,0);\n        camLookat=vec3(0,5.5,-0.5);\n    } else if (localTime < t3)\n    {\n        animStructure = 1.0;\n        float time = localTime - t2;\n        float alpha = time / (t3 - t2);\n        fade = saturate(time);\n        fade *= saturate(t3 - localTime);\n        camPos = vec3(12.0, 6.3, -0.5);\n        camPos.y -= alpha * 1.8;\n        camPos.x = cos(alpha*1.0) * 6.3;\n        camPos.z = sin(alpha*1.0) * 6.3;\n        camUp=normalize(vec3(0,1,-0.3 - alpha * 0.5));\n        camLookat=vec3(0,0.0,-0.5);\n    } else if (localTime < t4)\n    {\n        animStructure = 1.0;\n        float time = localTime - t3;\n        float alpha = time / (t4 - t3);\n        fade = saturate(time);\n        fade *= saturate(t4 - localTime);\n        camPos = vec3(12.0, 3.0, -2.6);\n        camPos.y -= alpha * 1.8;\n        camPos.x = cos(alpha*1.0) * 6.5-alpha*0.25;\n        camPos.z += sin(alpha*1.0) * 6.5-alpha*0.25;\n        camUp=normalize(vec3(0,1,0.0));\n        camLookat=vec3(0,0.0,-0.0);\n    } else if (localTime < t5)\n    {\n        animStructure = 1.0;\n        float time = localTime - t4;\n        float alpha = time / (t5 - t4);\n        fade = saturate(time);\n        fade *= saturate(t5 - localTime);\n        camPos = vec3(0.0, -7.0, -0.9);\n        camPos.y -= alpha * 1.8;\n        camPos.x = cos(alpha*1.0) * 1.5-alpha*1.5;\n        camPos.z += sin(alpha*1.0) * 1.5-alpha*1.5;\n        camUp=normalize(vec3(0,1,0.0));\n        camLookat=vec3(0,-3.0,-0.0);\n    } else if (localTime < t6)\n    {\n        float time = localTime - t5;\n        float alpha = time / (t6 - t5);\n        float smoothv = smoothstep(0.0, 1.0, saturate(alpha*1.8-0.1));\n        animStructure = 1.0-smoothv;\n        fade = saturate(time);\n        fade *= saturate(t6 - localTime);\n        camPos = vec3(10.0, -0.95+smoothv*1.0, 0.0);\n        camPos.x -= alpha * 6.8;\n        camUp=normalize(vec3(0,1.0-smoothv,0.0+smoothv));\n        camLookat=vec3(0,-0.0,-0.0);\n    }\n#endif\n\n\t// Camera setup.\n\tvec3 camVec=normalize(camLookat - camPos);\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\n\tvec3 upNorm=cross(camVec, sideNorm);\n\tvec3 worldFacing=(camPos + camVec);\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;\n\tvec3 rayVec = normalize(worldPix - camPos);\n\n\t// ----------------------------- Ray march the scene ------------------------------\n\tfloat dist = 1.0;\n\tfloat t = 0.1 + Hash2d(uv)*0.1;\t// random dither-fade things close to the camera\n\tconst float maxDepth = 45.0; // farthest distance rays will travel\n\tvec3 pos = vec3(0,0,0);\n    const float smallVal = 0.000625;\n\t// ray marching time\n    for (int i = ZERO_TRICK; i < 210; i++)\t// This is the count of the max times the ray actually marches.\n    {\n        // Step along the ray. Switch x, y, and z because I messed up the orientation.\n        pos = (camPos + rayVec * t).yzx;\n        // This is _the_ function that defines the \"distance field\".\n        // It's really what makes the scene geometry. The idea is that the\n        // distance field returns the distance to the closest object, and then\n        // we know we are safe to \"march\" along the ray by that much distance\n        // without hitting anything. We repeat this until we get really close\n        // and then break because we have effectively hit the object.\n        dist = DistanceToObject(pos);\n        // This makes the ray trace more precisely in the center so it will not miss the\n        // vertical glowy beam.\n        dist = min(dist, length(pos.yz));\n\n        t += dist;\n        // If we are very close to the object, let's call it a hit and exit this loop.\n        if ((t > maxDepth) || (abs(dist) < smallVal)) break;\n    }\n\n\t// --------------------------------------------------------------------------------\n\t// Now that we have done our ray marching, let's put some color on this geometry.\n\tfloat glowSave = glow;\n\tfloat glow2Save = glow2;\n\tfloat glow3Save = glow3;\n\n\tvec3 sunDir = normalize(vec3(0.93, 1.0, -1.5));\n\tvec3 finalColor = vec3(0.0);\n\n\t// If a ray actually hit the object, let's light it.\n    if (t <= maxDepth)\n\t{\n        // calculate the normal from the distance field. The distance field is a volume, so if you\n        // sample the current point and neighboring points, you can use the difference to get\n        // the normal.\n        vec3 smallVec = vec3(smallVal, 0, 0);\n        vec3 normalU = vec3(dist - DistanceToObject(pos - smallVec.xyy),\n                           dist - DistanceToObject(pos - smallVec.yxy),\n                           dist - DistanceToObject(pos - smallVec.yyx));\n        vec3 normal = normalize(normalU);\n\n        // calculate 2 ambient occlusion values. One for global stuff and one\n        // for local stuff\n        float ambientS = 1.0;\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.05)*20.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.1)*10.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.2)*5.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.4)*2.5);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.8)*1.25);\n        float ambient = ambientS * saturate(DistanceToObject(pos + normal * 1.6)*1.25*0.5);\n        //ambient *= saturate(DistanceToObject(pos + normal * 3.2)*1.25*0.25);\n        //ambient *= saturate(DistanceToObject(pos + normal * 6.4)*1.25*0.125);\n        //ambient = max(0.05, pow(ambient, 0.3));\t// tone down ambient with a pow and min clamp it.\n        ambient = saturate(ambient);\n\n        // calculate the reflection vector for highlights\n        //vec3 ref = reflect(rayVec, normal);\n\n        // Trace a ray toward the sun for sun shadows\n        float sunShadow = 1.0;\n        float iter = 0.01;\n        vec3 nudgePos = pos + normal*0.002;\t// don't start tracing too close or inside the object\n\t\tfor (int i = ZERO_TRICK; i < 30; i++)\n        {\n            float tempDist = DistanceToObject(nudgePos + sunDir * iter);\n\t        sunShadow *= saturate(tempDist*150.0);\t// Shadow hardness\n            if (tempDist <= 0.0) break;\n            //iter *= 1.5;\t// constant is more reliable than distance-based\n            iter += max(0.01, tempDist)*1.0;\n            if (iter > 4.2) break;\n        }\n        sunShadow = saturate(sunShadow);\n\n        // make a few frequencies of noise to give it some texture\n        float n =0.0;\n        n += noise(pos*32.0);\n        n += noise(pos*64.0);\n        n += noise(pos*128.0);\n        n += noise(pos*256.0);\n        n += noise(pos*512.0);\n        n *= 0.8;\n        normal = normalize(normal + (n-2.0)*0.1);\n\n        // ------ Calculate texture color  ------\n        vec3 texColor = vec3(0.95, 1.0, 1.0);\n        vec3 rust = vec3(0.65, 0.25, 0.1) - noise(pos*128.0);\n        // Call the function that makes rust stripes on the texture\n        texColor *= smoothstep(texColor, rust, vec3(saturate(RustNoise3D(pos*8.0))-0.2));\n\n        // apply noise\n        texColor *= vec3(1.0)*n*0.05;\n        texColor *= 0.7;\n        texColor = saturate(texColor);\n\n        // ------ Calculate lighting color ------\n        // Start with sun color, standard lighting equation, and shadow\n        vec3 lightColor = vec3(3.6) * saturate(dot(sunDir, normal)) * sunShadow;\n        // weighted average the near ambient occlusion with the far for just the right look\n        float ambientAvg = (ambient*3.0 + ambientS) * 0.25;\n        // a red and blue light coming from different directions\n        lightColor += (vec3(1.0, 0.2, 0.4) * saturate(-normal.z *0.5+0.5))*pow(ambientAvg, 0.35);\n        lightColor += (vec3(0.1, 0.5, 0.99) * saturate(normal.y *0.5+0.5))*pow(ambientAvg, 0.35);\n        // blue glow light coming from the glow in the middle\n        lightColor += vec3(0.3, 0.5, 0.9) * saturate(dot(-pos, normal))*pow(ambientS, 0.3);\n        lightColor *= 4.0;\n\n        // finally, apply the light to the texture.\n        finalColor = texColor * lightColor;\n        // sun reflection to make it look metal\n        //finalColor += vec3(1.0)*pow(n,4.0)* GetSunColorSmall(ref, sunDir) * sunShadow;// * ambientS;\n        // visualize length of gradient of distance field to check distance field correctness\n        //finalColor = vec3(0.5) * (length(normalU) / smallVec.x);\n\t}\n    else\n    {\n        // Our ray trace hit nothing, so draw sky.\n    }\n    // add the ray marching glows\n    float center = length(pos.yz);\n    finalColor += vec3(0.3, 0.5, 0.9) * glowSave*1.2;\n    finalColor += vec3(0.9, 0.5, 0.3) * glow2*1.2;\n    finalColor += vec3(0.25, 0.29, 0.93) * glow3Save*2.0;\n\n    // vignette?\n    finalColor *= vec3(1.0) * saturate(1.0 - length(uv/2.5));\n    finalColor *= 1.0;// 1.3;\n\n\t// output the final color without gamma correction - will do gamma later.\n\treturn vec3(clamp(finalColor, 0.0, 1.0)*saturate(fade+0.25));\n}\n\n#ifdef NON_REALTIME_HQ_RENDER\n// This function breaks the image down into blocks and scans\n// through them, rendering 1 block at a time. It's for non-\n// realtime things that take a long time to render.\n\n// This is the frame rate to render at. Too fast and you will\n// miss some blocks.\nconst float blockRate = 20.0;\nvoid BlockRender(in vec2 fragCoord)\n{\n    // blockSize is how much it will try to render in 1 frame.\n    // adjust this smaller for more complex scenes, bigger for\n    // faster render times.\n    const float blockSize = 64.0;\n    // Make the block repeatedly scan across the image based on time.\n    float frame = floor(iTime * blockRate);\n    vec2 blockRes = floor(iResolution.xy / blockSize) + vec2(1.0);\n    // ugly bug with mod.\n    //float blockX = mod(frame, blockRes.x);\n    float blockX = fract(frame / blockRes.x) * blockRes.x;\n    //float blockY = mod(floor(frame / blockRes.x), blockRes.y);\n    float blockY = fract(floor(frame / blockRes.x) / blockRes.y) * blockRes.y;\n    // Don't draw anything outside the current block.\n    if ((fragCoord.x - blockX * blockSize >= blockSize) ||\n    \t(fragCoord.x - (blockX - 1.0) * blockSize < blockSize) ||\n    \t(fragCoord.y - blockY * blockSize >= blockSize) ||\n    \t(fragCoord.y - (blockY - 1.0) * blockSize < blockSize))\n    {\n        discard;\n    }\n}\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#ifdef NON_REALTIME_HQ_RENDER\n    // Optionally render a non-realtime scene with high quality\n    BlockRender(fragCoord);\n#endif\n\n    // Do a multi-pass render\n    vec3 finalColor = vec3(0.0);\n#ifdef NON_REALTIME_HQ_RENDER\n    for (float i = 0.0; i < antialiasingSamples; i++)\n    {\n        const float motionBlurLengthInSeconds = 1.0 / 60.0;\n        // Set this to the time in seconds of the frame to render.\n\t    localTime = frameToRenderHQ;\n        // This line will motion-blur the renders\n        localTime += Hash11(v21(fragCoord + seed)) * motionBlurLengthInSeconds;\n        // Jitter the pixel position so we get antialiasing when we do multiple passes.\n        vec2 jittered = fragCoord.xy + vec2(\n            Hash21(fragCoord + seed),\n            Hash21(fragCoord*7.234567 + seed)\n            );\n        // don't antialias if only 1 sample.\n        if (antialiasingSamples == 1.0) jittered = fragCoord;\n        // Accumulate one pass of raytracing into our pixel value\n\t    finalColor += RayTrace(jittered);\n        // Change the random seed for each pass.\n\t    seed *= 1.01234567;\n    }\n    // Average all accumulated pixel intensities\n    finalColor /= antialiasingSamples;\n#else\n    // Regular real-time rendering\n    localTime = iTime;\n    finalColor = RayTrace(fragCoord);\n#endif\n\n    fragColor = vec4(sqrt(clamp(finalColor, 0.0, 1.0)),1.0);\n}\n\n\n",
    "tags": [
      "fractal",
      "space"
    ],
    "author": "otaviogood",
    "views": 0,
    "likes": 266,
    "published": 3
  },
  {
    "id": "XdXGW8",
    "title": "Noise - gradient - 2D",
    "description": "Gradient Noise. Slightly more expensive than \"Value Noise\" ([url]https://www.shadertoy.com/view/lsf3WH[/url]), but higher quality.",
    "code": "// The MIT License\n// Copyright \u00a9 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org\n\n\n// Gradient Noise (http://en.wikipedia.org/wiki/Gradient_noise), not to be confused with\n// Value Noise, and neither with Perlin's Noise (which is one form of Gradient Noise)\n// is probably the most convenient way to generate noise (a random smooth signal with \n// mostly all its energy in the low frequencies) suitable for procedural texturing/shading,\n// modeling and animation.\n//\n// It produces smoother and higher quality than Value Noise, but it's of course slighty more\n// expensive.\n//\n// The princpiple is to create a virtual grid/latice all over the plane, and assign one\n// random vector to every vertex in the grid. When querying/requesting a noise value at\n// an arbitrary point in the plane, the grid cell in which the query is performed is\n// determined, the four vertices of the grid are determined and their random vectors\n// fetched. Then, the position of the current point under  evaluation relative to each\n// vertex is doted (projected) with that vertex' random vector, and the result is\n// bilinearly interpolated with a smooth interpolant.\n\n// All noise functions here:\n//\n// https://www.shadertoy.com/playlist/fXlXzf&from=0&num=12\n\n\n\nvec2 grad( ivec2 z )  // replace this anything that returns a random vector\n{\n    // 2D to 1D  (feel free to replace by some other)\n    int n = z.x+z.y*11111;\n\n    // Hugo Elias hash (feel free to replace by another one)\n    n = (n<<13)^n;\n    n = (n*(n*n*15731+789221)+1376312589)>>16;\n\n#if 0\n\n    // simple random vectors\n    return vec2(cos(float(n)),sin(float(n)));\n    \n#else\n\n    // Perlin style vectors\n    n &= 7;\n    vec2 gr = vec2(n&1,n>>1)*2.0-1.0;\n    return ( n>=6 ) ? vec2(0.0,gr.x) : \n           ( n>=4 ) ? vec2(gr.x,0.0) :\n                              gr;\n#endif                              \n}\n\nfloat noise( in vec2 p )\n{\n    ivec2 i = ivec2(floor( p ));\n     vec2 f =       fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f); // feel free to replace by a quintic smoothstep instead\n\n    return mix( mix( dot( grad( i+ivec2(0,0) ), f-vec2(0.0,0.0) ), \n                     dot( grad( i+ivec2(1,0) ), f-vec2(1.0,0.0) ), u.x),\n                mix( dot( grad( i+ivec2(0,1) ), f-vec2(0.0,1.0) ), \n                     dot( grad( i+ivec2(1,1) ), f-vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// -----------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord / iResolution.xy;\n\n\tvec2 uv = p*vec2(iResolution.x/iResolution.y,1.0) + iTime*0.25;\n\t\n\tfloat f = 0.0;\n\t\n    // left: noise\t\n\tif( p.x<0.6 )\n\t{\n\t\tf = noise( 32.0*uv );\n\t}\n    // right: fractal noise (4 octaves)\n    else\t\n\t{\n\t\tuv *= 8.0;\n        mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\t\tf  = 0.5000*noise( uv ); uv = m*uv;\n\t\tf += 0.2500*noise( uv ); uv = m*uv;\n\t\tf += 0.1250*noise( uv ); uv = m*uv;\n\t\tf += 0.0625*noise( uv ); uv = m*uv;\n\t}\n\tf = 0.5 + 0.5*f;\n\t\n    f *= smoothstep( 0.0, 0.005, abs(p.x-0.6) );\t\n\t\n\tfragColor = vec4( f, f, f, 1.0 );\n}",
    "tags": [
      "procedural",
      "2d",
      "noise",
      "perlin",
      "gradient"
    ],
    "author": "iq",
    "views": 0,
    "likes": 167,
    "published": 3
  },
  {
    "id": "llVXRd",
    "title": "Geodesic tiling",
    "description": "Distributing points on a sphere, without the bunching at the poles you get from spherical coordinates.\n\nMinimal version of the technique: [url]https://www.shadertoy.com/view/llGXWc[/url]",
    "code": "#define MODEL_ROTATION vec2(.3, .25)\n#define CAMERA_ROTATION vec2(.5, .5)\n\n// 0: Defaults\n// 1: Model\n// 2: Camera\n#define MOUSE_CONTROL 1\n\n//#define DEBUG\n\n// 1, 2, or 3\n//#define LOOP 1\n\n\n// --------------------------------------------------------\n// HG_SDF\n// https://www.shadertoy.com/view/Xs3GRB\n// --------------------------------------------------------\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset) {\n    float t = dot(p, planeNormal)+offset;\n    if (t < 0.) {\n        p = p - (2.*t)*planeNormal;\n    }\n    return sign(t);\n}\n\nfloat smax(float a, float b, float r) {\n    float m = max(a, b);\n    if ((-a < r) && (-b < r)) {\n        return max(m, -(r - sqrt((r+a)*(r+a) + (r+b)*(r+b))));\n    } else {\n        return m;\n    }\n}\n\n\n// --------------------------------------------------------\n// Icosahedron domain mirroring\n// Adapted from knighty https://www.shadertoy.com/view/MsKGzw\n// --------------------------------------------------------\n\n#define PI 3.14159265359\n\nvec3 facePlane;\nvec3 uPlane;\nvec3 vPlane;\n\nint Type=5;\nvec3 nc;\nvec3 pab;\nvec3 pbc;\nvec3 pca;\n\nvoid initIcosahedron() {//setup folding planes and vertex\n    float cospin=cos(PI/float(Type)), scospin=sqrt(0.75-cospin*cospin);\n    nc=vec3(-0.5,-cospin,scospin);//3rd folding plane. The two others are xz and yz planes\n    pbc=vec3(scospin,0.,0.5);//No normalization in order to have 'barycentric' coordinates work evenly\n    pca=vec3(0.,scospin,cospin);\n    pbc=normalize(pbc); pca=normalize(pca);//for slightly better DE. In reality it's not necesary to apply normalization :)\n\tpab=vec3(0,0,1);\n    \n    facePlane = pca;\n    uPlane = cross(vec3(1,0,0), facePlane);\n    vPlane = vec3(1,0,0);\n}\n\nvoid pModIcosahedron(inout vec3 p) {\n    p = abs(p);\n    pReflect(p, nc, 0.);\n    p.xy = abs(p.xy);\n    pReflect(p, nc, 0.);\n    p.xy = abs(p.xy);\n    pReflect(p, nc, 0.);\n}\n\n\n// --------------------------------------------------------\n// Triangle tiling\n// Adapted from mattz https://www.shadertoy.com/view/4d2GzV\n// --------------------------------------------------------\n\nconst float sqrt3 = 1.7320508075688772;\nconst float i3 = 0.5773502691896258;\n\nconst mat2 cart2hex = mat2(1, 0, i3, 2. * i3);\nconst mat2 hex2cart = mat2(1, 0, -.5, .5 * sqrt3);\n\n#define PHI (1.618033988749895)\n#define TAU 6.283185307179586\n\nstruct TriPoints {\n\tvec2 a;\n    vec2 b;\n    vec2 c;\n    vec2 center;\n    vec2 ab;\n    vec2 bc;\n    vec2 ca;\n};\n\nTriPoints closestTriPoints(vec2 p) {    \n    vec2 pTri = cart2hex * p;\n    vec2 pi = floor(pTri);\n    vec2 pf = fract(pTri);\n    \n    float split1 = step(pf.y, pf.x);\n    float split2 = step(pf.x, pf.y);\n    \n    vec2 a = vec2(split1, 1);\n    vec2 b = vec2(1, split2);\n    vec2 c = vec2(0, 0);\n\n    a += pi;\n    b += pi;\n    c += pi;\n\n    a = hex2cart * a;\n    b = hex2cart * b;\n    c = hex2cart * c;\n    \n    vec2 center = (a + b + c) / 3.;\n    \n\tvec2 ab = (a + b) / 2.;\n    vec2 bc = (b + c) / 2.;\n    vec2 ca = (c + a) / 2.;\n\n    return TriPoints(a, b, c, center, ab, bc, ca);\n}\n\n\n// --------------------------------------------------------\n// Geodesic tiling\n// --------------------------------------------------------\n\nstruct TriPoints3D {\n\tvec3 a;\n    vec3 b;\n    vec3 c;\n\tvec3 center;\n    vec3 ab;\n    vec3 bc;\n    vec3 ca;\n};\n\nvec3 intersection(vec3 n, vec3 planeNormal, float planeOffset) {\n    float denominator = dot(planeNormal, n);\n    float t = (dot(vec3(0), planeNormal ) + planeOffset) / -denominator;\n    return n * t;\n}\n\n//// Edge length of an icosahedron with an inscribed sphere of radius of 1\n//float edgeLength = 1. / ((sqrt(3.) / 12.) * (3. + sqrt(5.)));\n//// Inner radius of the icosahedron's face\n//float faceRadius = (1./6.) * sqrt(3.) * edgeLength;\nfloat faceRadius = 0.3819660112501051;\n\n// 2D coordinates on the icosahedron face\nvec2 icosahedronFaceCoordinates(vec3 p) {\n    vec3 pn = normalize(p);\n    vec3 i = intersection(pn, facePlane, -1.);\n    return vec2(dot(i, uPlane), dot(i, vPlane));\n}\n\n// Project 2D icosahedron face coordinates onto a sphere\nvec3 faceToSphere(vec2 facePoint) {\n\treturn normalize(facePlane + (uPlane * facePoint.x) + (vPlane * facePoint.y));\n}\n\nTriPoints3D geodesicTriPoints(vec3 p, float subdivisions) {\n    // Get 2D cartesian coordiantes on that face\n    vec2 uv = icosahedronFaceCoordinates(p);\n    \n    // Get points on the nearest triangle tile\n\tfloat uvScale = subdivisions / faceRadius / 2.;\n    TriPoints points = closestTriPoints(uv * uvScale);\n    \n    // Project 2D triangle coordinates onto a sphere \n    vec3 a = faceToSphere(points.a / uvScale);\n    vec3 b = faceToSphere(points.b / uvScale);\n    vec3 c = faceToSphere(points.c / uvScale);\n    vec3 center = faceToSphere(points.center / uvScale);\n    vec3 ab = faceToSphere(points.ab / uvScale);\n    vec3 bc = faceToSphere(points.bc / uvScale);\n    vec3 ca = faceToSphere(points.ca / uvScale);\n    \n    return TriPoints3D(a, b, c, center, ab, bc, ca);\n}\n\n\n// --------------------------------------------------------\n// Spectrum colour palette\n// IQ https://www.shadertoy.com/view/ll2GD3\n// --------------------------------------------------------\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 spectrum(float n) {\n    return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n}\n\n\n// --------------------------------------------------------\n// Model/Camera Rotation\n// --------------------------------------------------------\n\nmat3 sphericalMatrix(float theta, float phi) {\n    float cx = cos(theta);\n    float cy = cos(phi);\n    float sx = sin(theta);\n    float sy = sin(phi);\n    return mat3(\n        cy, -sy * -sx, -sy * cx,\n        0, cx, sx,\n        sy, cy * -sx, cy * cx\n    );\n}\n\nmat3 mouseRotation(bool enable, vec2 xy) {\n    if (enable) {\n        vec2 mouse = iMouse.xy / iResolution.xy;\n\n        if (mouse.x != 0. && mouse.y != 0.) {\n            xy.x = mouse.x;\n            xy.y = mouse.y;\n        }\n    }\n    float rx, ry;\n    \n    rx = (xy.y + .5) * PI;\n    ry = (-xy.x) * 2. * PI;\n    \n    return sphericalMatrix(rx, ry);\n}\n\nmat3 modelRotation() {\n    mat3 m = mouseRotation(MOUSE_CONTROL==1, MODEL_ROTATION);\n    return m;\n}\n\nmat3 cameraRotation() {\n    mat3 m = mouseRotation(MOUSE_CONTROL==2, CAMERA_ROTATION);\n    return m;\n}\n\n\n// --------------------------------------------------------\n// Animation \n// --------------------------------------------------------\n\nconst float SCENE_DURATION = 6.;\nconst float CROSSFADE_DURATION = 2.;\n\nfloat time;\n\nstruct HexSpec {\n    float roundTop;\n    float roundCorner;\n\tfloat height;\n    float thickness;\n    float gap;    \n};\n    \nHexSpec newHexSpec(float subdivisions) {\n\treturn HexSpec(\n        .05 / subdivisions,\n        .1 / subdivisions,\n        2.,\n        2.,\n        .005\n    );\n}\n    \n// Animation 1\n    \nfloat animSubdivisions1() {\n\treturn mix(2.4, 3.4, cos(time * PI) * .5 + .5);\n}\n\nHexSpec animHex1(vec3 hexCenter, float subdivisions) {\n    HexSpec spec = newHexSpec(subdivisions);\n    \n    float offset = time * 3. * PI;\n    offset -= subdivisions;\n    float blend = dot(hexCenter, pca);\n    blend = cos(blend * 30. + offset) * .5 + .5;\n    spec.height = mix(1.75, 2., blend);\n\n    spec.thickness = spec.height;\n\n    return spec;\n}\n\n// Animation 2\n\nfloat animSubdivisions2() {\n    return mix(1., 2.3, sin(time * PI/2.) * .5 + .5);\n}\n\nHexSpec animHex2(vec3 hexCenter, float subdivisions) {\n    HexSpec spec = newHexSpec(subdivisions);\n    \n    float blend = hexCenter.y;\n    spec.height = mix(1.6, 2., sin(blend * 10. + time * PI) * .5 + .5);\n    \n    spec.roundTop = .02 / subdivisions;\n    spec.roundCorner = .09 / subdivisions;\n    spec.thickness = spec.roundTop * 4.;\n    spec.gap = .01;\n\n    return spec;\n}\n\n// Animation 3\n\nfloat animSubdivisions3() {\n\treturn 5.;\n}\n\nHexSpec animHex3(vec3 hexCenter, float subdivisions) {\n    HexSpec spec = newHexSpec(subdivisions);\n    \n    float blend = acos(dot(hexCenter, pab)) * 10.;\n    blend = cos(blend + time * PI) * .5 + .5;\n    spec.gap = mix(.01, .4, blend) / subdivisions;\n\n    spec.thickness = spec.roundTop * 2.;\n\n\treturn spec;\n}\n\n// Transition between animations\n\nfloat sineInOut(float t) {\n  return -0.5 * (cos(PI * t) - 1.0);\n}\n\nfloat transitionValues(float a, float b, float c) {\n    #ifdef LOOP\n        #if LOOP == 1\n            return a;\n        #endif\n        #if LOOP == 2\n            return b;\n        #endif\n        #if LOOP == 3\n            return c;\n        #endif\n    #endif\n    float t = time / SCENE_DURATION;\n    float scene = floor(mod(t, 3.));\n    float blend = fract(t);\n    float delay = (SCENE_DURATION - CROSSFADE_DURATION) / SCENE_DURATION;\n    blend = max(blend - delay, 0.) / (1. - delay);\n    blend = sineInOut(blend);\n    float ab = mix(a, b, blend);\n    float bc = mix(b, c, blend);\n    float cd = mix(c, a, blend);\n    float result = mix(ab, bc, min(scene, 1.));\n    result = mix(result, cd, max(scene - 1., 0.));\n    return result;\n}\n \nHexSpec transitionHexSpecs(HexSpec a, HexSpec b, HexSpec c) {\n    float roundTop = transitionValues(a.roundTop, b.roundTop, c.roundTop);\n    float roundCorner = transitionValues(a.roundCorner, b.roundCorner, c.roundCorner);\n\tfloat height = transitionValues(a.height, b.height, c.height);\n    float thickness = transitionValues(a.thickness, b.thickness, c.thickness);\n    float gap = transitionValues(a.gap, b.gap, c.gap);\n\treturn HexSpec(roundTop, roundCorner, height, thickness, gap);\n}\n\n\n// --------------------------------------------------------\n// Modelling \n// --------------------------------------------------------\n\nconst vec3 FACE_COLOR = vec3(.9,.9,1.);\nconst vec3 BACK_COLOR = vec3(.1,.1,.15);\nconst vec3 BACKGROUND_COLOR = vec3(.0, .005, .03);\n\nstruct Model {\n    float dist;\n    vec3 albedo;\n    float glow;\n};\n\nModel hexModel(\n    vec3 p,\n    vec3 hexCenter,\n    vec3 edgeA,\n    vec3 edgeB,\n    HexSpec spec\n) {\n    float d;\n\n    float edgeADist = dot(p, edgeA) + spec.gap;\n    float edgeBDist = dot(p, edgeB) - spec.gap;\n    float edgeDist = smax(edgeADist, -edgeBDist, spec.roundCorner);\n\n    float outerDist = length(p) - spec.height;\n    d = smax(edgeDist, outerDist, spec.roundTop);\n\n    float innerDist = length(p) - spec.height + spec.thickness;\n    d = smax(d, -innerDist, spec.roundTop);\n    \n    vec3 color;\n\n    float faceBlend = (spec.height - length(p)) / spec.thickness;\n    faceBlend = clamp(faceBlend, 0., 1.);\n    color = mix(FACE_COLOR, BACK_COLOR, step(.5, faceBlend));\n    \n    vec3 edgeColor = spectrum(dot(hexCenter, pca) * 5. + length(p) + .8);    \n\tfloat edgeBlend = smoothstep(-.04, -.005, edgeDist);\n    color = mix(color, edgeColor, edgeBlend); \n\n    return Model(d, color, edgeBlend);\n}\n\n// checks to see which intersection is closer\nModel opU( Model m1, Model m2 ){\n    if (m1.dist < m2.dist) {\n        return m1;\n    } else {\n        return m2;\n    }\n}\n\nModel geodesicModel(vec3 p) {\n\n    pModIcosahedron(p);\n    \n    float subdivisions = transitionValues(\n        animSubdivisions1(),\n        animSubdivisions2(),\n        animSubdivisions3()\n   \t);\n\tTriPoints3D points = geodesicTriPoints(p, subdivisions);\n        \n\tvec3 edgeAB = normalize(cross(points.center, points.ab));\n\tvec3 edgeBC = normalize(cross(points.center, points.bc));\n    vec3 edgeCA = normalize(cross(points.center, points.ca));\n    \n    Model model, part;\n    HexSpec spec;\n\n\tspec = transitionHexSpecs(\n        animHex1(points.b, subdivisions),\n        animHex2(points.b, subdivisions),\n        animHex3(points.b, subdivisions)\n    );\n    part = hexModel(p, points.b, edgeAB, edgeBC, spec);\n    model = part;\n\n\tspec = transitionHexSpecs(\n        animHex1(points.c, subdivisions),\n        animHex2(points.c, subdivisions),\n        animHex3(points.c, subdivisions)\n    );\n    part = hexModel(p, points.c, edgeBC, edgeCA, spec);\n    model = opU(model, part);\n    \n\tspec = transitionHexSpecs(\n        animHex1(points.a, subdivisions),\n        animHex2(points.a, subdivisions),\n        animHex3(points.a, subdivisions)\n    );\n    part = hexModel(p, points.a, edgeCA, edgeAB, spec);\n    model = opU(model, part);\n    \n\treturn model;\n}\n\nModel map( vec3 p ){\n    mat3 m = modelRotation();\n    p *= m;  \n    #ifndef LOOP\n    \tpR(p.xz, time * PI/16.);\n    #endif\n    Model model = geodesicModel(p);\n    return model;\n}\n\n// --------------------------------------------------------\n// LIGHTING\n// Adapted from IQ https://www.shadertoy.com/view/Xds3zN\n// --------------------------------------------------------\n\nvec3 doLighting(Model model, vec3 pos, vec3 nor, vec3 ref, vec3 rd) {\n    vec3 lightPos = normalize(vec3(.5,.5,-1.));\n    vec3 backLightPos = normalize(vec3(-.5,-.3,1));\n    vec3 ambientPos = vec3(0,1,0);\n    \n    vec3  lig = lightPos;\n    float amb = clamp((dot(nor, ambientPos) + 1.) / 2., 0., 1.);\n    float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n    float bac = pow(clamp(dot(nor, backLightPos), 0., 1.), 1.5);\n    float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n    \n    vec3 lin = vec3(0.0);\n    lin += 1.20 * dif * vec3(.9);\n    lin += 0.80 * amb * vec3(.5, .7, .8);\n    lin += 0.30 * bac * vec3(.25);\n    lin += 0.20 * fre * vec3(1);\n    \n    vec3 albedo = model.albedo;\n    vec3 col = mix(albedo * lin, albedo, model.glow);    \n\n    return col;\n}   \n\n\n// --------------------------------------------------------\n// Ray Marching\n// Adapted from cabbibo https://www.shadertoy.com/view/Xl2XWt\n// --------------------------------------------------------\n\nconst float MAX_TRACE_DISTANCE = 8.; // max trace distance\nconst float INTERSECTION_PRECISION = .001; // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 100;\nconst float FUDGE_FACTOR = .9; // Default is 1, reduce to fix overshoots\n\nstruct CastRay {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n    float len;\n};\n\nstruct Hit {\n    Ray ray;\n    Model model;\n    vec3 pos;\n    bool isBackground;\n    vec3 normal;\n    vec3 color;\n};\n\nvec3 calcNormal( in vec3 pos ){\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy).dist - map(pos-eps.xyy).dist,\n        map(pos+eps.yxy).dist - map(pos-eps.yxy).dist,\n        map(pos+eps.yyx).dist - map(pos-eps.yyx).dist );\n    return normalize(nor);\n}\n    \nHit raymarch(CastRay castRay){\n\n    float currentDist = INTERSECTION_PRECISION * 2.0;\n    Model model;\n    \n    Ray ray = Ray(castRay.origin, castRay.direction, 0.);\n\n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        if (currentDist < INTERSECTION_PRECISION || ray.len > MAX_TRACE_DISTANCE) {\n            break;\n        }\n        model = map(ray.origin + ray.direction * ray.len);\n        currentDist = model.dist;\n        ray.len += currentDist * FUDGE_FACTOR;\n    }\n    \n    bool isBackground = false;\n    vec3 pos = vec3(0);\n    vec3 normal = vec3(0);\n    vec3 color = vec3(0);\n    \n    if (ray.len > MAX_TRACE_DISTANCE) {\n        isBackground = true;\n    } else {\n        pos = ray.origin + ray.direction * ray.len;\n        normal = calcNormal(pos);\n    }\n\n    return Hit(ray, model, pos, isBackground, normal, color);\n}\n\n\n// --------------------------------------------------------\n// Rendering\n// --------------------------------------------------------\n\nvoid shadeSurface(inout Hit hit){\n    \n    vec3 color = BACKGROUND_COLOR;\n    \n    if (hit.isBackground) {\n        hit.color = color;\n        return;\n    }\n\n    vec3 ref = reflect(hit.ray.direction, hit.normal);\n\n    #ifdef DEBUG\n        color = hit.normal * 0.5 + 0.5;\n    #else \n        color = doLighting(\n            hit.model,\n            hit.pos,\n            hit.normal,\n            ref,\n            hit.ray.direction\n        );\n    #endif\n\n    hit.color = color;\n}\n\nvec3 render(Hit hit){\n    shadeSurface(hit);\n\treturn hit.color;\n}\n\n\n// --------------------------------------------------------\n// Camera\n// https://www.shadertoy.com/view/Xl2XWt\n// --------------------------------------------------------\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera(out vec3 camPos, out vec3 camTar, out float camRoll, in float time, in vec2 mouse) {\n    float dist = 5.5;\n    camRoll = 0.;\n    camTar = vec3(0,0,0);\n    camPos = vec3(0,0,-dist);\n    camPos *= cameraRotation();\n    camPos += camTar;\n}\n\n\n// --------------------------------------------------------\n// Gamma\n// https://www.shadertoy.com/view/Xds3zN\n// --------------------------------------------------------\n\nconst float GAMMA = 2.2;\n\nvec3 gamma(vec3 color, float g) {\n    return pow(color, vec3(g));\n}\n\nvec3 linearToScreen(vec3 linearRGB) {\n    return gamma(linearRGB, 1.0 / GAMMA);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = iTime;\n\n    #ifdef LOOP\n        #if LOOP == 1\n            time = mod(time, 2.);   \n        #endif\n        #if LOOP == 2\n            time = mod(time, 4.);   \n        #endif\n        #if LOOP == 3\n            time = mod(time, 2.);\n    \t#endif\n    #endif\n    \n    initIcosahedron();\n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    vec3 camPos = vec3( 0., 0., 2.);\n    vec3 camTar = vec3( 0. , 0. , 0. );\n    float camRoll = 0.;\n    \n    // camera movement\n    doCamera(camPos, camTar, camRoll, iTime, m);\n    \n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( camPos, camTar, camRoll );  // 0.0 is the camera roll\n    \n    // create view ray\n    vec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n    \n    Hit hit = raymarch(CastRay(camPos, rd));\n\n    vec3 color = render(hit);\n    \n    #ifndef DEBUG\n        color = linearToScreen(color);\n    #endif\n\n    fragColor = vec4(color,1.0);\n}",
    "tags": [
      "sphere",
      "hexagon",
      "tile",
      "geodesic"
    ],
    "author": "tdhooper",
    "views": 0,
    "likes": 559,
    "published": 3
  },
  {
    "id": "XlSGzz",
    "title": "yuan",
    "description": "yuan",
    "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tvec2 p = (2.*fragCoord.xy-iResolution.xy) / iResolution.y; \n\n    float a = atan(p.x,p.y);\n    float r = length(p);\n    vec2 uv = vec2(0.0,r);\n\n\tuv = (2.0 * uv) -1.0;     \n    float beamWidth = abs(5.0 / (40.0 * uv.y));\n\n    \n    \n    \n\n    if(abs(uv.y)>=1.0)\n    {\n    \n   \t  // fragColor=vec4(0.0,0.5,0.0,1.0);\n      //  return;\n    }\n    \n\tvec3 horBeam = vec3(beamWidth);\n\t\n\tfragColor = vec4( horBeam , 1.0);\n    //fragColor = vec4( 5. / (40. * abs(2.*length(p)-1.) ) );\n\n    \n  \n}",
    "tags": [
      "cineshader"
    ],
    "author": "playertk",
    "views": 0,
    "likes": 64,
    "published": 3
  },
  {
    "id": "WlcyD7",
    "title": "TIE Fighters",
    "description": "It was a fine line between creating a scene with\nTIE Fighters or X-Wings. TIE Fighters won.\n\nScene duration: 40 secs",
    "code": "// 'TIE Fighters' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/WlcyD7\n//\n// Processed by 'GLSL Shader Shrinker'\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n//\n// It was a fine line between creating a scene with\n// TIE Fighters or X-Wings. TIE Fighters won.\n// I'm quite happy with the modelling in this one,\n// but definitely want to practice terrains some more.\n//\n// I've switched to using hash functions which don't\n// rely on trig functions. Hopefully that will reduce\n// differences on different platforms...\n//\n// Tricks to get the performance:\n//  - The TIE SDF code bails early if the raymarching point\n//    is 'too far away', so no time wasted calculating the SDF\n//    of all the fine details when not necessary.\n//    See sdTie()\n//  - Shadows are only cast by the TIEs (See calcShadow())\n//    so I don't have to render the entire scene too many times.\n//  - The ray is only reflected if it hits glass or metal, and then\n//    marched only if it points down. (So we don't reflect the sky.)\n//  - I have two normal-calculating functions. One for the TIEs,\n//    and one for the terrain. Once the ray has hit an object,\n//    the relevant 'normal' code is called.\n//  - The high frequency noise is added to the terrain during the\n//    color look-up phase. Only the low frequency noise is added to\n//    the SDF.\n//\n// Things I _could_ do:\n//  - Split the TIE modelling into two functions, one for just\n//    the wings and cockpit, and another which extends it to\n//    include the finer details.\n//    The 'simple' version could be used to generate the shadows.\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane\n// and a bunch of others for sharing their knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat T, g;\nstruct Hit {\n\tfloat d;\n\tint id;\n\tvec3 uv;\n};\n\n// Thanks Dave Hoskins - https://www.shadertoy.com/view/4djSRW\nvec4 hash44(vec4 p4) {\n\tp4 = fract(p4 * vec4(.1031, .103, .0973, .1099));\n\tp4 += dot(p4, p4.wzxy + 33.33);\n\treturn fract((p4.xxyz + p4.yzzw) * p4.zywx);\n}\n\n// Thanks Shane - https://www.shadertoy.com/view/lstGRB\nfloat n31(vec3 p) {\n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p);\n\tp = fract(p);\n\tp = p * p * (3. - 2. * p);\n\tvec4 h = vec4(0, s.yz, s.y + s.z) + dot(ip, s);\n\th = mix(hash44(h), hash44(h + s.x), p.x);\n\th.xy = mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\nvoid minH(inout Hit a, Hit b) { if (b.d < a.d) a = b; }\n\nmat2 rot(float a) {\n\tfloat c = cos(a),\n\t      s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nvec2 opModPolar(vec2 p, float n, float o) {\n\tfloat angle = 3.141 / n,\n\t      a = mod(atan(p.y, p.x) + angle + o, 2. * angle) - angle;\n\treturn length(p) * vec2(cos(a), sin(a));\n}\n\nfloat sdHex(vec3 p, vec2 h) {\n\tconst vec3 k = vec3(-.866, .5, .577);\n\tp = abs(p);\n\tp.xy -= 2. * min(dot(k.xy, p.xy), 0.) * k.xy;\n\tvec2 d = vec2(length(p.xy - vec2(clamp(p.x, -k.z * h.x, k.z * h.x), h.x)) * sign(p.y - h.x), p.z - h.y);\n\treturn min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\nfloat sdPlane(vec3 p, vec3 n) { return dot(p, n); }\n\nfloat dot2(vec3 a) { return dot(a, a); }\n\nfloat sdTri(vec3 p, vec3 a, vec3 b, vec3 c) {\n\tvec3 ba = b - a,\n\t     pa = p - a,\n\t     cb = c - b,\n\t     pb = p - b,\n\t     ac = a - c,\n\t     pc = p - c,\n\t     n = cross(ba, ac);\n\treturn sqrt((sign(dot(cross(ba, n), pa)) + sign(dot(cross(cb, n), pb)) + sign(dot(cross(ac, n), pc)) < 2.) ? min(min(dot2(ba * clamp(dot(ba, pa) / dot2(ba), 0., 1.) - pa), dot2(cb * clamp(dot(cb, pb) / dot2(cb), 0., 1.) - pb)), dot2(ac * clamp(dot(ac, pc) / dot2(ac), 0., 1.) - pc)) : dot(n, pa) * dot(n, pa) / dot2(n));\n}\n\nfloat sdCyl(vec3 p, vec2 hr) {\n\tvec2 d = abs(vec2(length(p.xy), p.z)) - hr;\n\treturn min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n\tvec3 f = normalize(lookAt - ro),\n\t     r = normalize(cross(vec3(0, 1, 0), f));\n\treturn normalize(f + r * uv.x + cross(f, r) * uv.y);\n}\n\nHit sdWings(vec3 p) {\n\tp.xy = abs(p.xy);\n\tp.z = abs(p.z) - 2.3;\n\treturn Hit(min(sdTri(p, vec3(0), vec3(2, 3, 0), vec3(-2, 3, 0)), sdTri(p, vec3(0), vec3(3.3, 0, 0), vec3(2, 3, 0))) - .03, 2, p);\n}\n\nHit sdTie(vec3 p) {\n\tp = p.zyx - vec3(10, 0, 0);\n\n\t// Wings.\n\tHit h = sdWings(p);\n\tif (h.d > 2.5) return h; // Bail early - Point is too far away.\n\t// Wing ribs.\n\tvec3 op = p;\n\tp.xy = abs(p.xy);\n\tp.z = abs(p.z) - 2.3;\n\tfloat f,\n\t      d = 0.;\n\tif ((f = abs(p.y)) < .1) d = .03 + step(f, .025) * .02;\n\telse if ((f = abs(p.y - p.x * 1.5)) < .15) d = .03 + step(f, .025) * .02;\n\telse if (abs(p.y - 3.) < .1) d = .03;\n\telse if (abs(p.x - 3.3 + p.y * .43) < .1) d = .03;\n\n\tif (d > 0.) {\n\t\th.d -= d;\n\t\th.id = 1;\n\t}\n\n\t// Wing center hexes.\n\td = min(sdHex(p, vec2(.7, .06)), sdHex(p, vec2(.5, .12)));\n\n\t// Crossbar.\n\td = min(d, sdCyl(op, vec2(mix(.21, .23, step(p.y, .04)), 2.3))); // Main bar\n\tp.z = abs(p.z + .8) - .5;\n\tf = sdCyl(p, vec2(mix(.21, .33, (p.z + .33) / .48), .24));\n\tp.x -= .25;\n\tp.z += .02;\n\td = min(d, max(f, -sdBox(p, vec3(.1, .4, .08)))); // Join to wing/cockpit.\n\tp = op;\n\tp.yz = abs(p.yz);\n\tminH(h, Hit(min(d, sdTri(p, vec3(0), vec3(0, .8, 0), vec3(0, 0, 2)) - .05), 1, p)); // Triangle cockpit supports.\n\t// Cockpit - Sphere.\n\tf = step(.75, p.y);\n\tminH(h, Hit(length(op) - .9 - .02 * (f + step(p.y, .03) + f * step(p.z, .1)), 6, p));\n\n\t// Cockpit - Glass.\n\tp = op;\n\tp.x += .27;\n\tp.yz = opModPolar(p.yz, 8., .4);\n\tminH(h, Hit(max(length(p) - .7, sdPlane(p + vec3(.77, 0, 0), vec3(vec2(-1, 0) * rot(.5), 0))), 3, p));\n\n\t// Cockpit - Window frame.\n\tminH(h, Hit(max(length(p) - .71, .45 - length(p.yz)), 5, p));\n\n\t// Gunz.\n\tp = op;\n\tp.x += .7;\n\tp.y += .6;\n\tp.z = abs(p.z) - .2;\n\tminH(h, Hit(sdCyl(p.zyx, vec2(.05, .2)), 7, p));\n\treturn h;\n}\n\n// Position of the lead TIE.\nvec3 tiePos(vec3 p, float t) {\n\tfloat x = cos(t * .7);\n\tp += vec3(x, cos(t), sin(t * 1.1));\n\tp.xy *= rot(x * -.1);\n\treturn p;\n}\n\nHit sdTies(vec3 p) {\n\tvec3 op = p;\n\n\t// Front tie.\n\tp = tiePos(p, T);\n\tHit h = sdTie(p);\n\tif (sin(T) - step(T, 0.) * 10. > -.7) {\n\t\t// Weapon fire.\n\t\tp.x = abs(p.x) - .2;\n\t\tp.y += .6;\n\t\tp.z = mod(p.z + T * 50., 8.) - 4.;\n\t\tfloat x = max(sdCyl(p, vec2(.03, 1)), op.z - 8.);\n\t\tminH(h, Hit(x, 9, p));\n\t\tg += .001 / (.01 + x * x);\n\t}\n\n\t// Rear tie.\n\tif (h.d > .0015) {\n\t\tfloat x = -cos(T);\n\t\tp = op + vec3(14, -4. - .5 * cos(T * .5), -20. + 4. * sin(T * .6));\n\t\tp.xy *= rot(x * -.1);\n\t\tminH(h, sdTie(p));\n\t}\n\n\treturn h;\n}\n\nHit sdTerrain(vec3 p) {\n\tp.z -= T * 7e2; // Number controls the terrain speed.\n\tvec2 d = sin(p.xz * vec2(.01476, .01345)) * 10. + sin(p.xz * vec2(.05212, .04512)) * 2.;\n\treturn Hit(abs(p.y - d.x + d.y + 25.), 4, p);\n}\n\nHit map(vec3 p) {\n\tHit h = sdTerrain(p);\n\tminH(h, sdTies(p));\n\treturn h;\n}\n\nvec3 calcN(vec3 p, float t) {\n\tfloat h = t * .2;\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3((((i + 3) >> 1) & 1), (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * sdTies(p + e * h).d;\n\t}\n\n\treturn normalize(n);\n}\n\n// Terrian normal.\n// (Special case, but faster than using the SDF for the entire scene.)\nvec3 calcTN(vec3 p, float t) {\n\tfloat h = t * 2.;\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3((((i + 3) >> 1) & 1), (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * sdTerrain(p + e * h).d;\n\t}\n\n\treturn normalize(n);\n}\n\n// Note: For performance, shadows are only cast by tie fighters.\nfloat calcShadow(vec3 p, vec3 ld) {\n\t// Thanks iq.\n\tfloat s = 1.,\n\t      t = 1.;\n\tfor (float i = 0.; i < 30.; i++) {\n\t\tfloat h = sdTies(p + ld * t).d;\n\t\ts = min(s, 30. * h / t);\n\t\tt += h;\n\t\tif (s < .001 || t > 1e2) break;\n\t}\n\n\treturn clamp(s, 0., 1.);\n}\n\n// Note: For performance, occlusion only applied to tie fighters.\nfloat ao(vec3 p, vec3 n, float h) { return clamp(sdTies(p + h * n).d / h, 0., 1.); }\n\n// Sub-surface scattering (Applied to the snow).\n#define SSS(h)\tclamp(sdTerrain(p + ld * h).d / h, 0., 1.)\n\n/**********************************************************************************/\nvec3 vignette(vec3 c, vec2 fc) {\n\tvec2 q = fc.xy / iResolution.xy;\n\tc *= .5 + .5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .4);\n\treturn c;\n}\n\nvec3 lights(vec3 p, vec3 rd, float d, Hit h) {\n\tfloat am, ldt, l, spe,\n\t      sped = 4.;\n\tvec3 c, n, lig,\n\t     ld = normalize(vec3(30, 50, -40) - p);\n\tif (h.id == 4) {\n\t\t// Snow\n\t\tc = vec3(1.2 + SSS(1.) * .44);\n\t\tn = normalize(calcTN(p, d) + n31(h.uv) * .1);\n\t\tam = mix(.3, .9, sdTerrain(p + n).d);\n\t\tsped = .4;\n\t}\n\telse {\n\t\tn = calcN(p, d);\n\t\tam = mix(ao(p, n, .5), ao(p, n, 1.2), .75);\n\t\tif (h.id == 1 || h.id == 6) {\n\t\t\t// Metal\n\t\t\tc = vec3(.3 - n31(h.uv * 18.7) * .1);\n\t\t\tsped = .5;\n\t\t\tif (h.id == 6) c *= 1. - .8 * step(abs(atan(h.uv.y, h.uv.z) - .8), .01); // Cockpit.\n\t\t}\n\t\telse if (h.id == 2) {\n\t\t\t// Black wing area.\n\t\t\tif (h.uv.x < h.uv.y * .7) h.uv.y = 0.;\n\t\t\tc = vec3(.005 + .045 * pow(abs(sin((h.uv.x - h.uv.y) * 12.)), 20.));\n\t\t\tsped = .2;\n\t\t}\n\t\telse if (h.id == 7) {\n\t\t\t// Gunz.\n\t\t\tc = vec3(.02);\n\t\t\tsped = .2;\n\t\t}\n\t\telse if (h.id == 3) c = vec3(.05); // Cockpit glass.\n\t\telse if (h.id == 5) c = vec3(.1); // Glass surround.\n\t\telse c = vec3(.3, 1, .3); // Fire!\n\t}\n\n\t// Primary light.\n\tldt = dot(ld, n);\n\tl = max(0., .2 + .8 * ldt) + max(0., .2 - .8 * ldt) * .3;\n\tspe = smoothstep(0., 1., pow(max(0., dot(rd, reflect(ld, n))), 50.)) * sped;\n\n\t// Combine.\n\tlig = l * am * mix(.4, 1., calcShadow(p, ld)) * vec3(2, 1.8, 1.7) + clamp(n.y, .05, 1.) * vec3(.9, .95, 1); // Sky light.\n\treturn c * lig + spe;\n}\n\nvec3 march(vec3 ro, vec3 rd) {\n\t// Raymarch.\n\tvec3 p, c;\n\tfloat gg,\n\t      d = .01;\n\tHit h;\n\tfor (float i = 0.; i < 120.; i++) {\n\t\tp = ro + rd * d;\n\t\th = map(p);\n\t\tif (abs(h.d) < .0015 || d > 6e2) break;\n\t\td += h.d; // No hit, so keep marching.\n\t}\n\n\tgg = g; // Cache the 'glow'.\n\tif (d > 6e2) c = vec3(.85, .9, 1);\n\telse c = mix(lights(p, rd, d, h), vec3(1), smoothstep(2e2, 540., d));\n\n\tc += gg * vec3(0, 1, 0);\n\tif (h.id == 3 || h.id == 1) {\n\t\t// Reflections applied to cockpit glass and tie metal.\n\t\trd = reflect(rd, calcN(p, d));\n\t\tfloat alpha = (h.id == 3 ? .4 : .2) * smoothstep(0., 1., -rd.y);\n\t\tif (alpha < .001) return c; // Only reflect downwards.\n\t\td = .01;\n\t\tro = p;\n\t\tfor (float i = 0.; i < 40.; i++) {\n\t\t\tp = ro + rd * d;\n\t\t\th = sdTerrain(p);\n\t\t\tif (abs(h.d) < .0015 || d > 3e2) break;\n\t\t\td += h.d; // No hit, so keep marching.\n\t\t}\n\n\t\t// Combine a % of the reflected color.\n\t\tc = mix(c, d > 3e2 ? vec3(1) : lights(p, rd, d, h), alpha);\n\t}\n\n\treturn c;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc) {\n\tT = mod(iTime, 40.) - 4.;\n\tg = 0.;\n\tfloat t = smoothstep(0., 5., T);\n\tvec3 lookAt = mix(vec3(0, 0, 6) - tiePos(vec3(0), T - .2), vec3(2.5, 0, 0), t),\n\t     ro = mix(lookAt - vec3(0, 0, 1), vec3(4. + cos(T), sin(T) * .2, -8. + cos(T * .2) * 6.), t);\n\tfragColor = vec4(vignette(pow(march(ro, getRayDir(ro, lookAt, (fc - .5 * iResolution.xy) / iResolution.y)), vec3(.45)), fc), 0);\n}",
    "tags": [
      "3d",
      "raymarching",
      "snow",
      "starwars",
      "disney",
      "movie",
      "cineshader"
    ],
    "author": "dean_the_coder",
    "views": 0,
    "likes": 90,
    "published": 3
  },
  {
    "id": "Msj3zD",
    "title": "Super Mario Bros.",
    "description": "Mario jumping dynamically through a random level! How does Mario retain his jumping speed if shaders here are not supposed to know past frames? Would have done more sprites (bushes, clouds, enemies), but it's already really heavy to compile as it is...",
    "code": "// Super Mario Bros. by HLorenzi\n\n// If it does not run at 60 FPS,\n// try pausing/turning off the music!\n\n// Uncomment for totally random level!\n// Just to show off Mario's dynamic movements :P\n//#define TOTALLY_RANDOM_LEVEL 1\n\n\t\n// Positions to start and end Mario simulation (relative to screen position)\n// You can try changing these! (the difference between the two should be a multiple of 4)\n// Put startX too close to endX, and Mario'll experience jittering!\n#define startX  0.0\n#define endX   80.0\n\n\n\n\n\n\n\n#define RGB(r,g,b) vec4(float(r)/255.0,float(g)/255.0,float(b)/255.0,1.0)\n\n#define SPRROW(x,a,b,c,d,e,f,g,h, i,j,k,l,m,n,o,p) (x <= 7 ? SPRROW_H(a,b,c,d,e,f,g,h) : SPRROW_H(i,j,k,l,m,n,o,p))\n#define SPRROW_H(a,b,c,d,e,f,g,h) (a+4.0*(b+4.0*(c+4.0*(d+4.0*(e+4.0*(f+4.0*(g+4.0*(h))))))))\n#define SECROW(x,a,b,c,d,e,f,g,h) (x <= 3 ? SECROW_H(a,b,c,d) : SECROW_H(e,f,g,h))\n#define SECROW_H(a,b,c,d) (a+8.0*(b+8.0*(c+8.0*(d))))\n#define SELECT(x,i) mod(floor(i/pow(4.0,float(x))),4.0)\n#define SELECTSEC(x,i) mod(floor(i/pow(8.0,float(x))),8.0)\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec4 sprGround(int x, int y)\n{\n\tfloat col = 0.0;\n\tif (y == 15) col = SPRROW(x,1.,0.,0.,0.,0.,0.,0.,0., 0.,2.,1.,0.,0.,0.,0.,1.);\n\tif (y == 14) col = SPRROW(x,0.,1.,1.,1.,1.,1.,1.,1., 1.,2.,0.,1.,1.,1.,1.,2.);\n\tif (y == 13) col = SPRROW(x,0.,1.,1.,1.,1.,1.,1.,1., 1.,2.,0.,1.,1.,1.,1.,2.);\n\tif (y == 12) col = SPRROW(x,0.,1.,1.,1.,1.,1.,1.,1., 1.,2.,0.,1.,1.,1.,1.,2.);\n\tif (y == 11) col = SPRROW(x,0.,1.,1.,1.,1.,1.,1.,1., 1.,2.,0.,2.,1.,1.,1.,2.);\n\tif (y == 10) col = SPRROW(x,0.,1.,1.,1.,1.,1.,1.,1., 1.,2.,1.,2.,2.,2.,2.,1.);\n\tif (y ==  9) col = SPRROW(x,0.,1.,1.,1.,1.,1.,1.,1., 1.,2.,0.,0.,0.,0.,0.,2.);\n\tif (y ==  8) col = SPRROW(x,0.,1.,1.,1.,1.,1.,1.,1., 1.,2.,0.,1.,1.,1.,1.,2.);\n\t\n\tif (y ==  7) col = SPRROW(x,0.,1.,1.,1.,1.,1.,1.,1., 1.,2.,0.,1.,1.,1.,1.,2.);\n\tif (y ==  6) col = SPRROW(x,0.,1.,1.,1.,1.,1.,1.,1., 1.,2.,0.,1.,1.,1.,1.,2.);\n\tif (y ==  5) col = SPRROW(x,2.,2.,1.,1.,1.,1.,1.,1., 2.,0.,1.,1.,1.,1.,1.,2.);\n\tif (y ==  4) col = SPRROW(x,0.,0.,2.,2.,1.,1.,1.,1., 2.,0.,1.,1.,1.,1.,1.,2.);\n\tif (y ==  3) col = SPRROW(x,0.,1.,0.,0.,2.,2.,2.,2., 0.,1.,1.,1.,1.,1.,1.,2.);\n\tif (y ==  2) col = SPRROW(x,0.,1.,1.,1.,0.,0.,0.,2., 0.,1.,1.,1.,1.,1.,1.,2.);\n\tif (y ==  1) col = SPRROW(x,0.,1.,1.,1.,1.,1.,1.,2., 0.,1.,1.,1.,1.,1.,2.,2.);\n\tif (y ==  0) col = SPRROW(x,1.,2.,2.,2.,2.,2.,2.,1., 0.,2.,2.,2.,2.,2.,2.,1.);\n\t\n\tcol = SELECT(mod(float(x),8.0),col);\n\tif (col == 0.0) return RGB(247,214,181);\n\tif (col == 1.0) return RGB(231,90,16);\n\treturn RGB(0,0,0);\n}\n\nvec4 sprQuestionBlock(int x, int y)\n{\n\tfloat col = 0.0;\n\tif (y == 15) col = SPRROW(x,3.,0.,0.,0.,0.,0.,0.,0., 0.,0.,0.,0.,0.,0.,0.,3.);\n\tif (y == 14) col = SPRROW(x,0.,1.,1.,1.,1.,1.,1.,1., 1.,1.,1.,1.,1.,1.,1.,2.);\n\tif (y == 13) col = SPRROW(x,0.,1.,2.,1.,1.,1.,1.,1., 1.,1.,1.,1.,1.,2.,1.,2.);\n\tif (y == 12) col = SPRROW(x,0.,1.,1.,1.,1.,0.,0.,0., 0.,0.,1.,1.,1.,1.,1.,2.);\n\tif (y == 11) col = SPRROW(x,0.,1.,1.,1.,0.,0.,2.,2., 2.,0.,0.,1.,1.,1.,1.,2.);\n\tif (y == 10) col = SPRROW(x,0.,1.,1.,1.,0.,0.,2.,1., 1.,0.,0.,2.,1.,1.,1.,2.);\n\tif (y ==  9) col = SPRROW(x,0.,1.,1.,1.,0.,0.,2.,1., 1.,0.,0.,2.,1.,1.,1.,2.);\n\tif (y ==  8) col = SPRROW(x,0.,1.,1.,1.,1.,2.,2.,1., 0.,0.,0.,2.,1.,1.,1.,2.);\n\t\n\tif (y ==  7) col = SPRROW(x,0.,1.,1.,1.,1.,1.,1.,0., 0.,2.,2.,2.,1.,1.,1.,2.);\n\tif (y ==  6) col = SPRROW(x,0.,1.,1.,1.,1.,1.,1.,0., 0.,2.,1.,1.,1.,1.,1.,2.);\n\tif (y ==  5) col = SPRROW(x,0.,1.,1.,1.,1.,1.,1.,1., 2.,2.,1.,1.,1.,1.,1.,2.);\n\tif (y ==  4) col = SPRROW(x,0.,1.,1.,1.,1.,1.,1.,0., 0.,0.,1.,1.,1.,1.,1.,2.);\n\tif (y ==  3) col = SPRROW(x,0.,1.,1.,1.,1.,1.,1.,0., 0.,2.,1.,1.,1.,1.,1.,2.);\n\tif (y ==  2) col = SPRROW(x,0.,1.,2.,1.,1.,1.,1.,1., 2.,2.,1.,1.,1.,2.,1.,2.);\n\tif (y ==  1) col = SPRROW(x,0.,1.,1.,1.,1.,1.,1.,1., 1.,1.,1.,1.,1.,1.,1.,2.);\n\tif (y ==  0) col = SPRROW(x,2.,2.,2.,2.,2.,2.,2.,2., 2.,2.,2.,2.,2.,2.,2.,2.);\n\t\n\tif (y < 0 || y > 15) return RGB(107,140,255);\n\t\n\tcol = SELECT(mod(float(x),8.0),col);\n\tif (col == 0.0) return RGB(231,90,16);\n\tif (col == 1.0) return RGB(255,165,66);\n\tif (col == 2.0) return RGB(0,0,0);\n\treturn RGB(107,140,255);\n}\n\nvec4 sprUsedBlock(int x, int y)\n{\n\tfloat col = 0.0;\n\tif (y == 15) col = SPRROW(x,3.,0.,0.,0.,0.,0.,0.,0., 0.,0.,0.,0.,0.,0.,0.,3.);\n\tif (y == 14) col = SPRROW(x,0.,1.,1.,1.,1.,1.,1.,1., 1.,1.,1.,1.,1.,1.,1.,0.);\n\tif (y == 13) col = SPRROW(x,0.,1.,0.,1.,1.,1.,1.,1., 1.,1.,1.,1.,1.,0.,1.,0.);\n\tif (y == 12) col = SPRROW(x,0.,1.,1.,1.,1.,1.,1.,1., 1.,1.,1.,1.,1.,1.,1.,0.);\n\tif (y == 11) col = SPRROW(x,0.,1.,1.,1.,1.,1.,1.,1., 1.,1.,1.,1.,1.,1.,1.,0.);\n\tif (y == 10) col = SPRROW(x,0.,1.,1.,1.,1.,1.,1.,1., 1.,1.,1.,1.,1.,1.,1.,0.);\n\tif (y ==  9) col = SPRROW(x,0.,1.,1.,1.,1.,1.,1.,1., 1.,1.,1.,1.,1.,1.,1.,0.);\n\tif (y ==  8) col = SPRROW(x,0.,1.,1.,1.,1.,1.,1.,1., 1.,1.,1.,1.,1.,1.,1.,0.);\n\t\n\tif (y ==  7) col = SPRROW(x,0.,1.,1.,1.,1.,1.,1.,1., 1.,1.,1.,1.,1.,1.,1.,0.);\n\tif (y ==  6) col = SPRROW(x,0.,1.,1.,1.,1.,1.,1.,1., 1.,1.,1.,1.,1.,1.,1.,0.);\n\tif (y ==  5) col = SPRROW(x,0.,1.,1.,1.,1.,1.,1.,1., 1.,1.,1.,1.,1.,1.,1.,0.);\n\tif (y ==  4) col = SPRROW(x,0.,1.,1.,1.,1.,1.,1.,1., 1.,1.,1.,1.,1.,1.,1.,0.);\n\tif (y ==  3) col = SPRROW(x,0.,1.,1.,1.,1.,1.,1.,1., 1.,1.,1.,1.,1.,1.,1.,0.);\n\tif (y ==  2) col = SPRROW(x,0.,1.,0.,1.,1.,1.,1.,1., 1.,1.,1.,1.,1.,0.,1.,0.);\n\tif (y ==  1) col = SPRROW(x,0.,1.,1.,1.,1.,1.,1.,1., 1.,1.,1.,1.,1.,1.,1.,0.);\n\tif (y ==  0) col = SPRROW(x,3.,0.,0.,0.,0.,0.,0.,0., 0.,0.,0.,0.,0.,0.,0.,3.);\n\t\n\tif (y < 0 || y > 15) return RGB(107,140,255);\n\t\n\tcol = SELECT(mod(float(x),8.0),col);\n\tif (col == 0.0) return RGB(0,0,0);\n\tif (col == 1.0) return RGB(231,90,16);\n\treturn RGB(107,140,255);\n}\n\nvec4 sprMarioJump(int x, int y)\n{\n\tfloat col = 0.0;\n\tif (y == 15) col = SPRROW(x,0.,0.,0.,0.,0.,0.,0.,0., 0.,0.,0.,0.,0.,2.,2.,2.);\n\tif (y == 14) col = SPRROW(x,0.,0.,0.,0.,0.,0.,1.,1., 1.,1.,1.,0.,0.,2.,2.,2.);\n\tif (y == 13) col = SPRROW(x,0.,0.,0.,0.,0.,1.,1.,1., 1.,1.,1.,1.,1.,1.,2.,2.);\n\tif (y == 12) col = SPRROW(x,0.,0.,0.,0.,0.,3.,3.,3., 2.,2.,3.,2.,0.,3.,3.,3.);\n\tif (y == 11) col = SPRROW(x,0.,0.,0.,0.,3.,2.,3.,2., 2.,2.,3.,2.,2.,3.,3.,3.);\n\tif (y == 10) col = SPRROW(x,0.,0.,0.,0.,3.,2.,3.,3., 2.,2.,2.,3.,2.,2.,2.,3.);\n\tif (y ==  9) col = SPRROW(x,0.,0.,0.,0.,3.,3.,2.,2., 2.,2.,3.,3.,3.,3.,3.,0.);\n\tif (y ==  8) col = SPRROW(x,0.,0.,0.,0.,0.,0.,2.,2., 2.,2.,2.,2.,2.,3.,0.,0.);\n\t\n\tif (y ==  7) col = SPRROW(x,0.,0.,3.,3.,3.,3.,3.,1., 3.,3.,3.,1.,3.,0.,0.,0.);\n\tif (y ==  6) col = SPRROW(x,0.,3.,3.,3.,3.,3.,3.,3., 1.,3.,3.,3.,1.,0.,0.,3.);\n\tif (y ==  5) col = SPRROW(x,2.,2.,3.,3.,3.,3.,3.,3., 1.,1.,1.,1.,1.,0.,0.,3.);\n\tif (y ==  4) col = SPRROW(x,2.,2.,2.,0.,1.,1.,3.,1., 1.,2.,1.,1.,2.,1.,3.,3.);\n\tif (y ==  3) col = SPRROW(x,0.,2.,0.,3.,1.,1.,1.,1., 1.,1.,1.,1.,1.,1.,3.,3.);\n\tif (y ==  2) col = SPRROW(x,0.,0.,3.,3.,3.,1.,1.,1., 1.,1.,1.,1.,1.,1.,3.,3.);\n\tif (y ==  1) col = SPRROW(x,0.,3.,3.,3.,1.,1.,1.,1., 1.,1.,1.,0.,0.,0.,0.,0.);\n\tif (y ==  0) col = SPRROW(x,0.,3.,0.,0.,1.,1.,1.,1., 0.,0.,0.,0.,0.,0.,0.,0.);\n\t\n\tcol = SELECT(mod(float(x),8.0),col);\n\tif (col == 0.0) return RGB(0,0,0);\n\tif (col == 1.0) return RGB(177,52,37);\n\tif (col == 2.0) return RGB(227,157,37);\n\tif (col == 3.0) return RGB(106,107,4);\n\treturn RGB(0,0,0);\n}\n\nvec4 sprMarioWalk3(int x, int y)\n{\n\tfloat col = 0.0;\n\tif (y == 15) col = SPRROW(x,0.,0.,0.,0.,0.,1.,1.,1., 1.,1.,0.,0.,0.,0.,0.,0.);\n\tif (y == 14) col = SPRROW(x,0.,0.,0.,0.,1.,1.,1.,1., 1.,1.,1.,1.,1.,0.,0.,0.);\n\tif (y == 13) col = SPRROW(x,0.,0.,0.,0.,3.,3.,3.,2., 2.,3.,2.,0.,0.,0.,0.,0.);\n\tif (y == 12) col = SPRROW(x,0.,0.,0.,3.,2.,3.,2.,2., 2.,3.,2.,2.,2.,0.,0.,0.);\n\tif (y == 11) col = SPRROW(x,0.,0.,0.,3.,2.,3.,3.,2., 2.,2.,3.,2.,2.,2.,0.,0.);\n\tif (y == 10) col = SPRROW(x,0.,0.,0.,3.,3.,2.,2.,2., 2.,3.,3.,3.,3.,0.,0.,0.);\n\tif (y ==  9) col = SPRROW(x,0.,0.,0.,0.,0.,2.,2.,2., 2.,2.,2.,2.,0.,0.,0.,0.);\n\tif (y ==  8) col = SPRROW(x,0.,0.,3.,3.,3.,3.,1.,1., 3.,3.,0.,0.,0.,0.,0.,0.);\n\t\n\tif (y ==  7) col = SPRROW(x,2.,2.,3.,3.,3.,3.,1.,1., 1.,3.,3.,3.,2.,2.,2.,0.);\n\tif (y ==  6) col = SPRROW(x,2.,2.,2.,0.,3.,3.,1.,2., 1.,1.,1.,3.,3.,2.,2.,0.);\n\tif (y ==  5) col = SPRROW(x,2.,2.,0.,0.,1.,1.,1.,1., 1.,1.,1.,0.,0.,3.,0.,0.);\n\tif (y ==  4) col = SPRROW(x,0.,0.,0.,1.,1.,1.,1.,1., 1.,1.,1.,1.,3.,3.,0.,0.);\n\tif (y ==  3) col = SPRROW(x,0.,0.,1.,1.,1.,1.,1.,1., 1.,1.,1.,1.,3.,3.,0.,0.);\n\tif (y ==  2) col = SPRROW(x,0.,3.,3.,1.,1.,1.,0.,0., 0.,1.,1.,1.,3.,3.,0.,0.);\n\tif (y ==  1) col = SPRROW(x,0.,3.,3.,3.,0.,0.,0.,0., 0.,0.,0.,0.,0.,0.,0.,0.);\n\tif (y ==  0) col = SPRROW(x,0.,0.,3.,3.,3.,0.,0.,0., 0.,0.,0.,0.,0.,0.,0.,0.);\n\t\n\tcol = SELECT(mod(float(x),8.0),col);\n\tif (col == 0.0) return RGB(0,0,0);\n\tif (col == 1.0) return RGB(177,52,37);\n\tif (col == 2.0) return RGB(227,157,37);\n\tif (col == 3.0) return RGB(106,107,4);\n\treturn RGB(0,0,0);\n}\n\n\nvec4 sprMarioWalk2(int x, int y)\n{\n\tfloat col = 0.0;\n\tif (y == 15) col = SPRROW(x,0.,0.,0.,0.,0.,1.,1.,1., 1.,1.,0.,0.,0.,0.,0.,0.);\n\tif (y == 14) col = SPRROW(x,0.,0.,0.,0.,1.,1.,1.,1., 1.,1.,1.,1.,1.,0.,0.,0.);\n\tif (y == 13) col = SPRROW(x,0.,0.,0.,0.,3.,3.,3.,2., 2.,3.,2.,0.,0.,0.,0.,0.);\n\tif (y == 12) col = SPRROW(x,0.,0.,0.,3.,2.,3.,2.,2., 2.,3.,2.,2.,2.,0.,0.,0.);\n\tif (y == 11) col = SPRROW(x,0.,0.,0.,3.,2.,3.,3.,2., 2.,2.,3.,2.,2.,2.,0.,0.);\n\tif (y == 10) col = SPRROW(x,0.,0.,0.,3.,3.,2.,2.,2., 2.,3.,3.,3.,3.,0.,0.,0.);\n\tif (y ==  9) col = SPRROW(x,0.,0.,0.,0.,0.,2.,2.,2., 2.,2.,2.,2.,0.,0.,0.,0.);\n\tif (y ==  8) col = SPRROW(x,0.,0.,0.,0.,3.,3.,1.,3., 3.,3.,0.,0.,0.,0.,0.,0.);\n\t\n\tif (y ==  7) col = SPRROW(x,0.,0.,0.,3.,3.,3.,3.,1., 1.,3.,3.,0.,0.,0.,0.,0.);\n\tif (y ==  6) col = SPRROW(x,0.,0.,0.,3.,3.,3.,1.,1., 2.,1.,1.,2.,0.,0.,0.,0.);\n\tif (y ==  5) col = SPRROW(x,0.,0.,0.,3.,3.,3.,3.,1., 1.,1.,1.,1.,0.,0.,0.,0.);\n\tif (y ==  4) col = SPRROW(x,0.,0.,0.,1.,3.,3.,2.,2., 2.,1.,1.,1.,0.,0.,0.,0.);\n\tif (y ==  3) col = SPRROW(x,0.,0.,0.,0.,1.,3.,2.,2., 1.,1.,1.,0.,0.,0.,0.,0.);\n\tif (y ==  2) col = SPRROW(x,0.,0.,0.,0.,0.,1.,1.,1., 3.,3.,3.,0.,0.,0.,0.,0.);\n\tif (y ==  1) col = SPRROW(x,0.,0.,0.,0.,0.,3.,3.,3., 3.,3.,3.,3.,0.,0.,0.,0.);\n\tif (y ==  0) col = SPRROW(x,0.,0.,0.,0.,0.,3.,3.,3., 3.,0.,0.,0.,0.,0.,0.,0.);\n\t\n\tcol = SELECT(mod(float(x),8.0),col);\n\tif (col == 0.0) return RGB(0,0,0);\n\tif (col == 1.0) return RGB(177,52,37);\n\tif (col == 2.0) return RGB(227,157,37);\n\tif (col == 3.0) return RGB(106,107,4);\n\treturn RGB(0,0,0);\n}\n\n\nvec4 sprMarioWalk1(int x, int y)\n{\n\tfloat col = 0.0;\n\tif (y == 15) col = SPRROW(x,0.,0.,0.,0.,0.,0.,0.,0., 0.,0.,0.,0.,0.,0.,0.,0.);\n\tif (y == 14) col = SPRROW(x,0.,0.,0.,0.,0.,0.,1.,1., 1.,1.,1.,0.,0.,0.,0.,0.);\n\tif (y == 13) col = SPRROW(x,0.,0.,0.,0.,0.,1.,1.,1., 1.,1.,1.,1.,1.,1.,0.,0.);\n\tif (y == 12) col = SPRROW(x,0.,0.,0.,0.,0.,3.,3.,3., 2.,2.,3.,2.,0.,0.,0.,0.);\n\tif (y == 11) col = SPRROW(x,0.,0.,0.,0.,3.,2.,3.,2., 2.,2.,3.,2.,2.,2.,0.,0.);\n\tif (y == 10) col = SPRROW(x,0.,0.,0.,0.,3.,2.,3.,3., 2.,2.,2.,3.,2.,2.,2.,0.);\n\tif (y ==  9) col = SPRROW(x,0.,0.,0.,0.,3.,3.,2.,2., 2.,2.,3.,3.,3.,3.,0.,0.);\n\tif (y ==  8) col = SPRROW(x,0.,0.,0.,0.,0.,0.,2.,2., 2.,2.,2.,2.,2.,0.,0.,0.);\n\t\n\tif (y ==  7) col = SPRROW(x,0.,0.,0.,0.,0.,3.,3.,3., 3.,1.,3.,0.,2.,0.,0.,0.);\n\tif (y ==  6) col = SPRROW(x,0.,0.,0.,0.,2.,3.,3.,3., 3.,3.,3.,2.,2.,2.,0.,0.);\n\tif (y ==  5) col = SPRROW(x,0.,0.,0.,2.,2.,1.,3.,3., 3.,3.,3.,2.,2.,0.,0.,0.);\n\tif (y ==  4) col = SPRROW(x,0.,0.,0.,3.,3.,1.,1.,1., 1.,1.,1.,1.,0.,0.,0.,0.);\n\tif (y ==  3) col = SPRROW(x,0.,0.,0.,3.,1.,1.,1.,1., 1.,1.,1.,1.,0.,0.,0.,0.);\n\tif (y ==  2) col = SPRROW(x,0.,0.,3.,3.,1.,1.,1.,0., 1.,1.,1.,0.,0.,0.,0.,0.);\n\tif (y ==  1) col = SPRROW(x,0.,0.,3.,0.,0.,0.,0.,3., 3.,3.,0.,0.,0.,0.,0.,0.);\n\tif (y ==  0) col = SPRROW(x,0.,0.,0.,0.,0.,0.,0.,3., 3.,3.,3.,0.,0.,0.,0.,0.);\n\t\n\tcol = SELECT(mod(float(x),8.0),col);\n\tif (col == 0.0) return RGB(0,0,0);\n\tif (col == 1.0) return RGB(177,52,37);\n\tif (col == 2.0) return RGB(227,157,37);\n\tif (col == 3.0) return RGB(106,107,4);\n\treturn RGB(0,0,0);\n}\n\nvec4 getTile(int t, int x, int y)\n{\n\tif (t == 0) return RGB(107,140,255);\n\tif (t == 1) return sprGround(x,y);\n\tif (t == 2) return sprQuestionBlock(x,y);\n\tif (t == 3) return sprUsedBlock(x,y);\n\t\n\treturn RGB(107,140,255);\n}\n\nint getSection(int s, int x, int y)\n{\n\tfloat col = 0.0;\n\tif (s == 0) {\n\t\tif (y == 6) col = SECROW(x,0.,0.,0.,0.,0.,0.,0.,0.);\n\t\tif (y == 5) col = SECROW(x,0.,0.,0.,0.,0.,0.,0.,0.);\n\t\tif (y == 4) col = SECROW(x,0.,0.,3.,3.,3.,0.,0.,0.);\n\t\tif (y == 3) col = SECROW(x,0.,0.,2.,2.,2.,0.,0.,0.);\n\t\tif (y == 2) col = SECROW(x,0.,0.,0.,0.,0.,0.,0.,0.);\n\t\tif (y == 1) col = SECROW(x,0.,0.,0.,0.,0.,0.,0.,0.);\n\t\tif (y <= 0) col = SECROW(x,1.,1.,1.,1.,1.,1.,1.,1.);\n\t}\n\tif (s == 1) {\n\t\tif (y == 6) col = SECROW(x,0.,0.,0.,0.,0.,0.,0.,0.);\n\t\tif (y == 5) col = SECROW(x,0.,0.,0.,0.,0.,0.,0.,0.);\n\t\tif (y == 4) col = SECROW(x,0.,0.,0.,0.,0.,0.,0.,0.);\n\t\tif (y == 3) col = SECROW(x,0.,0.,0.,0.,0.,0.,0.,0.);\n\t\tif (y == 2) col = SECROW(x,0.,0.,0.,0.,0.,1.,0.,0.);\n\t\tif (y == 1) col = SECROW(x,0.,0.,0.,1.,1.,1.,0.,0.);\n\t\tif (y <= 0) col = SECROW(x,1.,1.,1.,1.,1.,1.,1.,1.);\n\t}\n\tif (s == 2) {\n\t\tif (y == 6) col = SECROW(x,0.,0.,0.,0.,0.,0.,0.,0.);\n\t\tif (y == 5) col = SECROW(x,0.,0.,0.,0.,0.,0.,0.,0.);\n\t\tif (y == 4) col = SECROW(x,0.,0.,3.,0.,0.,3.,0.,0.);\n\t\tif (y == 3) col = SECROW(x,0.,0.,2.,0.,0.,2.,0.,0.);\n\t\tif (y == 2) col = SECROW(x,0.,0.,0.,0.,0.,0.,0.,0.);\n\t\tif (y == 1) col = SECROW(x,0.,0.,0.,0.,0.,0.,0.,0.);\n\t\tif (y <= 0) col = SECROW(x,1.,1.,1.,1.,1.,1.,1.,1.);\n\t}\n\tif (s == 3) {\n\t\tif (y == 6) col = SECROW(x,0.,0.,0.,0.,0.,0.,0.,0.);\n\t\tif (y == 5) col = SECROW(x,0.,0.,0.,0.,0.,0.,0.,0.);\n\t\tif (y == 4) col = SECROW(x,0.,0.,0.,0.,0.,0.,0.,0.);\n\t\tif (y == 3) col = SECROW(x,0.,0.,0.,0.,0.,0.,0.,0.);\n\t\tif (y == 2) col = SECROW(x,0.,0.,0.,1.,1.,0.,0.,0.);\n\t\tif (y == 1) col = SECROW(x,0.,0.,0.,1.,1.,1.,0.,0.);\n\t\tif (y <= 0) col = SECROW(x,1.,1.,1.,1.,1.,1.,1.,1.);\n\t}\n\tif (s == 4) {\n\t\tif (y == 6) col = SECROW(x,0.,0.,0.,0.,3.,0.,0.,0.);\n\t\tif (y == 5) col = SECROW(x,0.,0.,0.,0.,2.,0.,0.,0.);\n\t\tif (y == 4) col = SECROW(x,0.,0.,0.,0.,0.,0.,0.,0.);\n\t\tif (y == 3) col = SECROW(x,0.,0.,0.,0.,0.,0.,0.,0.);\n\t\tif (y == 2) col = SECROW(x,0.,0.,0.,1.,1.,1.,0.,0.);\n\t\tif (y == 1) col = SECROW(x,0.,0.,0.,1.,1.,1.,0.,0.);\n\t\tif (y <= 0) col = SECROW(x,1.,1.,1.,1.,1.,1.,1.,1.);\n\t}\n\tif (s == 5) {\n\t\tif (y == 6) col = SECROW(x,0.,0.,0.,0.,0.,0.,0.,0.);\n\t\tif (y == 5) col = SECROW(x,0.,0.,0.,0.,0.,0.,0.,0.);\n\t\tif (y == 4) col = SECROW(x,0.,0.,0.,0.,0.,0.,0.,0.);\n\t\tif (y == 3) col = SECROW(x,0.,0.,0.,0.,0.,0.,0.,0.);\n\t\tif (y == 2) col = SECROW(x,0.,0.,0.,0.,0.,0.,0.,0.);\n\t\tif (y == 1) col = SECROW(x,0.,0.,0.,0.,0.,0.,0.,0.);\n\t\tif (y <= 0) col = SECROW(x,1.,1.,1.,0.,0.,1.,1.,1.);\n\t}\n\t\n\t\n\t\n\treturn int(SELECTSEC(mod(float(x),4.0),col));\n}\n\nint getBlock(int x, int y)\n{\n#ifdef TOTALLY_RANDOM_LEVEL\n\tint height = 1 + int(rand(vec2(int(float(x) / 3.0),2.3)) * 3.0);\n\treturn (y < height ? 1 : 0);\n#else\n\tif (y > 6) return 0;\n\t\n\tint section = int(rand(vec2(int(float(x) / 8.0),3.0)) * 6.0);\n\tint sectionX = int(mod(float(x), 8.0));\n\t\n\treturn getSection(section,sectionX,y - int(rand(vec2(section,2.0)) * 0.0));\n#endif\n}\n\nbool isSolid(int b)\n{\n\treturn (b != 0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tconst float gameSpeed = 60.0;\n\t\n\t// Get the current game pixel\n\t// (Each game pixel is two screen pixels)\n\t//  (or four, if the screen is larger)\n\tfloat x = fragCoord.x / 2.0;\n\tfloat y = fragCoord.y / 2.0;\n\tif (iResolution.y >= 640.0) {\n\t\tx /= 2.0;\n\t\ty /= 2.0;\n\t}\n\tif (iResolution.y < 200.0) {\n\t\tx *= 2.0;\n\t\ty *= 2.0;\n\t}\n\t\n\t// Just move the screen up for half a block's size\n\ty -= 8.0;\n\n\t// Get the grid index of the block at this pixel,\n\t// and of the block at the screen's leftmost position\n\tint firstBlockX = int((iTime * gameSpeed) / 16.0);\n\tint blockX = int((x + iTime * gameSpeed) / 16.0);\n\tint blockY = int(y / 16.0);\n\t\n\t// Ask for the block ID that exists in the current position\n\tint block = getBlock(blockX,blockY);\n\t\n\t// Get the fractional position inside current block\n\tint subx = int(mod((x + iTime * gameSpeed),16.0));\n\tint suby = int(mod(y,16.0));\n\t\n\t// Animate block if it's a Question Block\n\tif (block == 2) {\n\t\tif (blockX - firstBlockX == 5) {\n\t\t\tsuby -= int(max(0.0,(sin(mod((iTime * gameSpeed / 16.0),1.0) * 3.141592 * 1.5) * 8.0)));\n\t\t}\n\t\t\n\t\tif ((floor((x + iTime * gameSpeed) / 16.0) - (iTime * gameSpeed) / 16.0) < 4.25) block = 3;\n\t// Animate block if it's on top of a Question Block\n\t} else if (block == 3) {\n\t\tblock = 2;\n\t\tsuby += 16;\n\t\tif (blockX - firstBlockX == 5) {\n\t\t\tsuby -= int(max(0.0,(sin(mod((iTime * gameSpeed / 16.0),1.0) * 3.141592 * 1.5) * 8.0)));\n\t\t}\n\t}\n\t// Get the final color for this pixel\n\t// (Mario can override this later on)\n\tfragColor = getTile(block,subx,suby);\n\t\n\t\n\t// If this is the column where Mario stops simulating...\n\t// (it's the only column he can appear in)\n\tif (x >= endX && x < endX + 16.0) {\n\t\t\n\t\t// Screen position in pixels:\n\t\t// Every block is 16 pixels wide\n\t\tfloat screenX = iTime * gameSpeed;\n\t\t\n\t\t// Mario's starting position and speed\n\t\tfloat marioX = screenX + startX;\n\t\tfloat marioY = 16.0;\n\t\tfloat marioXSpd = 4.0;\n\t\tfloat marioYSpd = 0.0;\n\t\t\n\t\t// Find out the first empty block in this column,\n\t\t// starting from the bottom, as to put Mario on top of it\n\t\tfor(int i = 1; i < 4; i++) {\n\t\t\tif (!isSolid(getBlock(int(marioX / 16.0), i))) {\n\t\t\t\tmarioY = float(i) * 16.0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Number of steps to simulate;\n\t\t// We'll simulate at 15 FPS and interpolate later,\n\t\t// hence the division by 4.0\n\t\t// (Mario should actually be walking 1 pixel every 1/60th of a second,\n\t\t//  but he'll be walking 4 pixels every 1/15th)\n\t\tconst int simSteps = int((endX - startX) / 4.0);\n\t\t\n\t\t// Previous position, as to interpolate later, for high frame rates\n\t\tfloat lastX = 0.0;\n\t\tfloat lastY = 0.0;\n\t\t\n\t\t// Start simulating\n\t\tbool onGround = false;\n\t\tfor(int sim = 0; sim < simSteps; sim++) {\n\t\t\t// Store the previous position\n\t\t\tlastX = marioX;\n\t\t\tlastY = marioY;\n\t\t\t\n\t\t\t// If Mario is inside a block, move him up\n\t\t\t// (This happens only at the start of the simulation,\n\t\t\t//  sometimes because he is heads-up with a wall and\n\t\t\t//  cannot make a jump properly)\n\t\t\tonGround = false;\n\t\t\tif (isSolid(getBlock(int(marioX / 16.0) + 1, int(marioY / 16.0)))) {\n\t\t\t\tmarioY = (floor(marioY / 16.0) * 16.0) + 16.0;\n\t\t\t}\n\t\t\t\n\t\t\t// Next, pretty standard platforming code\n\t\t\t\n\t\t\t// Apply gravity and move in the Y-axis\n\t\t\tmarioYSpd -= 2.5;\n\t\t\tmarioY += marioYSpd;\n\t\t\t\n\t\t\t// If he is going up,\n\t\t\t// and if there is a block above him,\n\t\t\t// align him with the grid (as to avoid getting inside the block),\n\t\t\t// and invert his YSpeed, as to fall quickly (because he bounced his head)\n\t\t\tif (marioYSpd > 0.0) {\n\t\t\t\tif (isSolid(getBlock(int(floor((marioX + 12.0) / 16.0)), int(floor((marioY + 15.9) / 16.0))))) {\n\t\t\t\t\tmarioYSpd *= -0.5;\n\t\t\t\t\tmarioY = (floor(marioY / 16.0) * 16.0);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// If he is going down,\n\t\t\t// and if there is a block beneath him,\n\t\t\t// align him with the grid (as to land properly on top of the block),\n\t\t\t// and mark him as onGround (to be able to perform a jump)\n\t\t\tif (marioYSpd < 0.0) {\n\t\t\t\tif (isSolid(getBlock(int(floor((marioX) / 16.0)), int(floor(marioY / 16.0)))) ||\n\t\t\t\t\tisSolid(getBlock(int(floor((marioX + 15.9) / 16.0)), int(floor(marioY / 16.0))))) {\n\t\t\t\t\tmarioYSpd = 0.0;\n\t\t\t\t\tmarioY = (floor(marioY / 16.0) * 16.0) + 16.0;\n\t\t\t\t\tonGround = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// Finally, move him in the X-axis\n\t\t\t// I assume here he'll never hit a block horizontally\n\t\t\tmarioX += marioXSpd;\n\t\t\t\n\t\t\t// Now, if he's onGround,\n\t\t\t// and if there are blocks in front of him,\n\t\t\t// or if there is a pit right next to him,\n\t\t\t// set his YSpeed to jump\n\t\t\tif (onGround) {\n\t\t\t\tif (!isSolid(getBlock(int((marioX) / 16.0) + 1,0))) {\n\t\t\t\t\tmarioYSpd = 15.5;\n\t\t\t\t} else if (isSolid(getBlock(int((marioX + 36.0) / 16.0), int((marioY + 24.0) / 16.0)))) {\n\t\t\t\t\tmarioYSpd = 15.5;\n\t\t\t\t} else if (isSolid(getBlock(int((marioX) / 16.0) + 2, int((marioY + 8.0) / 16.0)))) {\n\t\t\t\t\tmarioYSpd = 12.5;\n\t\t\t\t} else if (getBlock(int((marioX) / 16.0) + 1, int((marioY + 8.0) / 16.0) + 2) == 2) {\n\t\t\t\t\tmarioYSpd = 15.5;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Interpolate Y-pos for smooth high-frame-rate movement\n\t\tmarioY = mix(lastY,marioY,mod(iTime * 15.0,1.0)) - 1.0;\n\t\t\n\t\t// Finally, if he appears at this row, fetch a pixel from his sprites\n\t\tif (y >= marioY && y < marioY + 16.0) {\n\t\t\tvec4 spr = vec4(0,0,0,0);\n\t\t\tif (onGround) {\n\t\t\t\t// Which frame?\n\t\t\t\tint f = int(mod(iTime * 10.0, 3.0));\n\t\t\t\tif (f == 0) spr = sprMarioWalk1(int(x - (marioX - screenX)),int(y - marioY));\n\t\t\t\tif (f == 1) spr = sprMarioWalk2(int(x - (marioX - screenX)),int(y - marioY));\n\t\t\t\tif (f == 2) spr = sprMarioWalk3(int(x - (marioX - screenX)),int(y - marioY));\n\t\t\t} else {\n\t\t\t\tspr = sprMarioJump(int(x - (marioX - screenX)),int(y - marioY));\n\t\t\t}\n\t\t\t// Transparency check\n\t\t\tif (spr.x != 0.0) fragColor = spr;\n\t\t}\n\t}\n}",
    "tags": [
      "game",
      "sprite",
      "mario",
      "platform",
      "nes",
      "super",
      "bros",
      "jump",
      "state",
      "dynamic"
    ],
    "author": "HLorenzi",
    "views": 0,
    "likes": 132,
    "published": 3
  },
  {
    "id": "MltXz2",
    "title": "Mandelbrot - convergence",
    "description": "Visualization of the border, inner and outer radius of the convergent areas of the generalized Mandelbrot, for this article: [url]http://iquilezles.org/articles/mset_1bulb[/url]",
    "code": "// Created by inigo quilez - iq/2016\n//   https://www.youtube.com/c/InigoQuilez\n//   https://iquilezles.org/\n// I share this piece (art and code) here in Shadertoy and through its Public API, only for educational purposes. \n// You cannot use, sell, share or host this piece or modifications of it as part of your own commercial or non-commercial product, website or project.\n// You can share a link to it or an unmodified screenshot of it provided you attribute \"by Inigo Quilez, @iquilezles and iquilezles.org\". \n\n// Visualizing the analytical solution for the bounds of the plane for\n// which the dynamics of the iteration under the complex monic polynomial\n// converges.\n//\n// The derivation of the formulas are here: \n//\n// https://iquilezles.org/articles/mset1bulb\n//\n// Border:    c(w) = k^1/(1-k)\u00b7e^iw - k^k/(1-k)\u00b7e^ikw\n// Inner rad: r = k^1/(1-k) - k^k/(1-k)\n// Outer rad: R = 2^1/(k-1)\n//\n// Also, see here for the smooth iteration count formula: https://iquilezles.org/articles/msetsmooth\n\n#define AA 2\n\n//----------------------------------------------------------------\n// complex numbers\n\nvec2 cadd( vec2 a, float s ) { return vec2( a.x+s, a.y ); }\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\nvec2 cdiv( vec2 a, vec2 b )  { float d = dot(b,b); return vec2( dot(a,b), a.y*b.x - a.x*b.y ) / d; }\nvec2 cpow( vec2 z, float n ) { float r = length( z ); float a = atan( z.y, z.x ); return pow( r, n )*vec2( cos(a*n), sin(a*n) ); }\nvec2 csqrt( vec2 z )         { float m = length(z); return sqrt( 0.5*vec2(m+z.x, m-z.x) ) * vec2( 1.0, sign(z.y) ); }\nvec2 cconj( vec2 z )         { return vec2(z.x,-z.y); }\n\n//----------------------------------------------------------------\n// distance evaluators\n\nfloat lengthSquared( in vec2 v ) { return dot(v,v); }\nfloat sdSegmentSquared( vec2 p, vec2 a, vec2 b )\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn lengthSquared( pa - ba*h );\n}\n\n//----------------------------------------------------------------\n// generalized mandelbrot set, with smooth iteration count\n\nvec3 drawFractal( in float k, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.0);\n    \n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n        vec2 c = p * 1.25;\n\n        #if 0\n        if( k==2.0 )\n        {\n        float c2 = dot(c, c);\n        // skip computation inside M1 - https://iquilezles.org/articles/mset1bulb\n    \tif( 256.0*c2*c2 - 96.0*c2 + 32.0*c.x - 3.0 < 0.0 ) continue;\n    \t// skip computation inside M2 - https://iquilezles.org/articles/mset2bulb\n    \tif( 16.0*(c2+2.0*c.x+1.0) - 1.0 < 0.0 ) continue;\n        }\n        #endif\n        \n        const float threshold = 64.0;\n        vec2 z = vec2( 0.0 );\n        float it = 0.0;\n        for( int i=0; i<100; i++ )\n        {\n            z = cpow(z, k) + c;\n            if( dot(z,z)>threshold ) break;\n            it++;\n        }\n\n        vec3 tmp = vec3(0.0);\n        if( it<99.5 )\n        {\n            float sit = it - log2(log2(dot(z,z))/(log2(threshold)))/log2(k); // https://iquilezles.org/articles/msetsmooth\n            tmp = 0.5 + 0.5*cos( 3.0 + sit*0.075*k + vec3(0.0,0.6,1.0));\n        }\n        \n        col += tmp;\n#if AA>1\n    }\n    col /= float(AA*AA);\n#endif\n\n\treturn col;\n}\n\n//----------------------------------------------------------------\n// render\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float eps = 1.25/iResolution.y;\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\n    float time = iTime*0.25;\n    \n\n    vec2 c = p * 1.25;\n    //float k = 2.0 + mod(floor(time), 10.0 );\n    float k = 2.0 + floor(time) + smoothstep(0.8,1.0,fract(time));\n\n    float m = pow( k, (1.0/(1.0-k)) );\n    float n = pow( k, (k/(1.0-k)) );\n\n    // draw fractal\n    vec3 col = drawFractal( k, fragCoord );\n\n    vec3 dcol = col;\n\n    // draw convergence area\n    {\n        float d = 10.0;\n        vec2 ow = vec2( m-n, 0.0 );\n\t\tfor( int i=1; i<101; i++ )\n        {\n            float a = 6.283185*float(i)/200.0;\n            vec2 w = m*vec2( cos(a), sin(a) ) - n*vec2( cos(k*a), sin(k*a) );\n\n            d = min( d, sdSegmentSquared( vec2(c.x,abs(c.y)), ow, w ) );\n            ow = w;\n        }\n        d = sqrt(d);\n        dcol = mix( dcol, vec3(1.5,0.7,0.1), 1.0-smoothstep( 1.0*eps,6.0*eps,d) );\n    }\n    \n    // draw inner radius\n    {\n        float r = m - n;\n        float d = abs( length(c)-r );\n        dcol = mix( dcol, vec3(1.0,1.0,1.0), 1.0-smoothstep( 1.0*eps,4.0*eps,d) );\n    }\n    \n    // draw outer radius\n    {\n        float r = pow( 2.0, 1.0/(k-1.0) );\n        float d = abs( length(c)-r );\n        dcol = mix( dcol, vec3(1.0,1.0,1.0), 1.0-smoothstep( 0.0*eps,4.0*eps,d) );\n    }\n    \n    float f = smoothstep( 0.2, 0.8, 1.0 - abs(2.0*fract(time)-1.0) );\n    col = mix( col, dcol, f );\n    \n\n    fragColor = vec4( col, 1.0 );\n}",
    "tags": [
      "fractal",
      "analytic",
      "complexdynamics"
    ],
    "author": "iq",
    "views": 0,
    "likes": 68,
    "published": 3
  },
  {
    "id": "WtScDt",
    "title": "Bandlimited Synthesis 1",
    "description": "A simple way to prevent aliasing of cosine functions (the color palette in this case) by removing frequencies as oscillations become smaller than a pixel. You can think of it as an LOD system. Move the mouse to compare naive versus band-limited cos(x)",
    "code": "// The MIT License\n// Copyright \u00a9 2020 Inigo Quilez\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org/\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A simple way to prevent aliasing of cosine functions (the color\n// palette in this case is made of 8 layers) by attenuating them\n// when their oscillations become smaller than a pixel. Left is\n// direct use of cos(x), right is band-limited cos(x).\n//\n// Box-filtering of cos(x):\n//\n// (1/w)\u222bcos(t)dt with t \u2208 (x-\u00bdw, x+\u00bdw)\n// = [sin(x+\u00bdw) - sin(x-\u00bdw)]/w\n// = cos(x)\u00b7sin(\u00bdw)/(\u00bdw)\n//\n// Can approximate smoothstep(2\u03c0,0,w) \u2248 sin(w/2)/(w/2),\n// which you can also see as attenuating cos(x) when it \n// oscilates more than once per pixel. More info:\n//\n// https://iquilezles.org/articles/bandlimiting\n//\n// Related Shader:\n//   https://www.shadertoy.com/view/WtScDt\n//   https://www.shadertoy.com/view/wtXfRH\n//   https://www.shadertoy.com/view/3tScWd\n\n\n// box-filted cos(x)\nvec3 fcos( in vec3 x )\n{\n    vec3 w = fwidth(x);\n\t#if 1\n    return cos(x) * sin(0.5*w)/(0.5*w);       // exact\n\t#else\n    return cos(x) * smoothstep(6.2832,0.0,w); // approx\n\t#endif    \n}\n\n// pick raw cosine, or band-limited cosine\nbool  mode = false;\nvec3  mcos( vec3 x){return mode?cos(x):fcos(x);}\n\n// color palette, made of 8 cos functions\n// (see https://iquilezles.org/articles/palettes)\nvec3 getColor( in float t )\n{\n    vec3 col = vec3(0.6,0.5,0.4);\n    col += 0.14*mcos(6.2832*t*  1.0+vec3(0.0,0.5,0.6));\n    col += 0.13*mcos(6.2832*t*  3.1+vec3(0.5,0.6,1.0));\n    col += 0.12*mcos(6.2832*t*  5.1+vec3(0.1,0.7,1.1));\n    col += 0.11*mcos(6.2832*t*  9.1+vec3(0.1,0.5,1.2));\n    col += 0.10*mcos(6.2832*t* 17.1+vec3(0.0,0.3,0.9));\n    col += 0.09*mcos(6.2832*t* 31.1+vec3(0.1,0.5,1.3));\n    col += 0.08*mcos(6.2832*t* 65.1+vec3(0.1,0.5,1.3));\n    col += 0.07*mcos(6.2832*t*131.1+vec3(0.3,0.2,0.8));\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordiantes\n\tvec2 q = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    // separation\n    float th = (iMouse.z>0.001) ? (2.0*iMouse.x-iResolution.x)/iResolution.y : 1.8*sin(iTime);\n    mode = (q.x<th);\n    \n    // deformation\n    vec2 p = 2.0*q/dot(q,q);\n\n    // animation\n    p.xy += 0.05*iTime;\n\n    // texture\n    vec3 col = min(getColor(p.x),getColor(p.y));\n\n    // vignetting\n    col *= 1.5 - 0.2*length(q);\n    \n    // separation\n    col *= smoothstep(0.005,0.010,abs(q.x-th));\n    \n    // palette\n    if( q.y<-0.9 ) col = getColor( fragCoord.x/iResolution.x );\n\n    fragColor = vec4( col, 1.0 );\n}",
    "tags": [
      "2d",
      "cos",
      "filtering",
      "lod",
      "frequency",
      "bandlimited"
    ],
    "author": "iq",
    "views": 0,
    "likes": 214,
    "published": 3
  },
  {
    "id": "wlGXRD",
    "title": "PsychedelicSakura",
    "description": "Ex02",
    "code": "// Author Reva - 2020-02-21\n\nfloat plot(float r, float pct){\n\treturn  smoothstep( pct-0.2, pct, r) -smoothstep( pct, pct+0.2, r);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ){\n        return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = vec3(1.0);\n    vec2 pos = vec2(0.5) - uv;\n    pos.x *= iResolution.x/iResolution.y;\n    pos *= cos(iTime)*1.0+1.5;\n\n    float r = length(pos)*2.0;\n    float a = atan(pos.y,pos.x);\n\n    float f = abs(cos(a*2.5+iTime*0.5))*sin(iTime*2.0)*0.698+cos(iTime)-4.0;\n    float d = f-r;\n    \n    col = (vec3(smoothstep(fract(d),fract(d)+-0.200,0.160))-vec3(smoothstep(fract(d),fract(d)+-1.184,0.160)) ) \n\t* pal( f, vec3(0.725,0.475,0.440),vec3(0.605,0.587,0.007),vec3(1.0,1.0,1.0),vec3(0.310,0.410,0.154) );\n    float pct = plot(r*0.272,fract(d*(sin(iTime)*0.45+0.5)));\n\t\n    col += pct*pal( r, vec3(0.750,0.360,0.352),vec3(0.450,0.372,0.271),vec3(0.540,0.442,0.264),vec3(0.038,0.350,0.107) );\n\n    // Output to screen\n    fragColor = vec4(col,pct*0.3);\n}",
    "tags": [
      "2d",
      "trigonometry",
      "cineshader"
    ],
    "author": "Reva",
    "views": 0,
    "likes": 69,
    "published": 3
  },
  {
    "id": "4dl3zn",
    "title": "Bubbles",
    "description": "Happy Bubbles ^_^",
    "code": "// Copyright Inigo Quilez, 2013 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work neither\n// as it is or altered, here on Shadertoy or anywhere else, in any\n// form including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it or train a neural\n// network with it without permission. I share this Work for educational\n// purposes, and you can link to it, through an URL, proper attribution\n// and unmodified screenshot, as part of your educational material. If\n// these conditions are too restrictive please contact me and we'll\n// definitely work it out.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.0*fragCoord-iResolution.xy) / iResolution.y;\n\n    // background\t \n\tvec3 color = vec3(0.8 + 0.2*uv.y);\n\n    // bubbles\t\n\tfor( int i=0; i<40; i++ )\n\t{\n        // bubble seeds\n\t\tfloat pha =      sin(float(i)*546.13+1.0)*0.5 + 0.5;\n\t\tfloat siz = pow( sin(float(i)*651.74+5.0)*0.5 + 0.5, 4.0 );\n\t\tfloat pox =      sin(float(i)*321.55+4.1) * iResolution.x / iResolution.y;\n\n        // bubble size, position and color\n\t\tfloat rad = 0.1 + 0.5*siz;\n\t\tvec2  pos = vec2( pox, -1.0-rad + (2.0+2.0*rad)*mod(pha+0.1*iTime*(0.2+0.8*siz),1.0));\n\t\tfloat dis = length( uv - pos );\n\t\tvec3  col = mix( vec3(0.94,0.3,0.0), vec3(0.1,0.4,0.8), 0.5+0.5*sin(float(i)*1.2+1.9));\n\t\t//    col+= 8.0*smoothstep( rad*0.95, rad, dis );\n\t\t\n        // render\n\t\tfloat f = length(uv-pos)/rad;\n\t\tf = sqrt(clamp(1.0-f*f,0.0,1.0));\n\t\tcolor -= col.zyx *(1.0-smoothstep( rad*0.95, rad, dis )) * f;\n\t}\n\n    // vigneting\t\n\tcolor *= sqrt(1.5-0.5*length(uv));\n\n\tfragColor = vec4(color,1.0);\n}",
    "tags": [
      "2d"
    ],
    "author": "iq",
    "views": 0,
    "likes": 453,
    "published": 3
  },
  {
    "id": "XfyXRV",
    "title": "Let's self reflect",
    "description": "CC0: Let's self reflect\nAlways enjoyed the videos of Platonic solids with inner mirrors\nI made some previous attempts but thought I make another attempt it\n",
    "code": "// CC0: Let's self reflect\n//  Always enjoyed the videos of Platonic solids with inner mirrors\n//  I made some previous attempts but thought I make another attempt it\n\n// Reducing the alias effects on the inner reflections turned out to be a bit tricky. \n//  Simplest solution is just to run run fullscreen on a 4K screen ;)\n\n// Function to generate the solid found here: https://www.shadertoy.com/view/MsKGzw\n\n// Tinker with these parameters to create different solids\n// -------------------------------------------------------\nconst float rotation_speed= 0.25;\n\nconst float poly_U        = 1.;   // [0, inf]\nconst float poly_V        = 0.5;  // [0, inf]\nconst float poly_W        = 1.0;  // [0, inf]\nconst int   poly_type     = 3;    // [2, 5]\nconst float poly_zoom     = 2.0;\n\nconst float inner_sphere  = 1.;\n\nconst float refr_index    = 0.9;\n\n#define MAX_BOUNCES2        6\n// -------------------------------------------------------\n\n\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n#define TOLERANCE2          0.0005\n//#define MAX_RAY_LENGTH2   10.0\n#define MAX_RAY_MARCHES2    50\n#define NORM_OFF2           0.005\n#define BACKSTEP2\n\n#define TOLERANCE3          0.0005\n#define MAX_RAY_LENGTH3     10.0\n#define MAX_RAY_MARCHES3    90\n#define NORM_OFF3           0.005\n\nconst vec3 rayOrigin    = vec3(0.0, 1., -5.);\nconst vec3 sunDir       = normalize(-rayOrigin);\n\n\nconst vec3 sunCol       = HSV2RGB(vec3(0.06 , 0.90, 1E-2))*1.;\nconst vec3 bottomBoxCol = HSV2RGB(vec3(0.66, 0.80, 0.5))*1.;\nconst vec3 topBoxCol    = HSV2RGB(vec3(0.60, 0.90, 1.))*1.;\nconst vec3 glowCol0     = HSV2RGB(vec3(0.05 , 0.7, 1E-3))*1.;\nconst vec3 glowCol1     = HSV2RGB(vec3(0.95, 0.7, 1E-3))*1.;\nconst vec3 beerCol      = -HSV2RGB(vec3(0.15+0.5, 0.7, 2.)); \nconst float rrefr_index = 1./refr_index;\n\n\n// License: Unknown, author: knighty, found: https://www.shadertoy.com/view/MsKGzw\nconst float poly_cospin   = cos(PI/float(poly_type));\nconst float poly_scospin  = sqrt(0.75-poly_cospin*poly_cospin);\nconst vec3  poly_nc       = vec3(-0.5, -poly_cospin, poly_scospin);\nconst vec3  poly_pab      = vec3(0., 0., 1.);\nconst vec3  poly_pbc_     = vec3(poly_scospin, 0., 0.5);\nconst vec3  poly_pca_     = vec3(0., poly_scospin, poly_cospin);\nconst vec3  poly_p        = normalize((poly_U*poly_pab+poly_V*poly_pbc_+poly_W*poly_pca_));\nconst vec3  poly_pbc      = normalize(poly_pbc_);\nconst vec3  poly_pca      = normalize(poly_pca_);\n\nmat3 g_rot;\nvec2 g_gd;\n  \n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/noacos/\nmat3 rot(vec3 d, vec3 z) {\n  vec3  v = cross( z, d );\n  float c = dot( z, d );\n  float k = 1.0/(1.0+c);\n\n  return mat3( v.x*v.x*k + c,     v.y*v.x*k - v.z,    v.z*v.x*k + v.y,\n               v.x*v.y*k + v.z,   v.y*v.y*k + c,      v.z*v.y*k - v.x,\n               v.x*v.z*k - v.y,   v.y*v.z*k + v.x,    v.z*v.z*k + c    );\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6;\n  float a = 2.51;\n  float b = 0.03;\n  float c = 2.43;\n  float d = 0.59;\n  float e = 0.14;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0, 1.0);\n}\n\nfloat sphere(vec3 p, float r) {\n  return length(p) - r;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions/\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n  \n// License: Unknown, author: knighty, found: https://www.shadertoy.com/view/MsKGzw\nvoid poly_fold(inout vec3 pos) {\n  vec3 p = pos;\n\n  for(int i = 0; i < poly_type; ++i){\n    p.xy  = abs(p.xy);\n    p    -= 2.*min(0., dot(p,poly_nc)) * poly_nc;\n  }\n  \n  pos = p;\n}\n\nfloat poly_plane(vec3 pos) {\n  float d0 = dot(pos, poly_pab);\n  float d1 = dot(pos, poly_pbc);\n  float d2 = dot(pos, poly_pca);\n  float d = d0;\n  d = max(d, d1);\n  d = max(d, d2);\n  return d;\n}\n\nfloat poly_corner(vec3 pos) {\n  float d = length(pos) - .0125;\n  return d;\n}\n\nfloat dot2(vec3 p) {\n  return dot(p, p);\n}\n\nfloat poly_edge(vec3 pos) {\n  float dla = dot2(pos-min(0., pos.x)*vec3(1., 0., 0.));\n  float dlb = dot2(pos-min(0., pos.y)*vec3(0., 1., 0.));\n  float dlc = dot2(pos-min(0., dot(pos, poly_nc))*poly_nc);\n  return sqrt(min(min(dla, dlb), dlc))-2E-3;\n}\n\nvec3 shape(vec3 pos) {\n  pos *= g_rot;\n  pos /= poly_zoom;\n  poly_fold(pos);\n  pos -= poly_p;\n\n  return vec3(poly_plane(pos), poly_edge(pos), poly_corner(pos))*poly_zoom;\n}\n\nvec3 render0(vec3 ro, vec3 rd) {\n  vec3 col = vec3(0.0);\n  \n  float srd  = sign(rd.y);\n  float tp   = -(ro.y-6.)/abs(rd.y);\n\n  if (srd < 0.) {\n    col += bottomBoxCol*exp(-0.5*(length((ro + tp*rd).xz)));\n  }\n\n  if (srd > 0.0) {\n    vec3 pos  = ro + tp*rd;\n    vec2 pp = pos.xz;\n    float db = box(pp, vec2(5.0, 9.0))-3.0;\n    \n    col += topBoxCol*rd.y*rd.y*smoothstep(0.25, 0.0, db);\n    col += 0.2*topBoxCol*exp(-0.5*max(db, 0.0));\n    col += 0.05*sqrt(topBoxCol)*max(-db, 0.0);\n  }\n\n\n  col += sunCol/(1.001-dot(sunDir, rd));\n  return col; \n}\n\nfloat df2(vec3 p) {\n  vec3 ds = shape(p);\n  float d2 = ds.y-5E-3;\n  float d0 = min(-ds.x, d2);\n  float d1 = sphere(p, inner_sphere);\n  g_gd = min(g_gd, vec2(d2, d1));\n  float d = (min(d0, d1));\n  return d;\n}\n\nfloat rayMarch2(vec3 ro, vec3 rd, float tinit) {\n  float t = tinit;\n#if defined(BACKSTEP2)\n  vec2 dti = vec2(1e10,0.0);\n#endif\n  int i;\n  for (i = 0; i < MAX_RAY_MARCHES2; ++i) {\n    float d = df2(ro + rd*t);\n#if defined(BACKSTEP2)\n    if (d<dti.x) { dti=vec2(d,t); }\n#endif  \n    // Bouncing in a closed shell, will never miss\n    if (d < TOLERANCE2/* || t > MAX_RAY_LENGTH3 */) {\n      break;\n    }\n    t += d;\n  }\n#if defined(BACKSTEP2)\n  if(i==MAX_RAY_MARCHES2) { t=dti.y; };\n#endif  \n  return t;\n}\n\nvec3 normal2(vec3 pos) {\n  vec2  eps = vec2(NORM_OFF2,0.0);\n  vec3 nor;\n  nor.x = df2(pos+eps.xyy) - df2(pos-eps.xyy);\n  nor.y = df2(pos+eps.yxy) - df2(pos-eps.yxy);\n  nor.z = df2(pos+eps.yyx) - df2(pos-eps.yyx);\n  return normalize(nor);\n}\n\nvec3 render2(vec3 ro, vec3 rd, float db) {\n  vec3 agg = vec3(0.0);\n  float ragg = 1.;\n  float tagg = 0.;\n  \n  for (int bounce = 0; bounce < MAX_BOUNCES2; ++bounce) {\n    if (ragg < 0.1) break;\n    g_gd      = vec2(1E3);\n    float t2  = rayMarch2(ro, rd, min(db+0.05, 0.3));\n    vec2 gd2  = g_gd;\n    tagg      += t2;\n    \n    vec3 p2   = ro+rd*t2;\n    vec3 n2   = normal2(p2);\n    vec3 r2   = reflect(rd, n2);\n    vec3 rr2  = refract(rd, n2, rrefr_index);\n    float fre2= 1.+dot(n2,rd);\n    \n    vec3 beer = ragg*exp(0.2*beerCol*tagg);\n    agg += glowCol1*beer*((1.+tagg*tagg*4E-2)*6./max(gd2.x, 5E-4+tagg*tagg*2E-4/ragg));\n    vec3 ocol = 0.2*beer*render0(p2, rr2);\n    if (gd2.y <= TOLERANCE2) {\n      ragg *= 1.-0.9*fre2;\n    } else {\n      agg     += ocol;\n      ragg    *= 0.8;\n    }\n    \n    ro        = p2;\n    rd        = r2;\n    db        = gd2.x; \n  }\n\n\n  return agg;\n}\n\nfloat df3(vec3 p) {\n  vec3 ds = shape(p);\n  g_gd = min(g_gd, ds.yz);\n  const float sw = 0.02;\n  float d1 = min(ds.y, ds.z)-sw;\n  float d0 = ds.x;\n  d0 = min(d0, ds.y);\n  d0 = min(d0, ds.z);\n  return d0;\n}\n\nfloat rayMarch3(vec3 ro, vec3 rd, float tinit, out int iter) {\n  float t = tinit;\n  int i;\n  for (i = 0; i < MAX_RAY_MARCHES3; ++i) {\n    float d = df3(ro + rd*t);\n    if (d < TOLERANCE3 || t > MAX_RAY_LENGTH3) {\n      break;\n    }\n    t += d;\n  }\n  iter = i;\n  return t;\n}\n\nvec3 normal3(vec3 pos) {\n  vec2  eps = vec2(NORM_OFF3,0.0);\n  vec3 nor;\n  nor.x = df3(pos+eps.xyy) - df3(pos-eps.xyy);\n  nor.y = df3(pos+eps.yxy) - df3(pos-eps.yxy);\n  nor.z = df3(pos+eps.yyx) - df3(pos-eps.yyx);\n  return normalize(nor);\n}\n\nvec3 render3(vec3 ro, vec3 rd) {\n  int iter;\n\n  vec3 skyCol = render0(ro, rd);\n  vec3 col  = skyCol;\n\n  g_gd      = vec2(1E3);\n  float t1  = rayMarch3(ro, rd, 0.1, iter);\n  vec2 gd1  = g_gd;\n  vec3 p1   = ro+t1*rd;\n  vec3 n1   = normal3(p1);\n  vec3 r1   = reflect(rd, n1);\n  vec3 rr1  = refract(rd, n1, refr_index);\n  float fre1= 1.+dot(rd, n1);\n  fre1 *= fre1;\n\n  float ifo = mix(0.5, 1., smoothstep(1.0, 0.9, float(iter)/float(MAX_RAY_MARCHES3)));\n\n  if (t1 < MAX_RAY_LENGTH3) {\n    col = render0(p1, r1)*(0.5+0.5*fre1)*ifo;\n    vec3 icol = render2(p1, rr1, gd1.x); \n    if (gd1.x > TOLERANCE3 && gd1.y > TOLERANCE3 && rr1 != vec3(0.)) {\n      col += icol*(1.-0.75*fre1)*ifo;\n    }\n  }\n\n  col += (glowCol0+1.*fre1*(glowCol0))/max(gd1.x, 3E-4);\n  return col;\n\n}\n\n  \nvec3 effect(vec2 p, vec2 pp) {\n  const float fov = 2.0;\n  \n  const vec3 up = vec3(0., 1., 0.);\n  const vec3 la   = vec3(0.0);\n\n  const vec3 ww = normalize(normalize(la-rayOrigin));\n  const vec3 uu = normalize(cross(up, ww));\n  const vec3 vv = cross(ww, uu);\n  \n  vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww);\n\n  vec3 col = vec3(0.0);\n  col = render3(rayOrigin, rd);\n  \n  col -= 2E-2*vec3(2.,3.,1.)*(length(p)+0.25);\n  col = aces_approx(col);\n  col = sqrt(col);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  float a = TIME*rotation_speed;\n  vec3 r0 = vec3(1.0, sin(vec2(sqrt(0.5), 1.0)*a));\n  vec3 r1 = vec3(cos(vec2(sqrt(0.5), 1.0)*0.913*a), 1.0);\n  mat3 rot = rot(normalize(r0), normalize(r1));\n  g_rot = rot;\n\n  vec3 col = effect(p, pp);\n  \n  fragColor = vec4(col, 1.0);\n}\n\n",
    "tags": [
      "refraction"
    ],
    "author": "mrange",
    "views": 0,
    "likes": 445,
    "published": 3
  },
  {
    "id": "wlGGWG",
    "title": "Ashanoha",
    "description": "traning. \u9ebb\u306e\u8449",
    "code": "#define PI  \t3.14159265357989\n#define TAU \t(PI * 2.0)\n#define HEX_COS (0.86602540378443 * 0.5)\n#define HEX_TAN (0.57735026918962 * 0.5)\n\n\nstruct Animation\n{\n    float screenAngle;\n    float screenScale;\n    vec2  screenOffset;\n    float lineWidth;\n    float lineColorOffset;\n    float meshColorOffset;\n    float meshColorDist;\n    float lightAngle;\n    float blendLine;\n    float blendSolid;\n    float blendMesh;\n};\n\n\nmat2 rotate(float angle)\n{\n    float s = sin(angle), c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\nvec2 pmod(vec2 pos, float num, out float id)\n{\n    float angle = atan(pos.x, pos.y) + PI / num;\n    float split = TAU / num;\n    id = floor(angle / split);\n\tangle = id * split;\n    return rotate(-angle) * pos;\n}\n\nfloat cubicInOut(float time)\n{\n  return (time < 0.5) ? (4.0 * time * time * time) : (1.0 - 4.0 * pow(1.0 - time, 3.0));\n}\n\n// for line\nvoid map(vec2 uv, out vec3 near, out vec3 neighbor)\n{\n    vec2 point;\n    near = vec3(1e+4);\n\n    for(float y=-1.0; y<=1.0; y+=2.0)\n    {\n        point = vec2(0.0, HEX_COS + y * HEX_TAN * 0.25);\n        float dist = distance(uv, point);\n        near = near.z < dist ? near : vec3(point, dist);\n    }\n    \n    for(float x=-1.0; x<=1.0; x+=2.0)\n    {\n\t    for(float y=-1.0; y<=1.0; y+=2.0)\n        {\n            for(float both=-1.0; both<=1.0; both+=2.0)\n            {\n                point = vec2(x * 0.125, HEX_COS + y * HEX_COS * 0.5);\n                point.x += both * 0.5     * 0.125 * -x;\n                point.y += both * HEX_TAN * 0.125 * -y;\n                float dist = distance(uv, point);\n                near = near.z < dist ? near : vec3(point, dist);\n            }\n        }\n    }\n    \n    neighbor = vec3(1e+4);\n    \n    for(float y=-1.0; y<=1.0; y+=2.0)\n    {\n        point = vec2(0.0, HEX_COS + y * HEX_TAN * 0.25);\n        if(near.xy != point)\n        {\n            vec2 center = (point + near.xy) * 0.5;\n            float dist = dot(uv - center, normalize(near.xy - point));\n            neighbor = neighbor.z < dist ? neighbor : vec3(point, dist);\n        }\n    }\n    \n    for(float x=-1.0; x<=1.0; x+=2.0)\n    {\n\t    for(float y=-1.0; y<=1.0; y+=2.0)\n        {\n            for(float both=-1.0; both<=1.0; both+=2.0)\n            {\n                point = vec2(x * 0.125, HEX_COS + y * HEX_COS * 0.5);\n                point.x += both * 0.5     * 0.125 * -x;\n                point.y += both * HEX_TAN * 0.125 * -y;\n                \n                if(near.xy != point)\n                {\n                    vec2 center = (point + near.xy) * 0.5;\n                    float dist = dot(uv - center, normalize(near.xy - point));\n                    neighbor = neighbor.z < dist ? neighbor : vec3(point, dist);\n                }\n            }\n        }\n    }\n}\n\n// for normal\nvec4 normalmap(vec2 uv)\n{\n    vec2 point = vec2(0);\n    vec3 near = vec3(1e+4);\n    vec3 neighbor = vec3(1e+4);\n    \n    for(float y=-1.0; y<=1.0; y+=2.0)\n    {\n        point = vec2(0.0, HEX_COS + y * HEX_TAN * 0.5);\n        float dist = distance(uv, point);\n        near = near.z < dist ? near : vec3(point, dist);\n    }\n    \n\tfor(float y=-1.0; y<=1.0; y+=2.0)\n    {\n        point = vec2(0.0, HEX_COS + y * HEX_TAN * 0.5);\n        if(near.xy != point)\n        {\n            vec2 center = (point + near.xy) * 0.5;\n            float dist = dot(uv - center, normalize(near.xy - point));\n            neighbor = neighbor.z < dist ? neighbor : vec3(point, dist);\n        }\n    }\n    \n    for(float x=-1.0; x<=1.0; x+=2.0)\n    {\n\t    for(float y=-1.0; y<=1.0; y+=2.0)\n        {\n            point = vec2(x * 0.25, HEX_COS - y * (HEX_COS - HEX_TAN * 0.5));\n            vec2 center = (point + near.xy) * 0.5;\n            float dist = dot(uv - center, normalize(near.xy - point));\n            neighbor = neighbor.z < dist ? neighbor : vec3(point, dist);\n        }\n    }\n    \n    return vec4(normalize(vec3(neighbor.xy - near.xy, 1.0)), neighbor.z);\n}\n\nvoid animate(float time, vec2 uv, inout Animation anim)\n{\n    float animLoop = floor(floor(time) / 13.0);\n    float animType = mod(floor(time), 13.0);\n    float animTime = fract(time);\n    float clockwise = mod(animLoop, 2.0) <= 0.0 ? 1.0 : -1.0;\n    \n    anim.screenScale = 2.0;\n    anim.screenAngle = PI * 0.166667;\n    anim.screenOffset= vec2(0, 0);\n    anim.lineWidth   = 0.01;\n    anim.lineColorOffset = 0.0;\n    anim.meshColorOffset = 0.0;\n    anim.meshColorDist = 200.0;\n    anim.lightAngle = 0.0;\n    anim.blendLine = 0.0;\n    anim.blendMesh = 0.0;\n    anim.blendSolid = 0.0;\n    \n    if(animType <= 0.0)\n    {\n        anim.screenScale = cubicInOut(animTime) * 1.0 + 1.0;\n    \tanim.lineWidth   = cubicInOut(1.0 - animTime) * 0.4 + 0.01;\n    \tanim.lineColorOffset = animTime;\n    \tanim.blendLine = 1.0;\n    }\n    else if(animType <= 1.0)\n    {\n        anim.screenScale -= animTime * 0.02;\n    \tanim.lineColorOffset = PI * 2.0 * animTime;\n    \tanim.blendLine = 1.0;\n    }\n    else if(animType <= 2.0)\n    {\n        anim.screenScale -= animTime * 0.02 + 0.02;\n    \tanim.lineColorOffset = PI * 2.0 * animTime;\n        anim.meshColorOffset = PI * 3.0 * animTime;\n    \tanim.blendLine = smoothstep(1.0, 0.0, animTime);\n    \tanim.blendMesh = smoothstep(0.0, 1.0, animTime);\n    }\n    else if(animType <= 3.0)\n    {\n        anim.screenScale -= animTime * 0.02 + 0.04;\n        anim.meshColorOffset = PI * 3.0 * animTime + PI;\n    \tanim.meshColorDist = smoothstep(1.0, 0.2, animTime) * 200.0;\n   \t \tanim.lightAngle  = PI * 2.0 * time;\n    \tanim.blendMesh = smoothstep(0.8, 0.2, animTime);\n    \tanim.blendSolid = smoothstep(0.0, 1.0, animTime);\n    }\n    else if(animType <= 4.0)\n    {\n        anim.screenScale -= animTime * 0.02 + 0.06;\n    \tanim.blendSolid = 1.0;\n    }\n    else if(animType <= 10.0)\n    {\n        animTime += animType - 5.0;\n        anim.screenScale -= clamp(animTime * 0.02 + 0.08, 0.0, 0.1);\n        animTime /= 11.0 - 5.0;\n        anim.screenAngle += smoothstep(0.0, 1.0, animTime) * PI * 0.5 * clockwise;\n        \n        uv = rotate(PI * 2.0 * animTime * clockwise) * uv;\n        float pos = abs(uv.x + 0.0) + animTime;\n        float blend = smoothstep(-0.1, 0.0, sin(pos * PI * 3.0 * sin(animTime * PI)));\n    \tanim.blendSolid = blend;\n        anim.blendLine = 1.0 - blend;\n    \tanim.lineColorOffset = PI * 2.0 * animTime;\n    }\n    else if(animType <= 11.0)\n    {\n        anim.screenScale -= 0.1;\n        anim.screenAngle += PI * 0.5 * clockwise;\n        anim.lightAngle += PI * 2.0 * animTime;\n    \tanim.blendSolid = 1.0;\n    }\n    else if(animType <= 12.0)\n    {\n        anim.screenScale -= 0.1;\n        anim.screenAngle += PI * 0.5 * clockwise;\n        anim.lightAngle += PI * 2.0 * animTime;\n\n        float lineTime = (sin(animTime * PI * 3.0 - PI * 0.5) * 0.5 + 0.5);\n        lineTime = lineTime * lineTime * (animTime - (uv.x * uv.y * 0.2));\n        anim.lineWidth = clamp(lineTime, 0.0, 1.0) * 0.5;\n        anim.blendLine = 1.0;\n    \tanim.blendSolid = 1.0;\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n \n    // animation\n    Animation anim;\n    animate(iTime, uv, anim);\n    \n    // view\n    uv *= anim.screenScale;\n    uv += anim.screenOffset;\n    uv = rotate(anim.screenAngle) * uv;\n\n    // tiling\n    vec2 uvLocal = uv;\n    uvLocal.x = mod(uv.x, 1.0) - 0.5;\n    uvLocal.y = mod(uv.y, HEX_COS * 2.0) - HEX_COS;\n    \n    // rot tiling\n    float id;\n    uvLocal = pmod(uvLocal, 6.0, id);\n\n    // scene\n    vec3 near, neighbor;\n    map(uvLocal, near, neighbor);\n    \n    // lighting\n    vec4 normal = normalmap(uvLocal);\n    normal.xy = rotate(id * PI / 3.0) * normal.xy;\n    float dist = normal.w;\n    dist = 1.0 - pow(1.0 - dist, 20.0);\n\n    vec3 lightDir = normalize(vec3(rotate(anim.lightAngle) * vec2(1,0), 0.25));\n    float light = dot(normal.xyz, lightDir) * 0.8 + 0.2;\n    \n    // draw\n    float lineWidth = (1.0 - smoothstep(0.0, anim.lineWidth, neighbor.z));\n    vec3 lineColor = cos(vec3(0,2,4) * PI / 3.0 + anim.lineColorOffset) * 0.25 + 1.0;\n    vec3 meshColor = cos(vec3(0,2,4) * PI / 3.0 + anim.meshColorOffset + anim.meshColorDist * neighbor.z) * 0.35 + 0.65;\n    float solid = (dist * light) * 0.6 + 0.2;\n    solid = 1.0 - pow(1.0 - solid, 3.0);\n    \n    fragColor.rgb = vec3(0);\n    fragColor.rgb = mix(fragColor.rgb, vec3(solid), anim.blendSolid);\n    fragColor.rgb = mix(fragColor.rgb, lineColor, lineWidth * anim.blendLine);\n    fragColor.rgb = mix(fragColor.rgb, meshColor, anim.blendMesh);\n    \n    // degamma\n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0 / 2.2));\n    \n    // displacement\n    fragColor.a = mix(0.0, normal.w * 4.0, anim.blendSolid);\n    \n    // debug\n    //fragColor.gb = vec2(0);\n    //fragColor.r = 1.0 - pow(1.0 - near.z, 5.0);\n    //fragColor.r = neighbor.z * 10.0;\n    //fragColor.r = normal.w * 7.0;\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"Ashanoha\",\n\t\"description\": \"soundproof cushion\",\n\t\"model\": \"car\"\n}\n*/",
    "tags": [
      "pattern",
      "japanese",
      "traning",
      "cineshader"
    ],
    "author": "coposuke",
    "views": 0,
    "likes": 71,
    "published": 3
  },
  {
    "id": "ts3yD7",
    "title": "Timeless depths - cineshader",
    "description": "A timeless depths, constantly mutating over time.\n\nA raymarch experiment based on the tutorial by The Art Of Code: https://www.youtube.com/watch?v=-adHIyjIYgk",
    "code": "// Copyright 2020 - Giovanni Muzio\n// https://kesson.io\n//\n// Full Shadertoy version https://www.shadertoy.com/view/ttlyWB\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n\n#define MAX_STEPS 100\n#define MAX_DIST 8.\n#define SURF_DIST .001\n#define GYROID_DETAILS 12\n#define WIDEANGLE 0 // set this to 1 for a wide angle pseudo-distortion\n\nmat2 rotate(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdGyroid(vec3 p, float s, float t, float b) {\n    vec3 st = p * s;\n    \n    float lx = 1.0 + ((sin(iTime * 0.0576) * 0.5) + 0.5) * 0.25;    \n    float ly = 1.0 + ((cos(iTime * 0.0565) * 0.5) + 0.5) * 0.25;\n    \n    float ls = max(lx, ly);\n    \n    return abs(dot(sin(st * lx), cos(st.zxy * ly)) - b) / (s * ls) - t;\n}\n\nvec3 transform(vec3 p) {\n    p.xy *= rotate(p.z * 0.1);\n    p.z += iTime * 0.1;\n    p.y -= 0.3;\n    return p;\n}\n\nfloat GetDist(vec3 p) {\n    p = transform(p);\n        \n    float s = 10.798;\n    float t = 0.03;\n    float b = 0.3;\n    float m = 0.5;\n    \n    float s1 = 1.345 + ((sin(iTime* 0.01) * 0.5) + 0.5);\n    float g1 = sdGyroid(p, s1, 0.03, 1.5);\n    \n    for (int i = 0; i < GYROID_DETAILS; i++) {\n        if (i <= 1) g1 -= sdGyroid(p, s, t, b) * m;\n        else g1 += sdGyroid(p, s, t, b) * m;\n        s *= 1.75;\n        m *= 0.75;\n    }\n    \n    float d = g1 * 0.7;\n   \t\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvec3 bg(vec3 rd) {\n\tvec3 col = vec3(0.0);\n    float t = iTime * 0.2;\n    \n    float y = clamp(smoothstep(0.3, 1.0, rd.y * 0.5 + 0.5), 0.1, 1.0);\n    col += y * vec3(0.05, 0.18, 0.38) * 6.0;\n    \n    float a = atan(rd.x, rd.z);\n    float flares = 0.7 * sin(a*20.+t)*sin(a*2.-t)*sin(a*6.);\n    flares *= smoothstep(.0, 1.0, y);\n    col += flares;\n    col = max(col, 0.);    \n    return col;\n}\n\nvec3 getDiff(vec3 p, vec3 rd) {\n    vec3 n = GetNormal(p);\n    return reflect(rd, n);\n}\n\n// Camera matrix and movement from https://www.shadertoy.com/view/ldl3Dl\nvoid camera(float cd, vec2 uv, float an, out vec3 ro, out vec3 rd) {\n    ro = vec3( cd*cos(an), cd * sin(an), cd*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    rd = normalize( uv.x*uu + uv.y*vv + 2.0*ww );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    if (WIDEANGLE == 1) {\n    \tuv += sin(uv*2.0); // wideangle distortion\n    }\n            \n    vec3 col = vec3(0.0);\n    \n    float t = iTime * 0.01;\n    \n    uv += sin(uv*20.+t)*.01;\n    \n    float an = -iTime * 0.05;\n    \n    vec3 ro, rd;\n    float cd = 0.01; // camera distance\n    camera(cd, uv, an, ro, rd); // get the camera\n    \n    float d = RayMarch(ro, rd);\n    \n    if(d<MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n    \tvec3 n = GetNormal(p);\n        vec3 dr = getDiff(p, rd);\n    \tcol =vec3(0.0);\n        \n        p = transform(p);\n        \n    \tfloat dif = dot(n, normalize(vec3(0.0,0.0,1.0)))*.5+.5;\n        col *= dif;\n    \tcol += dif;\n        \n        float b = sdGyroid(p, 10.798, 0.03, 0.3);\n        col *= smoothstep(-0.05, 0.1, b);\n        \n        float cw = -0.02 + smoothstep(0.0, -0.5, n.y) * 0.02;\n        float c = smoothstep(cw, -0.03, b);\n        float cc = 1.0 - (sdGyroid(p+t, 6.789, 0.03, 0.3) * 4.0);\n        float cc2 = 1.0 - (sdGyroid(p-t*0.5, 3.789, 0.03, 0.3) * 2.0);\n        col += c * vec3(0.1, 0.4, 1.0) * cc * cc2 * 3.0;\n    }\n    \n    col = mix(col, bg(rd), smoothstep(0.0, MAX_DIST, d));\n    \n    fragColor = vec4(col,d / 3.0);\n}",
    "tags": [
      "cineshader"
    ],
    "author": "kesson",
    "views": 0,
    "likes": 25,
    "published": 3
  },
  {
    "id": "WtfyDj",
    "title": "Paint streams",
    "description": "Cellular automaton particle tracking used for advection in a fluid which is also fully conservative\nEach pixel has 1 virtual particle\nhttps://michaelmoroz.github.io/Reintegration-Tracking/",
    "code": "vec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 mixN(vec3 a, vec3 b, float k)\n{\n    return sqrt(mix(a*a, b*b, clamp(k,0.,1.)));\n}\n\nvec4 V(vec2 p)\n{\n    return pixel(ch1, p);\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{\n\tR = iResolution.xy; time = iTime;\n    //pos = R*0.5 + pos*0.1;\n    ivec2 p = ivec2(pos);\n    \n    vec4 data = texel(ch0, pos);\n    particle P = getParticle(data, pos);\n    \n    //border render\n    vec3 Nb = bN(P.X);\n    float bord = smoothstep(2.*border_h,border_h*0.5,border(pos));\n    \n    vec4 rho = V(pos);\n    vec3 dx = vec3(-2., 0., 2.);\n    vec4 grad = -0.5*vec4(V(pos + dx.zy).zw - V(pos + dx.xy).zw,\n                         V(pos + dx.yz).zw - V(pos + dx.yx).zw);\n    vec2 N = pow(length(grad.xz),0.2)*normalize(grad.xz+1e-5);\n    float specular = pow(max(dot(N, Dir(1.4)), 0.), 3.5);\n    float specularb = G(0.4*(Nb.zz - border_h))*pow(max(dot(Nb.xy, Dir(1.4)), 0.), 3.);\n    \n    float a = pow(smoothstep(fluid_rho*0., fluid_rho*2., rho.z),0.1);\n    float b = exp(-1.7*smoothstep(fluid_rho*1., fluid_rho*7.5, rho.z));\n    vec3 col0 = vec3(1., 0.5, 0.);\n    vec3 col1 = vec3(0.1, 0.4, 1.);\n\tvec3 fcol = mixN(col0, col1, tanh(3.*(rho.w - 0.7))*0.5 + 0.5);\n    // Output to screen\n    col = vec4(3.);\n    col.xyz = mixN(col.xyz, fcol.xyz*(1.5*b + specular*5.), a);\n    col.xyz = mixN(col.xyz, 0.*vec3(0.5,0.5,1.), bord);\n    col.xyz = tanh(col.xyz);\n}",
    "tags": [
      "particles",
      "ca"
    ],
    "author": "michael0884",
    "views": 0,
    "likes": 653,
    "published": 3
  },
  {
    "id": "MtcXWr",
    "title": "Ray tracing a cone",
    "description": "Highschool maths galore.",
    "code": "/*\n\nThis shader demonstrates solving the intersection of\na ray and a cone for ray tracing.\n\nThe math is detailed on this page:\nhttp://lousodrome.net/blog/light/2017/01/03/intersection-of-a-ray-and-a-cone/\n\n--\nZavie\n\n*/\n\n// Uncomment to test the case in which the\n// camera is aligned with the apex of the cone:\n//#define CORNER_CASE_CAMERA_ALIGNED_WITH_APEX\n\n#define MAX_BOUNCES 2\nfloat gamma = 2.2;\n\n// ---8<----------------------------------------------------------------------\n// Material\n\nstruct Material\n{\n    vec3 c;\t\t// diffuse color\n    float f0;\t// specular color (monochrome)\n};\n\n// ---8<----------------------------------------------------------------------\n// Geometry\n\n#define PI acos(-1.)\nfloat hash(float x) { return fract(sin(x) * 43758.5453); }\n\nstruct Ray\n{\n    vec3 o;\t\t// origin\n    vec3 d;\t\t// direction\n};\n\nstruct Hit\n{\n    float t;\t// solution to p=o+t*d\n    vec3 n;\t\t// normal\n    Material m;\t// material\n};\nconst Hit noHit = Hit(1e10, vec3(0.), Material(vec3(-1.), -1.));\n\nstruct Plane\n{\n    float d;\t// solution to dot(n,p)+d=0\n    vec3 n;\t\t// normal\n    Material m;\t// material\n};\n\nstruct Disc\n{\n    vec3 p;     // center position\n    vec3 n;     // normal\n    float r;    // radius\n    Material m;\t// material\n};\n \nstruct Sphere\n{\n\tfloat r;\t// radius\n    vec3 p;\t\t// center position\n    Material m;\t// material\n};\n\nstruct Cone\n{\n    float cosa;\t// half cone angle\n    float h;\t// height\n    vec3 c;\t\t// tip position\n    vec3 v;\t\t// axis\n    Material m;\t// material\n};\n\nHit intersectPlane(Plane p, Ray r)\n{\n    float dotnd = dot(p.n, r.d);\n    if (dotnd > 0.) return noHit;\n\n    float t = -(dot(r.o, p.n) + p.d) / dotnd;\n    return Hit(t, p.n, p.m);\n}\n\nHit intersectDisc(Disc d, Ray r)\n{\n    Hit hit = intersectPlane(Plane(-dot(d.p, d.n), d.n, d.m), r);\n    vec3 p = r.o + r.d * hit.t;\n    if (length(p - d.p) > d.r) return noHit;\n\n    return hit;\n}\n\nHit intersectSphere(Sphere s, Ray r)\n{\n\tvec3 op = s.p - r.o;\n    float b = dot(op, r.d);\n    float det = b * b - dot(op, op) + s.r * s.r;\n    if (det < 0.) return noHit;\n\n    det = sqrt(det);\n    float t = b - det;\n    if (t < 0.) t = b + det;\n    if (t < 0.) return noHit;\n\n    return Hit(t, (r.o + t*r.d - s.p) / s.r, s.m);\n}\n\nHit intersectCone(Cone s, Ray r)\n{\n    vec3 co = r.o - s.c;\n\n    float a = dot(r.d,s.v)*dot(r.d,s.v) - s.cosa*s.cosa;\n    float b = 2. * (dot(r.d,s.v)*dot(co,s.v) - dot(r.d,co)*s.cosa*s.cosa);\n    float c = dot(co,s.v)*dot(co,s.v) - dot(co,co)*s.cosa*s.cosa;\n\n    float det = b*b - 4.*a*c;\n    if (det < 0.) return noHit;\n\n    det = sqrt(det);\n    float t1 = (-b - det) / (2. * a);\n    float t2 = (-b + det) / (2. * a);\n\n    // Determine which of the t, if any, is a solution:\n    bool hitFound = false;\n    float t;\n    vec3 cp;\n    if (t1 >= 0.0)\n    {\n        vec3 cp1 = r.o + t1 * r.d - s.c;\n        float h = dot(cp1, s.v);\n        if (h >= 0.0 && h <= s.h)\n        {\n            hitFound = true;\n            t = t1;\n            cp = cp1;\n        }\n    }\n    if (t2 >= 0.0 && (!hitFound || t2 < t))\n    {\n        vec3 cp2 = r.o + t2 * r.d - s.c;\n        float h = dot(cp2, s.v);\n        if (h >= 0.0 && h <= s.h)\n        {\n            hitFound = true;\n            t = t2;\n            cp = cp2;\n        }\n    }\n\n    if (!hitFound) return noHit;\n\n    vec3 n = normalize(cp * dot(s.v, cp) / dot(cp, cp) - s.v);\n\n    return Hit(t, n, s.m);\n}\n\nvec3 randomVector(float seed)\n{\n    float r2 = hash(seed);\n    float phi = 2. * PI * hash(seed + r2);\n    float sina = sqrt(r2);\n    float cosa = sqrt(1. - r2);\n\n\treturn vec3(cos(phi) * sina, cosa, sin(phi) * sina);\n}\n\nbool compare(inout Hit a, Hit b)\n{\n    if (b.m.f0 >= 0. && b.t < a.t)\n    {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nHit intersectScene(Ray r)\n{\n    vec3 axis1 = randomVector(floor(iTime));\n    vec3 axis2 = randomVector(floor(iTime+1.));\n    vec3 axis = normalize(mix(axis1, axis2, fract(iTime)));\n    vec3 translation = vec3(4.*abs(2.*fract(iTime/8.)-1.) - 2., 2., 1.);\n\n#ifdef CORNER_CASE_CAMERA_ALIGNED_WITH_APEX\n    axis = vec3(0., 0., 1.);\n    translation.yz = vec2(1.1, 2.);\n#endif\n\n    float coneHeight = 2.;\n    float cosa = 0.95;\n\n    Sphere s = Sphere(1., vec3(1., 1., 0.), Material(vec3(0.5), 0.04));\n    Plane p  = Plane(0., vec3(0., 1., 0.), Material(vec3(0.5, 0.4, 0.3), 0.04));\n    Cone c = Cone(cosa, coneHeight, translation, -axis, Material(vec3(1., 0., 0.), 0.02));\n    Disc d = Disc(translation - coneHeight * axis, -axis, coneHeight * sqrt(1./(cosa*cosa) - 1.), Material(vec3(1., 0., 0.), 0.02));\n\n    Hit hit = noHit;\n    compare(hit, intersectPlane(p, r));\n    compare(hit, intersectSphere(s, r));\n    compare(hit, intersectCone(c, r));\n    compare(hit, intersectDisc(d, r));\n    return hit;\n}\n\n// ---8<----------------------------------------------------------------------\n// Light\n\nstruct DirectionalLight\n{\n    vec3 d;\t\t// Direction\n    vec3 c;\t\t// Color\n};\n\nDirectionalLight sunLight = DirectionalLight(normalize(vec3(1., .5, .5)), vec3(1e3));\nvec3 skyColor(vec3 d)\n{\n    float transition = pow(smoothstep(0.02, .5, d.y), 0.4);\n\n    vec3 sky = 2e2*mix(vec3(0.52, 0.77, 1), vec3(0.12, 0.43, 1), transition);\n    vec3 sun = sunLight.c * pow(abs(dot(d, sunLight.d)), 5000.);\n    return sky + sun;\n}\n\nfloat pow5(float x) { return x * x * x * x * x; }\n\n// Schlick approximation\nfloat fresnel(vec3 h, vec3 v, float f0)\n{\n    return pow5(1. - clamp(dot(h, v), 0., 1.)) * (1. - f0) + f0;\n}\n\nfloat epsilon = 4e-4;\n\nvec3 accountForDirectionalLight(vec3 p, vec3 n, DirectionalLight l)\n{\n    if (intersectScene(Ray(p + epsilon * l.d, l.d)).m.f0 < 0.)\n    {\n        return clamp(dot(n, l.d), 0., 1.) * l.c;\n    }\n\treturn vec3(0.);\n}\n\nvec3 radiance(Ray r)\n{\n    vec3 accum = vec3(0.);\n    vec3 attenuation = vec3(1.);\n\n    for (int i = 0; i <= MAX_BOUNCES; ++i)\n    {\n        Hit hit = intersectScene(r);\n\n        if (hit.m.f0 >= 0.)\n        {\n            float f = fresnel(hit.n, -r.d, hit.m.f0);\n\n            vec3 hitPos = r.o + hit.t * r.d;\n\n            // Diffuse\n            vec3 incoming = vec3(0.);\n            incoming += accountForDirectionalLight(hitPos, hit.n, sunLight);\n\n            accum += (1. - f) * attenuation * hit.m.c * incoming;\n\n            // Specular: next bounce\n            attenuation *= f;\n            vec3 d = reflect(r.d, hit.n);\n            r = Ray(r.o + hit.t * r.d + epsilon * d, d);\n        }\n        else\n        {\n            accum += attenuation * skyColor(r.d);\n            break;\n        }\n    }\n    return accum;\n}\n\n// ---8<----------------------------------------------------------------------\n// Tone mapping\n\n// See: http://filmicgames.com/archives/75\nvec3 Uncharted2ToneMapping(vec3 color)\n{\n\tfloat A = 0.15;\n\tfloat B = 0.50;\n\tfloat C = 0.10;\n\tfloat D = 0.20;\n\tfloat E = 0.02;\n\tfloat F = 0.30;\n\tfloat W = 11.2;\n\tfloat exposure = 0.012;\n\tcolor *= exposure;\n\tcolor = ((color * (A * color + C * B) + D * E) / (color * (A * color + B) + D * F)) - E / F;\n\tfloat white = ((W * (A * W + C * B) + D * E) / (W * (A * W + B) + D * F)) - E / F;\n\tcolor /= white;\n\tcolor = pow(color, vec3(1. / gamma));\n\treturn color;\n}\n\n// ---8<----------------------------------------------------------------------\n// Scene\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n\n    float o1 = 0.25;\n    float o2 = 0.75;\n    vec2 msaa[4];\n    msaa[0] = vec2( o1,  o2);\n    msaa[1] = vec2( o2, -o1);\n    msaa[2] = vec2(-o1, -o2);\n    msaa[3] = vec2(-o2,  o1);\n\n    vec3 color = vec3(0.);\n    for (int i = 0; i < 4; ++i)\n    {\n        vec3 p0 = vec3(0., 1.1, 4.);\n        vec3 p = p0;\n        vec3 offset = vec3(msaa[i] / iResolution.y, 0.);\n        vec3 d = normalize(vec3(iResolution.x/iResolution.y * uv.x, uv.y, -1.5) + offset);\n        Ray r = Ray(p, d);\n        color += radiance(r) / 4.;\n    }\n\n\tfragColor = vec4(Uncharted2ToneMapping(color),1.0);\n}\n",
    "tags": [
      "raytracing",
      "cone",
      "analytic",
      "conics"
    ],
    "author": "Zavie",
    "views": 0,
    "likes": 50,
    "published": 3
  },
  {
    "id": "4df3Rn",
    "title": "Mandelbrot - smooth",
    "description": "A zoom in the Mandelbrot set, that showcases the difference between the regular iteration count coloring and the smooth iteration count coloring. See here: [url]https://iquilezles.org/articles/msetsmooth/[/url]",
    "code": "// Created by inigo quilez - iq/2013\n//   https://www.youtube.com/c/InigoQuilez\n//   https://iquilezles.org\n// I share this piece (art and code) here in Shadertoy and through its Public API, only for educational purposes. \n// You cannot use, sell, share or host this piece or modifications of it as part of your own commercial or non-commercial product, website or project.\n// You can share a link to it or an unmodified screenshot of it provided you attribute \"by Inigo Quilez, @iquilezles and iquilezles.org\". \n// If you are a teacher, lecturer, educator or similar and these conditions are too restrictive for your needs, please contact me and we'll work it out.\n\n\n// See here for more information on smooth iteration count:\n//\n// https://iquilezles.org/articles/msetsmooth\n\n\n// increase this if you have a very fast GPU\n#define AA 2\n\n\n\n\nfloat mandelbrot( in vec2 c )\n{\n    #if 1\n    {\n        float c2 = dot(c, c);\n        // skip computation inside M1 - https://iquilezles.org/articles/mset1bulb\n        if( 256.0*c2*c2 - 96.0*c2 + 32.0*c.x - 3.0 < 0.0 ) return 0.0;\n        // skip computation inside M2 - https://iquilezles.org/articles/mset2bulb\n        if( 16.0*(c2+2.0*c.x+1.0) - 1.0 < 0.0 ) return 0.0;\n    }\n    #endif\n\n    const float B = 256.0;\n    float n = 0.0;\n    vec2 z  = vec2(0.0);\n    for( int i=0; i<512; i++ )\n    {\n        z = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\n        if( dot(z,z)>(B*B) ) break;\n        n += 1.0;\n    }\n\n    if( n>511.0 ) return 0.0;\n    \n    // ------------------------------------------------------\n    // smooth interation count\n    //float sl = l - log(log(length(z))/log(B))/log(2.0);\n\n    // equivalent optimized smooth interation count\n    float sn = n - log2(log2(dot(z,z))) + 4.0;\n\n    float al = smoothstep( -0.1, 0.0, sin(0.5*6.2831*iTime ) );\n    return mix( n, sn, al );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.0);\n    \n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord.xy+vec2(float(m),float(n))/float(AA)))/iResolution.y;\n        float w = float(AA*m+n);\n        float time = iTime + 0.5*(1.0/24.0)*w/float(AA*AA);\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n        float time = iTime;\n#endif\n    \n        float zoo = 0.62 + 0.38*cos(.07*time);\n        float coa = cos( 0.15*(1.0-zoo)*time );\n        float sia = sin( 0.15*(1.0-zoo)*time );\n        zoo = pow( zoo,8.0);\n        vec2 xy = vec2( p.x*coa-p.y*sia, p.x*sia+p.y*coa);\n        vec2 c = vec2(-.745,.186) + xy*zoo;\n\n        float l = mandelbrot(c);\n\n        col += (l<0.5) ? vec3(0.0,0.0,0.0) : \n               0.5 + 0.5*cos( 3.0 + l*0.15 + vec3(0.0,0.6,1.0));\n#if AA>1\n    }\n    col /= float(AA*AA);\n#endif\n\n    fragColor = vec4( col, 1.0 );\n}",
    "tags": [
      "2d",
      "fractal",
      "mandelbrot"
    ],
    "author": "iq",
    "views": 0,
    "likes": 153,
    "published": 3
  },
  {
    "id": "Msf3WH",
    "title": "Noise - simplex - 2D",
    "description": "Simplex Noise. Potentially cheaper than \"Value Noise\" and \"Gradient Noise\" (especially when extrapoalted to 3D).",
    "code": "// The MIT License\n// Copyright \u00a9 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org\n\n\n// Simplex Noise (http://en.wikipedia.org/wiki/Simplex_noise), a type of gradient noise\n// that uses N+1 vertices for random gradient interpolation instead of 2^N as in regular\n// latice based Gradient Noise.\n\n// All noise functions here:\n//\n// https://www.shadertoy.com/playlist/fXlXzf&from=0&num=12\n\n\n\nvec2 hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\n// -----------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy / iResolution.xy;\n\n\tvec2 uv = p*vec2(iResolution.x/iResolution.y,1.0) + iTime*0.25;\n\t\n\tfloat f = 0.0;\n\t\n    // left: value noise\t\n\tif( p.x<0.6 )\n\t{\n\t\tf = noise( 16.0*uv );\n\t}\n    // right: fractal noise (4 octaves)\n    else\t\n\t{\n\t\tuv *= 5.0;\n        mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\t\tf  = 0.5000*noise( uv ); uv = m*uv;\n\t\tf += 0.2500*noise( uv ); uv = m*uv;\n\t\tf += 0.1250*noise( uv ); uv = m*uv;\n\t\tf += 0.0625*noise( uv ); uv = m*uv;\n\t}\n\n\tf = 0.5 + 0.5*f;\n\t\n    f *= smoothstep( 0.0, 0.005, abs(p.x-0.6) );\t\n\t\n\tfragColor = vec4( f, f, f, 1.0 );\n}",
    "tags": [
      "procedural",
      "2d",
      "noise",
      "perlin"
    ],
    "author": "iq",
    "views": 0,
    "likes": 127,
    "published": 3
  },
  {
    "id": "WlcXR4",
    "title": "Fractal.4",
    "description": "Old fractal exploration for CineShader",
    "code": "vec2 f(vec2 x, vec2 c) {\n    return mat2(x,-x.y,x.x)*x + c;\n}\n\nvec3 palette(float t, vec3 a, vec3 b, vec3 c, vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;uv *= 1.3;uv += 0.5;\n    vec4 col = vec4(1.0);\n    float time = iTime;\n    \n    int u_maxIterations = 75;\n    \n    float r = 0.7885*(sin((time/3.) - 1.57)*0.2+0.85);\n\tvec2 c = vec2(r*cos((time/3.)), r*sin((time/3.)));\n    \n    vec2 z = vec2(0.);\n    z.x = 3.0 * (uv.x - 0.5);\n    z.y = 2.0 * (uv.y - 0.5);\n    bool escaped = false;\n    int iterations;\n    for (int i = 0; i < 10000; i++) {\n        if (i > u_maxIterations) break;\n        iterations = i;\n        z = f(z, c);\n        if (dot(z,z) > 4.0) {\n            escaped = true;\n            break;\n        }\n    }\n\t\t\t\n    vec3 iterationCol = vec3(palette(float(iterations)/ float(u_maxIterations),\n                                     vec3(0.5),\n                                     vec3(0.5),\n                                     vec3(1.0, 1.0, 0.0),\n                                     vec3(0.3 + 0.3 * sin(time),\n                                          0.2 + 0.2 * sin(1. + time),\n                                          0.2  + 0.2 * sin(1.5 + time))));\n\t\t\n\tvec3 coreCol = vec3(0.);\n\t\n    float f_ite = float(iterations);\n    float f_maxIte = float(u_maxIterations);\n    fragColor = vec4(escaped ? iterationCol : coreCol, f_ite/f_maxIte );\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"Fractal.4\",\n\t\"description\": \"Old fractal exploration https://codepen.io/gThiesson/pen/PowYRqg\",\n\t\"model\": \"nothing\"\n}\n*/",
    "tags": [
      "fractal",
      "cineshader"
    ],
    "author": "gaetanThiesson",
    "views": 0,
    "likes": 28,
    "published": 3
  },
  {
    "id": "ttK3Wt",
    "title": "Sponge Tunnel",
    "description": "Simple Menger.",
    "code": "const float pi=acos(-1.0);\nconst float pi2=pi*2.0;\n\nmat2 rot(float a){\n    float c=cos(a), s=sin(a);\n    return mat2(c, s, -s, c);\n}\n\nvec2 pmod(vec2 p, float r){\n    float a=atan(p.x, p.y)+pi/r;\n    float n=pi2*(-sin(0.42*iTime)*sin(0.42*iTime)+0.35)/r;\n    a=floor(a/n)*n-pi;\n    return p*rot(-a);\n}\n\nfloat crossf(vec3 p, float r){\n    p=abs(p);\n    float dxy=max(p.x, p.y);\n    float dyz=max(p.y, p.z);\n    float dxz=max(p.z, p.x);\n    return min(dxy, min(dyz, dxz))-r;\n}\n\nfloat boxf(vec3 p, vec3 b){\n    p=abs(p)-b;\n    return length(max(p, 0.0))+min(max(p.x, max(p.y, p.z)), 0.0);\n}\n\n\nfloat mengersponge(vec3 p, float scale, float width){\n    float d=boxf(p, vec3(1.0));\n    float s=1.0;\n    for(int i=0; i<5; i++){\n        vec3 a=mod(p*s, 2.0)-1.0;\n        s*=scale;\n        vec3 r=1.0-scale*abs(a);\n        float c=crossf(r, width)/s;\n        d=max(d,c);\n    }\n    return d;\n}\n\nfloat map(vec3 p){\n    p=mod(p, 4.0)-2.0;\n    return mengersponge(p, 3.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=(fragCoord.xy*2.0-iResolution.xy)/min(iResolution.x, iResolution.y);\n    vec3 ro=vec3(0.0, 0.0, 8.0*iTime);\n    vec3 rd=normalize(vec3(uv, 0.8*sin(0.58*iTime)));\n    vec3 col=vec3(0);\n    float dp=0.0, dpp=0.0;\n    for(int i=0; i<99; i++){\n        vec3 pos=ro+rd*dp;\n        pos.xy*=rot(0.1*iTime);\n        pos.xy=pmod(pos.xy, 8.0);\n        float d=map(pos);\n        if(d<0.00001){\n            col=vec3(1.0-float(i)*0.02);\n            break;\n        }\n        dp+=d*0.8;\n        dpp=d*75.516;\n    }\n    fragColor=vec4(col, dpp);\n}",
    "tags": [
      "cineshadermengerspongeraymarching"
    ],
    "author": "hatuxes",
    "views": 0,
    "likes": 18,
    "published": 3
  },
  {
    "id": "3ltSW2",
    "title": "Disk - distance 2D",
    "description": "Distance to a disk",
    "code": "// The MIT License\n// Copyright \u00a9 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Signed distance to a disk\n\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and iquilezles.org/articles/distfunctions2d\n\n\nfloat sdCircle( in vec2 p, in float r ) \n{\n    return length(p)-r;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\n\tfloat d = sdCircle(p,0.5);\n    \n\t// coloring\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n    col *= 1.0 - exp(-6.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n\n    if( iMouse.z>0.001 )\n    {\n    d = sdCircle(m,0.5);\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n\tfragColor = vec4(col,1.0);\n}",
    "tags": [
      "2d",
      "distancefield",
      "sdf",
      "circle",
      "distance"
    ],
    "author": "iq",
    "views": 0,
    "likes": 73,
    "published": 3
  },
  {
    "id": "WtsBzf",
    "title": "Aeriel Flux",
    "description": "Based on Aeriel Machina https://fractalforums.org/share-a-fractal/22/df-mandelbox-variation/3547\n\nView on Cineshader @ https://www.cineshader.com/view/WtsBzf",
    "code": "float map(vec3 z0)\n{\n    float T = cos(iTime*0.002)+0.33;\n    float T2 = cos(iTime*0.015)+0.25;\n    vec4 z = vec4(z0,0.05);\n    \n    for (int n = 0; n < 8; n++) {\n        z.xyz=clamp(z.xyz, -T*T2, T*T2)*2.0-z.xyz;\n        z*=(T-0.25)/max(dot(z.xyz, z.xyz), 0.02*(T+T2));\n    }\n    return length(max(abs(z.xyz)-vec3(0.0,1.0,0.0),0.0))/z.w;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float T = sin(iTime*0.05)-1.0;\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec3 rayOri = vec3((uv - 0.5) * vec2(iResolution.x/iResolution.y, 1.0)*(1.0-T)*1024.0, 0.0);\n\tvec3 rayDir = vec3(0.0, 0.0, 0.001);\n\t\n\tfloat depth = 0.0;\n\tvec3 p;\n\t\n\tfor(int i = 0; i < 10; i++) {\n\t\tp = rayOri + rayDir * depth;\n\t\tfloat dist = map(p);\n        depth += dist;\n\t\tif (dist < 1e-7) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n    float c = 1.0-pow(depth*0.0005, 0.75);\n    fragColor = vec4(c*2.0,c*0.125,c*0.125,1.0-depth*0.00001);\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"Aeriel Flux\",\n\t\"description\": \"Intersection plane into a mandelbox-like structure\",\n\t\"model\": \"person\"\n}\n*/",
    "tags": [
      "cineshader"
    ],
    "author": "iRyanBell",
    "views": 0,
    "likes": 12,
    "published": 3
  }
]